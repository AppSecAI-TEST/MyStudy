<html>
<meta charset="UTF-8" />
<head><style type="text/css"> svg { height:auto !important; } </style>
<link rel="stylesheet" href="/Users/Mike/.vim/MarkDownRes/code-styles/solarized_light.css">
<link rel="stylesheet" href="/Users/Mike/.vim/MarkDownRes/chart-styles/chart.css">
<link href="/Users/Mike/.vim/MarkDownRes/github.css" media="all" rel="stylesheet"/>
<script src="/Users/Mike/.vim/MarkDownRes/js/highlight.min.js"></script>
<script src="/Users/Mike/.vim/MarkDownRes/js/highlight.pack.js"></script>
<script src="/Users/Mike/.vim/MarkDownRes/js/jquery-1.11.3.min.js"></script>
<script src="/Users/Mike/.vim/MarkDownRes/js/mermaid.js"></script>
<script> hljs.initHighlightingOnLoad(); window.onload = function() { mermaid.init({noteMargin: 5}, ".lang-chart"); }; </script>
</head>
<body id="content"><h2>搜索最近的店铺 or 找最多店铺的点</h2>
<p>这两个问题，应该是电商网站或者说 O2O 业务中最常用的功能。在之前，我也想过该题的解决方法。</p>
<p>第一个问题最简单的方法就是，一个 for 遍历周围所有的数据。通过欧式距离的判断，进行从小打大的排序判断，然后推送结果给用户。但是，当商铺基数足够大的时候，似乎，每次的 O(N) 操作，都是一个不小的时间开销。于是，可以通过进行地区的划分进行优化。</p>
<p>比如在二维坐标系中，划分为 N * N 的正方形区域。进行距离判断的时候，只需要查询用户当前区域和周围 8 个区域的店铺，然后进行搜索，然后排序。同时，也可以针对每个区域进行 cache，因为某个区域间的商铺的排序顺序基本不会有太大变化，而且即使是不同的距离，基本也就是 50 ~ 100 米的误差，某种程度上，用户也能接受这样的误差。</p>
<p>所以，这个角度看，似乎是个不错的解决方案，毕竟通过后台的距离判断可以进行离线操作，然后将结果显示到用户端，因为缓存的原因，查找效率也是 O(1)。而且因为是离线的计算，后续的店铺推广业务，广告业务，竞价排名等操作也能很好的集成到离线操作中。</p>
<p>但是，就纯粹的查找效率而言，GEO HASH 似乎是个更好的手段。他的主要思想就是把二维的地理坐标信息投射到一维的坐标轴中。差不多就像这样：</p>
<blockquote>
<p><img src="http://images.cnblogs.com/cnblogs_com/step1/geohash.gif" alt="映射" /></p>
</blockquote>
<p>不过具体的实际操作中，也可以是这样的顺序：</p>
<blockquote>
<p><img src="http://ww4.sinaimg.cn/mw690/7178f37ejw1emyk4zds00j20e908igmv.jpg" alt="映射" /></p>
</blockquote>
<p>这就很好玩了。但是，从业务上来看的话，究竟选取这个还是之前那个，个人还是偏向之前的算法。因为那个是我大学刚毕业那会给出的面试解法。</p>
<p>然后就是更加好玩的找店铺最多的点的算法了。这个问题的由来是这样的,在打<a href="https://hihocoder.com/contest/offers14/problem/4">Offer 收割赛</a>的时候，遇到了最后一题『剑刃风暴』，这里面的需求就是求如何通过一个固定半径的圆，尽可能多的伤害到尽可能多的英雄。</p>
<p>其实这个业务场景和 O2O 中的，查找最热地区有点类似。通常的解法，就是选点进行判定。比如二维坐标系中的 X, Y， 分别取 delta=0.1 然后进行遍历。最后求出最多的那个点。</p>
<p>To be honest, 这个方法必然是 TLE 的而且也不准确。因为，最后的精度完全取决于你的 delta 取值。</p>
<p>其实有个更好的解法，可以参考 POJ 1981 这道题的解法。</p>
<blockquote>
<p>先固定一个点 i，该点的单位圆与其他点 j 的单位圆相交，形成 i 圆上的一段弧，该弧被 j 圆覆盖。最终圆如果在该弧上，则一定能覆盖 j 点。那么问题归结于找出i圆上被覆盖次数最多的一段弧。</p>
<p>至于弧的表示，用两个极角表示，分别为起始和终止，类似于一个区间。枚举完其他点之后，得到 N-1 个区间。将其排序后，从前往后扫描，碰到起始计数 +1，碰到终止计数 -1，同时更新答案。</p>
<p>极角的求解：</p>
<p><img src="http://ww3.sinaimg.cn/large/6cbb8645jw1ep2cvup4vbj20qq0nyq4t.jpg" alt="极角的解法" /></p>
</blockquote>
</body></html>



