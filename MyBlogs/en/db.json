{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/even/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/even/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.eot","path":"fonts/chancery/apple-chancery-webfont.eot","modified":0,"renderable":1},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.woff","path":"fonts/chancery/apple-chancery-webfont.woff","modified":0,"renderable":1},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.ttf","path":"fonts/chancery/apple-chancery-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.woff2","path":"fonts/chancery/apple-chancery-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/even/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/even/source/js/src/even.js","path":"js/src/even.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/blank.gif","path":"lib/fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/fancybox_loading.gif","path":"lib/fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/fancybox_loading@2x.gif","path":"lib/fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/fancybox_overlay.png","path":"lib/fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/fancybox_sprite.png","path":"lib/fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/fancybox_sprite@2x.png","path":"lib/fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.css","path":"lib/fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.js","path":"lib/fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.pack.js","path":"lib/fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.svg","path":"fonts/chancery/apple-chancery-webfont.svg","modified":0,"renderable":1},{"_id":"themes/even/source/lib/jquery/jquery-3.1.1.min.js","path":"lib/jquery/jquery-3.1.1.min.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/fancybox_buttons.png","path":"lib/fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-media.js","path":"lib/fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/even/.eslintrc","hash":"c009059eb928e61061ded12c6777788210dcab81","modified":1483422071000},{"_id":"themes/even/.gitignore","hash":"1d54f4b6fe44e61eae3d29e95de4b2618a6619aa","modified":1483422071000},{"_id":"themes/even/LICENSE","hash":"6fd796a4c624297885ceed920ac7130a96f29a85","modified":1483422071000},{"_id":"themes/even/README.md","hash":"3c56571c42391c2356c613711608ece4d61ee1d7","modified":1483422071000},{"_id":"themes/even/_config.yml","hash":"fc04054437ec2b5ca9aacdab5b0c271e55fcbba6","modified":1483429971000},{"_id":"themes/even/package.json","hash":"1da9a5fba89597843fa69d881128cf9a821a6da3","modified":1483422071000},{"_id":"source/_posts/132Pattern.md","hash":"b3231694a12d04c8e059841ac9b78868ef04be05","modified":1483495208000},{"_id":"source/_posts/Heaters.md","hash":"f6b1d02ddd7647d8cd6512efefe8f0b2c9205f93","modified":1483507667000},{"_id":"source/_posts/NewStart.md","hash":"8e373a9c4e54ad72603e05d0edd11cdfeb3a0673","modified":1483426041000},{"_id":"source/_posts/TotalHammingDistance.md","hash":"c44ffcf424f702efdb91945decaed6e68d9e0941","modified":1483426048000},{"_id":"themes/even/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1483422071000},{"_id":"themes/even/.git/config","hash":"5ef1223485809abf438784735be8518631c5a612","modified":1483422071000},{"_id":"themes/even/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1483422059000},{"_id":"themes/even/.git/index","hash":"716749894a2bec82dced497b6b1c5e60d1c760ef","modified":1483428481000},{"_id":"themes/even/.git/packed-refs","hash":"10f165803b82c8da56e715acccaffa12802d0066","modified":1483422071000},{"_id":"themes/even/languages/default.yml","hash":"d7d6be001048ac4a038a1c16a3fd7be51fbc03c4","modified":1483422071000},{"_id":"themes/even/languages/en.yml","hash":"d7d6be001048ac4a038a1c16a3fd7be51fbc03c4","modified":1483422071000},{"_id":"themes/even/languages/zh-cn.yml","hash":"83a65fec58b88e44e600091f17ad0658d20f4a29","modified":1483422071000},{"_id":"themes/even/layout/_layout.swig","hash":"6cc0eeedb6b871c2e044bb01604408b168ff9ba6","modified":1483422071000},{"_id":"themes/even/layout/archive.swig","hash":"30971263c38e67bffb6fdd90d458f6c82a75c05d","modified":1483427895000},{"_id":"themes/even/layout/categories.swig","hash":"dc244e0ee1fc34f43d5b195b9c1f6ef6d3ad2d0d","modified":1483422071000},{"_id":"themes/even/layout/index.swig","hash":"26b2e750075218a6b54d23869324db1fd336cf0c","modified":1483428492000},{"_id":"themes/even/layout/page.swig","hash":"3a767206198efb3eb487d7061107212c2171106c","modified":1483422071000},{"_id":"themes/even/layout/post.swig","hash":"a0ed82a3aa04d3554dd654a3cf6194644ae1574c","modified":1483422071000},{"_id":"themes/even/layout/tags.swig","hash":"ae9500008d0b445d1962a34cdb59fde3106ed33a","modified":1483422071000},{"_id":"themes/even/source/favicon.ico","hash":"0505cec3b99707df7a681de37177b3cf7950cc5d","modified":1483422071000},{"_id":"themes/even/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1483422059000},{"_id":"themes/even/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1483422059000},{"_id":"themes/even/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1483422059000},{"_id":"themes/even/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1483422059000},{"_id":"themes/even/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1483422059000},{"_id":"themes/even/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1483422059000},{"_id":"themes/even/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1483422059000},{"_id":"themes/even/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1483422059000},{"_id":"themes/even/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1483422059000},{"_id":"themes/even/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1483422059000},{"_id":"themes/even/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1483422059000},{"_id":"themes/even/.git/logs/HEAD","hash":"488ab2a7f4ab0592946e61be28c81c71291da80c","modified":1483422071000},{"_id":"themes/even/layout/_partial/comments.swig","hash":"b76b54b562f32fea566c618187cdbb240a1b4352","modified":1483422071000},{"_id":"themes/even/layout/_partial/footer.swig","hash":"ddde14c49c4ed34fd3552f3596d7b31355cba264","modified":1483428511000},{"_id":"themes/even/layout/_partial/head.swig","hash":"cca6668f88f0a6114dc3e0bf8f4eda9932bc4347","modified":1483422071000},{"_id":"themes/even/layout/_partial/header.swig","hash":"804acd103aed2a844683989213ee3b9d7613a3fa","modified":1483422071000},{"_id":"themes/even/layout/_partial/pagination.swig","hash":"3843e523b9a7a1c5973d0c2de05cc88467733e09","modified":1483422071000},{"_id":"themes/even/layout/_macro/archive.swig","hash":"fe1940477c6cb2315859903aef835dcf8f32219d","modified":1483428336000},{"_id":"themes/even/layout/_macro/post.swig","hash":"8a47aee5bbab6b4f5a96eb3bfee7320a7f8538ce","modified":1483422071000},{"_id":"themes/even/layout/_script/analytics.swig","hash":"24ba4a8adcaf09c9ede76405ee732385595d8e39","modified":1483422071000},{"_id":"themes/even/layout/_script/comments.swig","hash":"256713e117d67e2caad21db52bc0d51460e4ff7e","modified":1483422071000},{"_id":"themes/even/layout/_script/libs.swig","hash":"b1bbb3d785933b71a12384de050a1a881c561436","modified":1483422071000},{"_id":"themes/even/layout/_script/theme.swig","hash":"cb81a0a6a6d5264cc6451dda3dd3a96101f89b1d","modified":1483422071000},{"_id":"themes/even/source/css/_base.scss","hash":"a6a5e21d54b2b7f019c0459ceee7367a5ed2b48e","modified":1483422071000},{"_id":"themes/even/source/css/_variables.scss","hash":"4b32cb649565e7caa1b5e09e0a6c22540813cd52","modified":1483422684000},{"_id":"themes/even/source/css/style.scss","hash":"0a405eb8f315a9ec1e32d550a456dc7651e9b261","modified":1483422071000},{"_id":"themes/even/.git/refs/heads/master","hash":"ce2aa00a7fccd272d87da2c4465a76bf8907d6fc","modified":1483422071000},{"_id":"themes/even/layout/_script/_analytics/baidu-analytics.swig","hash":"5d62309b16071f1b6952891ec8e1f1d42e38a088","modified":1483422071000},{"_id":"themes/even/layout/_script/_analytics/google-analytics.swig","hash":"f44684799386fbd4af6e5994b0c14c85eeff060c","modified":1483422071000},{"_id":"themes/even/layout/_script/_comments/disqus.swig","hash":"0502145777d65515249680d3e4611f249e3d9ff8","modified":1483422071000},{"_id":"themes/even/layout/_script/_comments/duoshou.swig","hash":"582cf94bc12b56c6a16b5f3aa0067b51f74b0d40","modified":1483422071000},{"_id":"themes/even/source/css/_common/_animation.scss","hash":"f32d2444f0ab4dcb8b811ae1bccae6073f21a988","modified":1483422071000},{"_id":"themes/even/source/css/_common/_normalize.scss","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1483422071000},{"_id":"themes/even/source/css/_common/_utils.scss","hash":"21dfd8cfdb574504b97896a282044d93d972e338","modified":1483422071000},{"_id":"themes/even/source/css/_custom/_custom.scss","hash":"d0873cd8554d515282a6792fcc3f5bd4a256b7a6","modified":1483422071000},{"_id":"themes/even/source/css/_partial/_archive.scss","hash":"4adb1a3ad3d5672a9bac1b793f3b41118bf83be0","modified":1483422071000},{"_id":"themes/even/source/css/_partial/_back-to-top.scss","hash":"c6f586ac04a9a0f3633dadf5c66be9e0c4027f1d","modified":1483422071000},{"_id":"themes/even/source/css/_partial/_categories.scss","hash":"96f47000d25ef4e0e948f8f43fa4e2983ff0d746","modified":1483422071000},{"_id":"themes/even/source/css/_partial/_footer.scss","hash":"76f3a72440be8aa1e93d8ddc5ea958777d1545ab","modified":1483422071000},{"_id":"themes/even/source/css/_partial/_header.scss","hash":"f5853dbb2002dd74a0fa631122b48586d7ddbd3b","modified":1483422071000},{"_id":"themes/even/source/css/_partial/_iconfont.scss","hash":"aa244964566da0393bcb5f536944d1c91f99235e","modified":1483422071000},{"_id":"themes/even/source/css/_partial/_pagination.scss","hash":"b24db39534e180ebcebba2e81d91d9f1d534eea1","modified":1483422071000},{"_id":"themes/even/source/css/_partial/_post.scss","hash":"f3b05f32bf5e986df1856fdbec4b2bfdb9c3f129","modified":1483422071000},{"_id":"themes/even/source/css/_partial/_tags.scss","hash":"fb4bf54b34291d5b72598a7ba4d3e370c8ad9383","modified":1483422071000},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.eot","hash":"fef78bd502f74fdbf0316123e176454cb3eb4e50","modified":1483422071000},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.woff","hash":"95beafe485d4bdbddfecbcf3b2bc9b2d9cf5f5c5","modified":1483422071000},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.ttf","hash":"5e25c531901d8a9e37ab45a7f4acdbe5324b51b6","modified":1483422071000},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.woff2","hash":"afd0f74128f1c21c5a542b2e100870e74da663b6","modified":1483422071000},{"_id":"themes/even/source/js/src/bootstrap.js","hash":"d01a401518abf0dd1e40c406cf9cda2a58a5cb1e","modified":1483422071000},{"_id":"themes/even/source/js/src/even.js","hash":"384f1f0466e88b717cd1d4ddc5a08b94c39f81fa","modified":1483422071000},{"_id":"themes/even/source/lib/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1483422071000},{"_id":"themes/even/source/lib/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1483422071000},{"_id":"themes/even/source/lib/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1483422071000},{"_id":"themes/even/source/lib/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1483422071000},{"_id":"themes/even/source/lib/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1483422071000},{"_id":"themes/even/source/lib/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1483422071000},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1483422071000},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1483422071000},{"_id":"themes/even/source/lib/fancybox/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1483422071000},{"_id":"themes/even/.git/objects/pack/pack-bceb22320e6e936d32665a41bfb4e52fdd675475.idx","hash":"7b222bf1e5617dbc9e02b36ae9acae921bffba85","modified":1483422071000},{"_id":"themes/even/source/fonts/chancery/apple-chancery-webfont.svg","hash":"a94e508f306a742637653f98c6e8827b11d3c142","modified":1483422071000},{"_id":"themes/even/source/lib/jquery/jquery-3.1.1.min.js","hash":"f647a6d37dc4ca055ced3cf64bbc1f490070acba","modified":1483422071000},{"_id":"themes/even/.git/logs/refs/heads/master","hash":"488ab2a7f4ab0592946e61be28c81c71291da80c","modified":1483422071000},{"_id":"themes/even/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1483422071000},{"_id":"themes/even/source/css/_partial/_footer/_copyright.scss","hash":"afbc0f90c674e5cd5fd7509eb1296d60b999d4e1","modified":1483422071000},{"_id":"themes/even/source/css/_partial/_footer/_social.scss","hash":"bca6a1036951c2475278bfbd3a5ce51ff861e9a3","modified":1483422071000},{"_id":"themes/even/source/css/_partial/_header/_logo.scss","hash":"f3fda6322fcc38d29cf439a422c57e09292adf68","modified":1483422071000},{"_id":"themes/even/source/css/_partial/_header/_menu.scss","hash":"c4eeed0abe9a83ff0699b649f2ffd3e6f6530556","modified":1483422071000},{"_id":"themes/even/source/css/_partial/_header/_mobile-navbar.scss","hash":"1633f9cb54a3b2d09be086e27e5e5d33c718ca69","modified":1483422071000},{"_id":"themes/even/source/css/_partial/_header/_search.scss","hash":"3e9655aecde9a09bf015c97c7b10434a807a1ac4","modified":1483422071000},{"_id":"themes/even/source/css/_partial/_post/_code.scss","hash":"80632262cd4c27a3f042bfb88295f7511c285e5b","modified":1483422071000},{"_id":"themes/even/source/css/_partial/_post/_content.scss","hash":"a00cd224d832aff0c4a6deefc0b2b91fe4548172","modified":1483422071000},{"_id":"themes/even/source/css/_partial/_post/_footer.scss","hash":"9f2ab0ac20b2a8bfd315febd387c399f72f43d10","modified":1483422071000},{"_id":"themes/even/source/css/_partial/_post/_header.scss","hash":"794b85495d917e24bbe2f2782f3c7e69b6845eee","modified":1483422071000},{"_id":"themes/even/source/css/_partial/_post/_toc.scss","hash":"24ca97cb8845871b9fd8dcd2314d59248d90c682","modified":1483422071000},{"_id":"themes/even/source/lib/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1483422071000},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1483422071000},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1483422071000},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1483422071000},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1483422071000},{"_id":"themes/even/source/lib/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1483422071000},{"_id":"themes/even/.git/logs/refs/remotes/origin/HEAD","hash":"488ab2a7f4ab0592946e61be28c81c71291da80c","modified":1483422071000},{"_id":"themes/even/.git/objects/pack/pack-bceb22320e6e936d32665a41bfb4e52fdd675475.pack","hash":"64b84be9658c983414c65a4ebe2eb0a644dcc852","modified":1483422071000},{"_id":"public/2017/01/03/132Pattern/index.html","hash":"757061a4a643ba57f51e997558eb407d18bf995f","modified":1483507672574},{"_id":"public/2017/01/02/TotalHammingDistance/index.html","hash":"e1c64db38c4dc9076db0d3dd5f11cfd13da6540b","modified":1483507672574},{"_id":"public/2017/01/01/NewStart/index.html","hash":"c7650036c429db9c6138c419012efcc748f89134","modified":1483507672574},{"_id":"public/archives/index.html","hash":"ad921449bc223ae65963b0100683a7a0b0b4ed1d","modified":1483691827167},{"_id":"public/archives/2017/index.html","hash":"f9bb7a00ec4ca1c21bf39bab9981464cf84fc2e8","modified":1483691827167},{"_id":"public/archives/2017/01/index.html","hash":"43d0dc27df396981ad2bebe64db5fc01adc914e2","modified":1483691827168},{"_id":"public/index.html","hash":"d8c45c52d2aad968a1820d67ac9315ac79f92dbe","modified":1483691849613},{"_id":"public/tags/Stack/index.html","hash":"17016d63ac398c616244d3e2b20587972759470b","modified":1483691827168},{"_id":"public/tags/Binary-Search/index.html","hash":"78bba0edc760153da933f2e919270af047fd501a","modified":1483691827168},{"_id":"public/tags/Description/index.html","hash":"3174a73492ab692a40b7ce29249a2599bb8046ae","modified":1483691827168},{"_id":"public/tags/Bitmap/index.html","hash":"e08ce479511e9766e783aa32f5a8f86e9324f0fc","modified":1483691827168},{"_id":"public/2017/01/04/Heaters/index.html","hash":"e475a282a5189648f57f5ac727cc4f4e71b459d8","modified":1483595117569},{"_id":"public/favicon.ico","hash":"0505cec3b99707df7a681de37177b3cf7950cc5d","modified":1483507672578},{"_id":"public/fonts/chancery/apple-chancery-webfont.eot","hash":"fef78bd502f74fdbf0316123e176454cb3eb4e50","modified":1483507672578},{"_id":"public/fonts/chancery/apple-chancery-webfont.woff","hash":"95beafe485d4bdbddfecbcf3b2bc9b2d9cf5f5c5","modified":1483507672578},{"_id":"public/fonts/chancery/apple-chancery-webfont.woff2","hash":"afd0f74128f1c21c5a542b2e100870e74da663b6","modified":1483507672578},{"_id":"public/fonts/chancery/apple-chancery-webfont.ttf","hash":"5e25c531901d8a9e37ab45a7f4acdbe5324b51b6","modified":1483507672578},{"_id":"public/lib/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1483507672578},{"_id":"public/lib/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1483507672578},{"_id":"public/lib/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1483507672578},{"_id":"public/lib/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1483507672579},{"_id":"public/lib/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1483507672579},{"_id":"public/lib/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1483507672579},{"_id":"public/lib/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1483507672579},{"_id":"public/fonts/chancery/apple-chancery-webfont.svg","hash":"a94e508f306a742637653f98c6e8827b11d3c142","modified":1483507672584},{"_id":"public/js/src/bootstrap.js","hash":"d01a401518abf0dd1e40c406cf9cda2a58a5cb1e","modified":1483507672589},{"_id":"public/js/src/even.js","hash":"384f1f0466e88b717cd1d4ddc5a08b94c39f81fa","modified":1483507672589},{"_id":"public/lib/fancybox/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1483507672589},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1483507672589},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1483507672589},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1483507672589},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1483507672589},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1483507672589},{"_id":"public/lib/fancybox/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1483507672589},{"_id":"public/lib/fancybox/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1483507672589},{"_id":"public/lib/jquery/jquery-3.1.1.min.js","hash":"f647a6d37dc4ca055ced3cf64bbc1f490070acba","modified":1483507672589},{"_id":"public/css/style.css","hash":"1e0073a7395b5e1bf7e8b5b6364f391774272c69","modified":1483507672607},{"_id":"source/_posts/BattleshipsinaBoard.md","hash":"7b802fc1894ee7a8064d72053fad5abcb5ec4a8f","modified":1483595140000},{"_id":"public/tags/Simulation/index.html","hash":"16d85559693d8b510d855f86abd51da4a3ccf1fb","modified":1483691827168},{"_id":"public/2017/01/05/BattleshipsinaBoard/index.html","hash":"14bacbf07c2291c78be4f143b542da29cfa185c0","modified":1483691827168},{"_id":"source/_posts/PartitionEqualSubsetSum.md","hash":"09b3f969a58407ef3d7f0bc52dcc423044999387","modified":1483691844000},{"_id":"public/2017/01/06/PartitionEqualSubsetSum/index.html","hash":"7813902c84590a35722ac46b55487044365123ad","modified":1483691849613},{"_id":"public/tags/Dynamic-Programming/index.html","hash":"72af768078c61e300456e705777e6d157bb41458","modified":1483691827169}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"132 Pattern","date":"2017-01-03T05:46:25.000Z","_content":"\n> Given a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such that i < j < k and ai < ak < aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.\n>\n> Note: n will be less than 15,000.\n>\n> Example 1:\n>\n> Input: [1, 2, 3, 4]\n>\n> Output: False\n>\n> Explanation: There is no 132 pattern in the sequence.\n>\n> Example 2:\n>\n> Input: [3, 1, 4, 2]\n>\n> Output: True\n>\n> Explanation: There is a 132 pattern in the sequence: [1, 4, 2].\n>\n> Example 3:\n>\n> Input: [-1, 3, 2, 0]\n>\n> Output: True\n>\n> Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\n\n<!--more-->\n\nThis is Leetcode 456. As the problem description, we can quickly write this solution like this:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        bool find132pattern(vector<int>& nums) {\n            for (int i = 0; i < (int)nums.size() - 2; i++) {\n                for (int j = i + 1; j < (int)nums.size() - 1; j++) {\n                    for (int k = j + 1; k < (int)nums.size(); k++) {\n                        if (check(nums, i, j, k)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        bool check(vector<int> &nums, int idx, int idy, int idz) {\n            if (nums[idx] < nums[idy]\n                    && nums[idz] < nums[idy]\n                    && nums[idx] < nums[idz]) {\n                return true;\n            }\n            return false;\n        }\n};\n```\nBut it's time complex is O(n^3), and it will get TLE. So, we try to think another way. As a similar problem, try to find a array S1 < S2 < S3, we will find use two pointers to aim at the start and the end of the array.\n\nSo, here we can use a similar solution. We can use a stack to store the num which is bigger than S3, and store it try to find the possible S3.\n\nFor more detail, use [9, 11, 8, 9, 10, 7, 9] as an example:\n\nEXAMPLE:\n + i = 6, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = None, Stack = Empty\n + i = 5, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 7, S3 candidate = None, Stack = [9]\n + i = 4, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 10, S3 candidate = None, Stack = [9,7]\n + i = 3, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = 9, Stack = [10]\n + i = 2, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 8, S3 candidate = 9, Stack = [10,9] We have 8 < 9, sequence found!\n\nSo, the solution is:\n\n```\nbool find132pattern(vector<int>& nums) {\n    int s3 = INT_MIN, s1;\n    std::stack<int> stack;\n    for (int i = nums.size() - 1; i >= 0; i--) {\n        s1 = nums[i];\n        if (s3 > s1) {\n            return true;\n        } else {\n            while (!stack.empty() && nums[i] > stack.top()) {\n                s3 = stack.top();\n                stack.pop();\n            }\n        }\n        stack.push(nums[i]);\n    }\n    return false;\n}\n```\n","source":"_posts/132Pattern.md","raw":"---\ntitle: 132 Pattern\ndate: 2017-01-03 13:46:25\ntags:\n    - Stack\n---\n\n> Given a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such that i < j < k and ai < ak < aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.\n>\n> Note: n will be less than 15,000.\n>\n> Example 1:\n>\n> Input: [1, 2, 3, 4]\n>\n> Output: False\n>\n> Explanation: There is no 132 pattern in the sequence.\n>\n> Example 2:\n>\n> Input: [3, 1, 4, 2]\n>\n> Output: True\n>\n> Explanation: There is a 132 pattern in the sequence: [1, 4, 2].\n>\n> Example 3:\n>\n> Input: [-1, 3, 2, 0]\n>\n> Output: True\n>\n> Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\n\n<!--more-->\n\nThis is Leetcode 456. As the problem description, we can quickly write this solution like this:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        bool find132pattern(vector<int>& nums) {\n            for (int i = 0; i < (int)nums.size() - 2; i++) {\n                for (int j = i + 1; j < (int)nums.size() - 1; j++) {\n                    for (int k = j + 1; k < (int)nums.size(); k++) {\n                        if (check(nums, i, j, k)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        bool check(vector<int> &nums, int idx, int idy, int idz) {\n            if (nums[idx] < nums[idy]\n                    && nums[idz] < nums[idy]\n                    && nums[idx] < nums[idz]) {\n                return true;\n            }\n            return false;\n        }\n};\n```\nBut it's time complex is O(n^3), and it will get TLE. So, we try to think another way. As a similar problem, try to find a array S1 < S2 < S3, we will find use two pointers to aim at the start and the end of the array.\n\nSo, here we can use a similar solution. We can use a stack to store the num which is bigger than S3, and store it try to find the possible S3.\n\nFor more detail, use [9, 11, 8, 9, 10, 7, 9] as an example:\n\nEXAMPLE:\n + i = 6, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = None, Stack = Empty\n + i = 5, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 7, S3 candidate = None, Stack = [9]\n + i = 4, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 10, S3 candidate = None, Stack = [9,7]\n + i = 3, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = 9, Stack = [10]\n + i = 2, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 8, S3 candidate = 9, Stack = [10,9] We have 8 < 9, sequence found!\n\nSo, the solution is:\n\n```\nbool find132pattern(vector<int>& nums) {\n    int s3 = INT_MIN, s1;\n    std::stack<int> stack;\n    for (int i = nums.size() - 1; i >= 0; i--) {\n        s1 = nums[i];\n        if (s3 > s1) {\n            return true;\n        } else {\n            while (!stack.empty() && nums[i] > stack.top()) {\n                s3 = stack.top();\n                stack.pop();\n            }\n        }\n        stack.push(nums[i]);\n    }\n    return false;\n}\n```\n","slug":"132Pattern","published":1,"updated":"2017-01-04T02:00:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixii5xns0000khf4f8v0kmrt","content":"<blockquote>\n<p>Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.</p>\n<p>Note: n will be less than 15,000.</p>\n<p>Example 1:</p>\n<p>Input: [1, 2, 3, 4]</p>\n<p>Output: False</p>\n<p>Explanation: There is no 132 pattern in the sequence.</p>\n<p>Example 2:</p>\n<p>Input: [3, 1, 4, 2]</p>\n<p>Output: True</p>\n<p>Explanation: There is a 132 pattern in the sequence: [1, 4, 2].</p>\n<p>Example 3:</p>\n<p>Input: [-1, 3, 2, 0]</p>\n<p>Output: True</p>\n<p>Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 456. As the problem description, we can quickly write this solution like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool find132pattern(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size() - 2; i++) &#123;</div><div class=\"line\">                for (int j = i + 1; j &lt; (int)nums.size() - 1; j++) &#123;</div><div class=\"line\">                    for (int k = j + 1; k &lt; (int)nums.size(); k++) &#123;</div><div class=\"line\">                        if (check(nums, i, j, k)) &#123;</div><div class=\"line\">                            return true;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool check(vector&lt;int&gt; &amp;nums, int idx, int idy, int idz) &#123;</div><div class=\"line\">            if (nums[idx] &lt; nums[idy]</div><div class=\"line\">                    &amp;&amp; nums[idz] &lt; nums[idy]</div><div class=\"line\">                    &amp;&amp; nums[idx] &lt; nums[idz]) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>But it’s time complex is O(n^3), and it will get TLE. So, we try to think another way. As a similar problem, try to find a array S1 &lt; S2 &lt; S3, we will find use two pointers to aim at the start and the end of the array.</p>\n<p>So, here we can use a similar solution. We can use a stack to store the num which is bigger than S3, and store it try to find the possible S3.</p>\n<p>For more detail, use [9, 11, 8, 9, 10, 7, 9] as an example:</p>\n<p>EXAMPLE:</p>\n<ul>\n<li>i = 6, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = None, Stack = Empty</li>\n<li>i = 5, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 7, S3 candidate = None, Stack = [9]</li>\n<li>i = 4, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 10, S3 candidate = None, Stack = [9,7]</li>\n<li>i = 3, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = 9, Stack = [10]</li>\n<li>i = 2, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 8, S3 candidate = 9, Stack = [10,9] We have 8 &lt; 9, sequence found!</li>\n</ul>\n<p>So, the solution is:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool find132pattern(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    int s3 = INT_MIN, s1;</div><div class=\"line\">    std::stack&lt;int&gt; stack;</div><div class=\"line\">    for (int i = nums.size() - 1; i &gt;= 0; i--) &#123;</div><div class=\"line\">        s1 = nums[i];</div><div class=\"line\">        if (s3 &gt; s1) &#123;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            while (!stack.empty() &amp;&amp; nums[i] &gt; stack.top()) &#123;</div><div class=\"line\">                s3 = stack.top();</div><div class=\"line\">                stack.pop();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        stack.push(nums[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<blockquote>\n<p>Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.</p>\n<p>Note: n will be less than 15,000.</p>\n<p>Example 1:</p>\n<p>Input: [1, 2, 3, 4]</p>\n<p>Output: False</p>\n<p>Explanation: There is no 132 pattern in the sequence.</p>\n<p>Example 2:</p>\n<p>Input: [3, 1, 4, 2]</p>\n<p>Output: True</p>\n<p>Explanation: There is a 132 pattern in the sequence: [1, 4, 2].</p>\n<p>Example 3:</p>\n<p>Input: [-1, 3, 2, 0]</p>\n<p>Output: True</p>\n<p>Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].</p>\n</blockquote>","more":"<p>This is Leetcode 456. As the problem description, we can quickly write this solution like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool find132pattern(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size() - 2; i++) &#123;</div><div class=\"line\">                for (int j = i + 1; j &lt; (int)nums.size() - 1; j++) &#123;</div><div class=\"line\">                    for (int k = j + 1; k &lt; (int)nums.size(); k++) &#123;</div><div class=\"line\">                        if (check(nums, i, j, k)) &#123;</div><div class=\"line\">                            return true;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool check(vector&lt;int&gt; &amp;nums, int idx, int idy, int idz) &#123;</div><div class=\"line\">            if (nums[idx] &lt; nums[idy]</div><div class=\"line\">                    &amp;&amp; nums[idz] &lt; nums[idy]</div><div class=\"line\">                    &amp;&amp; nums[idx] &lt; nums[idz]) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>But it’s time complex is O(n^3), and it will get TLE. So, we try to think another way. As a similar problem, try to find a array S1 &lt; S2 &lt; S3, we will find use two pointers to aim at the start and the end of the array.</p>\n<p>So, here we can use a similar solution. We can use a stack to store the num which is bigger than S3, and store it try to find the possible S3.</p>\n<p>For more detail, use [9, 11, 8, 9, 10, 7, 9] as an example:</p>\n<p>EXAMPLE:</p>\n<ul>\n<li>i = 6, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = None, Stack = Empty</li>\n<li>i = 5, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 7, S3 candidate = None, Stack = [9]</li>\n<li>i = 4, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 10, S3 candidate = None, Stack = [9,7]</li>\n<li>i = 3, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = 9, Stack = [10]</li>\n<li>i = 2, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 8, S3 candidate = 9, Stack = [10,9] We have 8 &lt; 9, sequence found!</li>\n</ul>\n<p>So, the solution is:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool find132pattern(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    int s3 = INT_MIN, s1;</div><div class=\"line\">    std::stack&lt;int&gt; stack;</div><div class=\"line\">    for (int i = nums.size() - 1; i &gt;= 0; i--) &#123;</div><div class=\"line\">        s1 = nums[i];</div><div class=\"line\">        if (s3 &gt; s1) &#123;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            while (!stack.empty() &amp;&amp; nums[i] &gt; stack.top()) &#123;</div><div class=\"line\">                s3 = stack.top();</div><div class=\"line\">                stack.pop();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        stack.push(nums[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"Heaters","date":"2017-01-04T05:46:25.000Z","_content":"\n> Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.\n>\n> So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.\n>\n> Note:\n>\n> + Numbers of houses and heaters you are given are non-negative and will not exceed 25000.\n> + Positions of houses and heaters you are given are non-negative and will not exceed 10^9.\n> + As long as a house is in the heaters' warm radius range, it can be warmed.\n> + All the heaters follow your radius standard and the warm radius will the same.\n>\n> Example 1:\n>\n> Input: [1,2,3],[2]\n> Output: 1\n> Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.\n>\n> Example 2:\n>\n> Input: [1,2,3,4],[1,4]\n> Output: 1\n> Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.\n\n<!-- more -->\n\nThis is Leetcode 475. As it's descripted, we can quickly find a solution. Picture this:\n\n\n```\n          h1   h2        h3\n           |    |         |\n......................................\n```\n\nIf we find the min value of the radius between every two heaters, and find the max one, which will be the result.\n\nAnd it's time complex is O(n*m), n is the num of the houses and m is the num of heaters.\n\n```\nusing namespace std;\n\nclass Solution {\npublic:\n    int idx;\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\n        sort(houses.begin(), houses.end());\n        sort(heaters.begin(), heaters.end());\n\n        int res = INT_MIN;\n        idx = 0;\n        for (int i = 0; i < (int)heaters.size(); i++) {\n            if (i == 0) {\n                res = max(res, findMinRadius(houses, -1, heaters[i]));\n            } else if (i == (int)heaters.size()) {\n                res = max(res, findMinRadius(houses, heaters[i - 1], -1));\n            } else {\n                res = max(res, findMinRadius(houses, heaters[i - 1], heaters[i]));\n            }\n            std::cout << res << std::endl;\n        }\n        return res;\n    }\n\n    int findMinRadius(vector<int> houses, int heater1, int heater2) {\n        if (heater1 == -1) { // means the first one\n            while (houses[idx] <= heater2) { idx++; }\n            return heater2 - houses[0];\n        } else if (heater2 == -1) { // means the last one\n            while (idx < (int)houses.size()) { idx++; }\n            return houses[idx - 1] - heater1;\n        } else {\n            int minRadius = INT_MAX;\n            for (int i = idx; houses[i] < heater2; i++) {\n                // minRadius = min(max(houses[i] - heater1, heater2 - houses[i]), minRadius);\n                // if there are (2n-1) houses, we need to use the mid one\n                // if there are (2n) houses, we should use the the mid two\n                // here is hard to decide which to use as the standard\n            }\n            return minRadius;\n        }\n    }\n};\n```\n\nHowever, there is a better way to figure this problem out. The idea is to leverage decent binarySearch function.\n\n+ For each house, find its position between those heaters (thus we need the heaters array to be sorted).\n+ Calculate the distances between this house and left heater and right heater, get a MIN value of those two values. Corner cases are there is no left or right heater.\n+ Get MAX value among distances in step 2. It's the answer.\n\nSo, here comes the solution:\n\n```\nclass Solution {\n    public:\n        int findRadius(vector<int>& houses, vector<int>& heaters) {\n            int house_size = houses.size();\n            if (house_size == 0) return 0;\n            sort(heaters.begin(), heaters.end());\n\n            int res = 0;\n            for (auto& c : houses) {\n\n                int idx = Bsearch(heaters, c);\n\n                if (idx == 0) {\n                    res = max(res, heaters[idx] - c);\n                } else if (idx >= (int)heaters.size()) {\n                    res = max(res, c - heaters.back());\n                } else {\n                    res = max(res, min(heaters[idx] - c, c - heaters[idx - 1]));\n                }\n            }\n            return res;\n        }\n\n        int Bsearch(vector<int>& nums, int val) {\n\n            int l = 0, r = nums.size() - 1;\n            while (l <= r) {\n                int mid = l + ((r - l) >> 1);\n                if (nums[mid] == val)\n                    return mid;\n                else if (nums[mid] < val)\n                    l = mid + 1;\n                else\n                    r = mid - 1;\n            }\n            return l;\n        }\n};\n```\n\nAnd it's AC.\n","source":"_posts/Heaters.md","raw":"---\ntitle: Heaters\ndate: 2017-01-04 13:46:25\ntags:\n    - Binary Search\n---\n\n> Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.\n>\n> So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.\n>\n> Note:\n>\n> + Numbers of houses and heaters you are given are non-negative and will not exceed 25000.\n> + Positions of houses and heaters you are given are non-negative and will not exceed 10^9.\n> + As long as a house is in the heaters' warm radius range, it can be warmed.\n> + All the heaters follow your radius standard and the warm radius will the same.\n>\n> Example 1:\n>\n> Input: [1,2,3],[2]\n> Output: 1\n> Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.\n>\n> Example 2:\n>\n> Input: [1,2,3,4],[1,4]\n> Output: 1\n> Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.\n\n<!-- more -->\n\nThis is Leetcode 475. As it's descripted, we can quickly find a solution. Picture this:\n\n\n```\n          h1   h2        h3\n           |    |         |\n......................................\n```\n\nIf we find the min value of the radius between every two heaters, and find the max one, which will be the result.\n\nAnd it's time complex is O(n*m), n is the num of the houses and m is the num of heaters.\n\n```\nusing namespace std;\n\nclass Solution {\npublic:\n    int idx;\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\n        sort(houses.begin(), houses.end());\n        sort(heaters.begin(), heaters.end());\n\n        int res = INT_MIN;\n        idx = 0;\n        for (int i = 0; i < (int)heaters.size(); i++) {\n            if (i == 0) {\n                res = max(res, findMinRadius(houses, -1, heaters[i]));\n            } else if (i == (int)heaters.size()) {\n                res = max(res, findMinRadius(houses, heaters[i - 1], -1));\n            } else {\n                res = max(res, findMinRadius(houses, heaters[i - 1], heaters[i]));\n            }\n            std::cout << res << std::endl;\n        }\n        return res;\n    }\n\n    int findMinRadius(vector<int> houses, int heater1, int heater2) {\n        if (heater1 == -1) { // means the first one\n            while (houses[idx] <= heater2) { idx++; }\n            return heater2 - houses[0];\n        } else if (heater2 == -1) { // means the last one\n            while (idx < (int)houses.size()) { idx++; }\n            return houses[idx - 1] - heater1;\n        } else {\n            int minRadius = INT_MAX;\n            for (int i = idx; houses[i] < heater2; i++) {\n                // minRadius = min(max(houses[i] - heater1, heater2 - houses[i]), minRadius);\n                // if there are (2n-1) houses, we need to use the mid one\n                // if there are (2n) houses, we should use the the mid two\n                // here is hard to decide which to use as the standard\n            }\n            return minRadius;\n        }\n    }\n};\n```\n\nHowever, there is a better way to figure this problem out. The idea is to leverage decent binarySearch function.\n\n+ For each house, find its position between those heaters (thus we need the heaters array to be sorted).\n+ Calculate the distances between this house and left heater and right heater, get a MIN value of those two values. Corner cases are there is no left or right heater.\n+ Get MAX value among distances in step 2. It's the answer.\n\nSo, here comes the solution:\n\n```\nclass Solution {\n    public:\n        int findRadius(vector<int>& houses, vector<int>& heaters) {\n            int house_size = houses.size();\n            if (house_size == 0) return 0;\n            sort(heaters.begin(), heaters.end());\n\n            int res = 0;\n            for (auto& c : houses) {\n\n                int idx = Bsearch(heaters, c);\n\n                if (idx == 0) {\n                    res = max(res, heaters[idx] - c);\n                } else if (idx >= (int)heaters.size()) {\n                    res = max(res, c - heaters.back());\n                } else {\n                    res = max(res, min(heaters[idx] - c, c - heaters[idx - 1]));\n                }\n            }\n            return res;\n        }\n\n        int Bsearch(vector<int>& nums, int val) {\n\n            int l = 0, r = nums.size() - 1;\n            while (l <= r) {\n                int mid = l + ((r - l) >> 1);\n                if (nums[mid] == val)\n                    return mid;\n                else if (nums[mid] < val)\n                    l = mid + 1;\n                else\n                    r = mid - 1;\n            }\n            return l;\n        }\n};\n```\n\nAnd it's AC.\n","slug":"Heaters","published":1,"updated":"2017-01-04T05:27:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixii5xnw0001khf402dz5rd6","content":"<blockquote>\n<p>Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.</p>\n<p>So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.</p>\n<p>Note:</p>\n<ul>\n<li>Numbers of houses and heaters you are given are non-negative and will not exceed 25000.</li>\n<li>Positions of houses and heaters you are given are non-negative and will not exceed 10^9.</li>\n<li>As long as a house is in the heaters’ warm radius range, it can be warmed.</li>\n<li>All the heaters follow your radius standard and the warm radius will the same.</li>\n</ul>\n<p>Example 1:</p>\n<p>Input: [1,2,3],[2]<br>Output: 1<br>Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.</p>\n<p>Example 2:</p>\n<p>Input: [1,2,3,4],[1,4]<br>Output: 1<br>Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 475. As it’s descripted, we can quickly find a solution. Picture this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">          h1   h2        h3</div><div class=\"line\">           |    |         |</div><div class=\"line\">......................................</div></pre></td></tr></table></figure>\n<p>If we find the min value of the radius between every two heaters, and find the max one, which will be the result.</p>\n<p>And it’s time complex is O(n*m), n is the num of the houses and m is the num of heaters.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    int idx;</div><div class=\"line\">    int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;</div><div class=\"line\">        sort(houses.begin(), houses.end());</div><div class=\"line\">        sort(heaters.begin(), heaters.end());</div><div class=\"line\"></div><div class=\"line\">        int res = INT_MIN;</div><div class=\"line\">        idx = 0;</div><div class=\"line\">        for (int i = 0; i &lt; (int)heaters.size(); i++) &#123;</div><div class=\"line\">            if (i == 0) &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, -1, heaters[i]));</div><div class=\"line\">            &#125; else if (i == (int)heaters.size()) &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, heaters[i - 1], -1));</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, heaters[i - 1], heaters[i]));</div><div class=\"line\">            &#125;</div><div class=\"line\">            std::cout &lt;&lt; res &lt;&lt; std::endl;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return res;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int findMinRadius(vector&lt;int&gt; houses, int heater1, int heater2) &#123;</div><div class=\"line\">        if (heater1 == -1) &#123; // means the first one</div><div class=\"line\">            while (houses[idx] &lt;= heater2) &#123; idx++; &#125;</div><div class=\"line\">            return heater2 - houses[0];</div><div class=\"line\">        &#125; else if (heater2 == -1) &#123; // means the last one</div><div class=\"line\">            while (idx &lt; (int)houses.size()) &#123; idx++; &#125;</div><div class=\"line\">            return houses[idx - 1] - heater1;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            int minRadius = INT_MAX;</div><div class=\"line\">            for (int i = idx; houses[i] &lt; heater2; i++) &#123;</div><div class=\"line\">                // minRadius = min(max(houses[i] - heater1, heater2 - houses[i]), minRadius);</div><div class=\"line\">                // if there are (2n-1) houses, we need to use the mid one</div><div class=\"line\">                // if there are (2n) houses, we should use the the mid two</div><div class=\"line\">                // here is hard to decide which to use as the standard</div><div class=\"line\">            &#125;</div><div class=\"line\">            return minRadius;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>However, there is a better way to figure this problem out. The idea is to leverage decent binarySearch function.</p>\n<ul>\n<li>For each house, find its position between those heaters (thus we need the heaters array to be sorted).</li>\n<li>Calculate the distances between this house and left heater and right heater, get a MIN value of those two values. Corner cases are there is no left or right heater.</li>\n<li>Get MAX value among distances in step 2. It’s the answer.</li>\n</ul>\n<p>So, here comes the solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;</div><div class=\"line\">            int house_size = houses.size();</div><div class=\"line\">            if (house_size == 0) return 0;</div><div class=\"line\">            sort(heaters.begin(), heaters.end());</div><div class=\"line\"></div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (auto&amp; c : houses) &#123;</div><div class=\"line\"></div><div class=\"line\">                int idx = Bsearch(heaters, c);</div><div class=\"line\"></div><div class=\"line\">                if (idx == 0) &#123;</div><div class=\"line\">                    res = max(res, heaters[idx] - c);</div><div class=\"line\">                &#125; else if (idx &gt;= (int)heaters.size()) &#123;</div><div class=\"line\">                    res = max(res, c - heaters.back());</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    res = max(res, min(heaters[idx] - c, c - heaters[idx - 1]));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int Bsearch(vector&lt;int&gt;&amp; nums, int val) &#123;</div><div class=\"line\"></div><div class=\"line\">            int l = 0, r = nums.size() - 1;</div><div class=\"line\">            while (l &lt;= r) &#123;</div><div class=\"line\">                int mid = l + ((r - l) &gt;&gt; 1);</div><div class=\"line\">                if (nums[mid] == val)</div><div class=\"line\">                    return mid;</div><div class=\"line\">                else if (nums[mid] &lt; val)</div><div class=\"line\">                    l = mid + 1;</div><div class=\"line\">                else</div><div class=\"line\">                    r = mid - 1;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return l;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it’s AC.</p>\n","excerpt":"<blockquote>\n<p>Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.</p>\n<p>So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.</p>\n<p>Note:</p>\n<ul>\n<li>Numbers of houses and heaters you are given are non-negative and will not exceed 25000.</li>\n<li>Positions of houses and heaters you are given are non-negative and will not exceed 10^9.</li>\n<li>As long as a house is in the heaters’ warm radius range, it can be warmed.</li>\n<li>All the heaters follow your radius standard and the warm radius will the same.</li>\n</ul>\n<p>Example 1:</p>\n<p>Input: [1,2,3],[2]<br>Output: 1<br>Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.</p>\n<p>Example 2:</p>\n<p>Input: [1,2,3,4],[1,4]<br>Output: 1<br>Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.</p>\n</blockquote>","more":"<p>This is Leetcode 475. As it’s descripted, we can quickly find a solution. Picture this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">          h1   h2        h3</div><div class=\"line\">           |    |         |</div><div class=\"line\">......................................</div></pre></td></tr></table></figure>\n<p>If we find the min value of the radius between every two heaters, and find the max one, which will be the result.</p>\n<p>And it’s time complex is O(n*m), n is the num of the houses and m is the num of heaters.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    int idx;</div><div class=\"line\">    int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;</div><div class=\"line\">        sort(houses.begin(), houses.end());</div><div class=\"line\">        sort(heaters.begin(), heaters.end());</div><div class=\"line\"></div><div class=\"line\">        int res = INT_MIN;</div><div class=\"line\">        idx = 0;</div><div class=\"line\">        for (int i = 0; i &lt; (int)heaters.size(); i++) &#123;</div><div class=\"line\">            if (i == 0) &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, -1, heaters[i]));</div><div class=\"line\">            &#125; else if (i == (int)heaters.size()) &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, heaters[i - 1], -1));</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, heaters[i - 1], heaters[i]));</div><div class=\"line\">            &#125;</div><div class=\"line\">            std::cout &lt;&lt; res &lt;&lt; std::endl;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return res;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int findMinRadius(vector&lt;int&gt; houses, int heater1, int heater2) &#123;</div><div class=\"line\">        if (heater1 == -1) &#123; // means the first one</div><div class=\"line\">            while (houses[idx] &lt;= heater2) &#123; idx++; &#125;</div><div class=\"line\">            return heater2 - houses[0];</div><div class=\"line\">        &#125; else if (heater2 == -1) &#123; // means the last one</div><div class=\"line\">            while (idx &lt; (int)houses.size()) &#123; idx++; &#125;</div><div class=\"line\">            return houses[idx - 1] - heater1;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            int minRadius = INT_MAX;</div><div class=\"line\">            for (int i = idx; houses[i] &lt; heater2; i++) &#123;</div><div class=\"line\">                // minRadius = min(max(houses[i] - heater1, heater2 - houses[i]), minRadius);</div><div class=\"line\">                // if there are (2n-1) houses, we need to use the mid one</div><div class=\"line\">                // if there are (2n) houses, we should use the the mid two</div><div class=\"line\">                // here is hard to decide which to use as the standard</div><div class=\"line\">            &#125;</div><div class=\"line\">            return minRadius;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>However, there is a better way to figure this problem out. The idea is to leverage decent binarySearch function.</p>\n<ul>\n<li>For each house, find its position between those heaters (thus we need the heaters array to be sorted).</li>\n<li>Calculate the distances between this house and left heater and right heater, get a MIN value of those two values. Corner cases are there is no left or right heater.</li>\n<li>Get MAX value among distances in step 2. It’s the answer.</li>\n</ul>\n<p>So, here comes the solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;</div><div class=\"line\">            int house_size = houses.size();</div><div class=\"line\">            if (house_size == 0) return 0;</div><div class=\"line\">            sort(heaters.begin(), heaters.end());</div><div class=\"line\"></div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (auto&amp; c : houses) &#123;</div><div class=\"line\"></div><div class=\"line\">                int idx = Bsearch(heaters, c);</div><div class=\"line\"></div><div class=\"line\">                if (idx == 0) &#123;</div><div class=\"line\">                    res = max(res, heaters[idx] - c);</div><div class=\"line\">                &#125; else if (idx &gt;= (int)heaters.size()) &#123;</div><div class=\"line\">                    res = max(res, c - heaters.back());</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    res = max(res, min(heaters[idx] - c, c - heaters[idx - 1]));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int Bsearch(vector&lt;int&gt;&amp; nums, int val) &#123;</div><div class=\"line\"></div><div class=\"line\">            int l = 0, r = nums.size() - 1;</div><div class=\"line\">            while (l &lt;= r) &#123;</div><div class=\"line\">                int mid = l + ((r - l) &gt;&gt; 1);</div><div class=\"line\">                if (nums[mid] == val)</div><div class=\"line\">                    return mid;</div><div class=\"line\">                else if (nums[mid] &lt; val)</div><div class=\"line\">                    l = mid + 1;</div><div class=\"line\">                else</div><div class=\"line\">                    r = mid - 1;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return l;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it’s AC.</p>"},{"title":"New Start","date":"2017-01-01T05:46:25.000Z","_content":"\nAs I promised before. I will write blogs in two languages. And here, I will use English to write about my oj games in order to improve my interview skills.\n\n<!--more-->\n","source":"_posts/NewStart.md","raw":"---\ntitle: New Start\ndate: 2017-01-01 13:46:25\ntags: \n    - Description\n---\n\nAs I promised before. I will write blogs in two languages. And here, I will use English to write about my oj games in order to improve my interview skills.\n\n<!--more-->\n","slug":"NewStart","published":1,"updated":"2017-01-03T06:47:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixii5xo00003khf4t26i4qih","content":"<p>As I promised before. I will write blogs in two languages. And here, I will use English to write about my oj games in order to improve my interview skills.</p>\n<a id=\"more\"></a>\n","excerpt":"<p>As I promised before. I will write blogs in two languages. And here, I will use English to write about my oj games in order to improve my interview skills.</p>","more":""},{"title":"Total Hamming Distance","date":"2017-01-02T05:46:25.000Z","_content":"\n> The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\n>\n> Now your job is to find the total Hamming distance between all pairs of the given numbers.\n>\n> Example:\n>\n> Input: 4, 14, 2\n>\n> Output: 6\n>\n> Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just\n> showing the four bits relevant in this case). So the answer will be:\n> HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\n>\n> Note:\n>\n> + Elements of the given array are in the range of 0 to 10^9\n> + Length of the array will not exceed 10^4.\n>\n> Subscribe to see which companies asked this question\n\n<!--more-->\n\nThis is the leetcode No.477, we can quickly find a solution like this:\n\n```\nusing namespace std;\n\nclass Solution {\npublic:\n    int totalHammingDistance(vector<int>& nums) {\n        int sum = 0;\n        for (int i = 0; i < (int)nums.size() - 1; i++) {\n            for (int j = i + 1; j < (int)nums.size(); j++) {\n                sum += hamming_distance(nums[i], nums[j]);\n            }\n        }\n        return sum;\n    }\n\n    int hamming_distance(unsigned long long x, unsigned long long y) {\n        return __builtin_popcountll(x ^ y);\n    }\n};\n```\n\nIt is correct, however it time complex is O(n^2), and the result is TLE.\n\nSo, I found a better solution here. As we can see from the question, we can find the number is int type, and no larger than 2^32 in that we use a 32 bit size bitmap. For better explaination, I use 8 bit size as example.\n\n```\n0000 0000\n1110 0010\n1101 0101\n```\n\nWe get such an array, and we just need to figure out how many 1s in each index. Take 1st index as an example, we get one 1 bit, and the total distance for the 1st index is (3-1)*(1) which stands for (n - bitCount) * bitCount.\n\nSo, what we should do is to add the total 32 bits.\n\nLast, here comes to a solution:\n\n```\nint totalHammingDistance(vector<int>& nums) {\n    int total = 0, bitCount = 0;\n    for (int idx = 0; idx < 32; idx++) {\n        for (int i = 0; i < (int)nums.size(); i++) {\n            bitCount += (nums[i] >> idx) & 1;\n        }\n        total += bitCount * (nums.size() - bitCount);\n    }\n    return total;\n}\n```\n\nAnd it's time complex is O(n*32) which means O(n) and it's accepted.\n","source":"_posts/TotalHammingDistance.md","raw":"---\ntitle: Total Hamming Distance\ndate: 2017-01-02 13:46:25\ntags: \n    - Bitmap\n---\n\n> The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\n>\n> Now your job is to find the total Hamming distance between all pairs of the given numbers.\n>\n> Example:\n>\n> Input: 4, 14, 2\n>\n> Output: 6\n>\n> Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just\n> showing the four bits relevant in this case). So the answer will be:\n> HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\n>\n> Note:\n>\n> + Elements of the given array are in the range of 0 to 10^9\n> + Length of the array will not exceed 10^4.\n>\n> Subscribe to see which companies asked this question\n\n<!--more-->\n\nThis is the leetcode No.477, we can quickly find a solution like this:\n\n```\nusing namespace std;\n\nclass Solution {\npublic:\n    int totalHammingDistance(vector<int>& nums) {\n        int sum = 0;\n        for (int i = 0; i < (int)nums.size() - 1; i++) {\n            for (int j = i + 1; j < (int)nums.size(); j++) {\n                sum += hamming_distance(nums[i], nums[j]);\n            }\n        }\n        return sum;\n    }\n\n    int hamming_distance(unsigned long long x, unsigned long long y) {\n        return __builtin_popcountll(x ^ y);\n    }\n};\n```\n\nIt is correct, however it time complex is O(n^2), and the result is TLE.\n\nSo, I found a better solution here. As we can see from the question, we can find the number is int type, and no larger than 2^32 in that we use a 32 bit size bitmap. For better explaination, I use 8 bit size as example.\n\n```\n0000 0000\n1110 0010\n1101 0101\n```\n\nWe get such an array, and we just need to figure out how many 1s in each index. Take 1st index as an example, we get one 1 bit, and the total distance for the 1st index is (3-1)*(1) which stands for (n - bitCount) * bitCount.\n\nSo, what we should do is to add the total 32 bits.\n\nLast, here comes to a solution:\n\n```\nint totalHammingDistance(vector<int>& nums) {\n    int total = 0, bitCount = 0;\n    for (int idx = 0; idx < 32; idx++) {\n        for (int i = 0; i < (int)nums.size(); i++) {\n            bitCount += (nums[i] >> idx) & 1;\n        }\n        total += bitCount * (nums.size() - bitCount);\n    }\n    return total;\n}\n```\n\nAnd it's time complex is O(n*32) which means O(n) and it's accepted.\n","slug":"TotalHammingDistance","published":1,"updated":"2017-01-03T06:47:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixii5xo20004khf4kgu5gtz9","content":"<blockquote>\n<p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p>\n<p>Now your job is to find the total Hamming distance between all pairs of the given numbers.</p>\n<p>Example:</p>\n<p>Input: 4, 14, 2</p>\n<p>Output: 6</p>\n<p>Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just<br>showing the four bits relevant in this case). So the answer will be:<br>HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</p>\n<p>Note:</p>\n<ul>\n<li>Elements of the given array are in the range of 0 to 10^9</li>\n<li>Length of the array will not exceed 10^4.</li>\n</ul>\n<p>Subscribe to see which companies asked this question</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is the leetcode No.477, we can quickly find a solution like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">        int sum = 0;</div><div class=\"line\">        for (int i = 0; i &lt; (int)nums.size() - 1; i++) &#123;</div><div class=\"line\">            for (int j = i + 1; j &lt; (int)nums.size(); j++) &#123;</div><div class=\"line\">                sum += hamming_distance(nums[i], nums[j]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return sum;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int hamming_distance(unsigned long long x, unsigned long long y) &#123;</div><div class=\"line\">        return __builtin_popcountll(x ^ y);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It is correct, however it time complex is O(n^2), and the result is TLE.</p>\n<p>So, I found a better solution here. As we can see from the question, we can find the number is int type, and no larger than 2^32 in that we use a 32 bit size bitmap. For better explaination, I use 8 bit size as example.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">0000 0000</div><div class=\"line\">1110 0010</div><div class=\"line\">1101 0101</div></pre></td></tr></table></figure>\n<p>We get such an array, and we just need to figure out how many 1s in each index. Take 1st index as an example, we get one 1 bit, and the total distance for the 1st index is (3-1)<em>(1) which stands for (n - bitCount) </em> bitCount.</p>\n<p>So, what we should do is to add the total 32 bits.</p>\n<p>Last, here comes to a solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    int total = 0, bitCount = 0;</div><div class=\"line\">    for (int idx = 0; idx &lt; 32; idx++) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">            bitCount += (nums[i] &gt;&gt; idx) &amp; 1;</div><div class=\"line\">        &#125;</div><div class=\"line\">        total += bitCount * (nums.size() - bitCount);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return total;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>And it’s time complex is O(n*32) which means O(n) and it’s accepted.</p>\n","excerpt":"<blockquote>\n<p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p>\n<p>Now your job is to find the total Hamming distance between all pairs of the given numbers.</p>\n<p>Example:</p>\n<p>Input: 4, 14, 2</p>\n<p>Output: 6</p>\n<p>Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just<br>showing the four bits relevant in this case). So the answer will be:<br>HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</p>\n<p>Note:</p>\n<ul>\n<li>Elements of the given array are in the range of 0 to 10^9</li>\n<li>Length of the array will not exceed 10^4.</li>\n</ul>\n<p>Subscribe to see which companies asked this question</p>\n</blockquote>","more":"<p>This is the leetcode No.477, we can quickly find a solution like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">        int sum = 0;</div><div class=\"line\">        for (int i = 0; i &lt; (int)nums.size() - 1; i++) &#123;</div><div class=\"line\">            for (int j = i + 1; j &lt; (int)nums.size(); j++) &#123;</div><div class=\"line\">                sum += hamming_distance(nums[i], nums[j]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return sum;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int hamming_distance(unsigned long long x, unsigned long long y) &#123;</div><div class=\"line\">        return __builtin_popcountll(x ^ y);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It is correct, however it time complex is O(n^2), and the result is TLE.</p>\n<p>So, I found a better solution here. As we can see from the question, we can find the number is int type, and no larger than 2^32 in that we use a 32 bit size bitmap. For better explaination, I use 8 bit size as example.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">0000 0000</div><div class=\"line\">1110 0010</div><div class=\"line\">1101 0101</div></pre></td></tr></table></figure>\n<p>We get such an array, and we just need to figure out how many 1s in each index. Take 1st index as an example, we get one 1 bit, and the total distance for the 1st index is (3-1)<em>(1) which stands for (n - bitCount) </em> bitCount.</p>\n<p>So, what we should do is to add the total 32 bits.</p>\n<p>Last, here comes to a solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    int total = 0, bitCount = 0;</div><div class=\"line\">    for (int idx = 0; idx &lt; 32; idx++) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">            bitCount += (nums[i] &gt;&gt; idx) &amp; 1;</div><div class=\"line\">        &#125;</div><div class=\"line\">        total += bitCount * (nums.size() - bitCount);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return total;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>And it’s time complex is O(n*32) which means O(n) and it’s accepted.</p>"},{"title":"Battleships in a Board","date":"2017-01-05T05:46:25.000Z","_content":"\n> Given an 2D board, count how many different battleships are in it. The battleships are represented with 'X's, empty slots are represented with '.'s. You may assume the following rules:\n>\n>  + You receive a valid board, made of only battleships or empty slots.\n>  + Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.\n>  + At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.\n>\n> Example:\n>\n> X..X\n> ...X\n> ...X\n>\n> In the above board there are 2 battleships.\n>\n> Invalid Example:\n>\n> ...X\n> XXXX\n> ...X\n>\n> This is an invalid board that you will not receive - as battleships will always have a cell separating between them.\n>\n> Follow up:\n> Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?\n\n<!-- more -->\n\nThis is Leetcode 419, and it's easy enough to figure out with simulation way as following:\n\n1. find the first X char, from up to down and left to right.\n2. if found, then search up and right, to check whether it is ok.\n3. use a global flag to mark if it's good for the result.\n\nThis method will use O(n*n) array to mark the visited position, if not it will modify the value of the board to make sure no cell will visit twice.\n\nFor example, if we use a visited array to mark the visited cells. the solution will be like these:\n\n```\nbool checkShip(vector<vector<char> > &board, int **visited, int idx, int idy) {\n    if (visited[idx][idy]) {\n        return false;\n    }\n\n    bool res = true;\n    // check the direction, down\n    int currentIdx = idx, currentIdy = idy;\n    while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n        if (board[currentIdx][currentIdy] == 'X') {\n            if (currentIdy + 1 < (int)board[0].size() && board[currentIdx][currentIdy + 1] == 'X') {\n                res = false;\n                break;\n            }\n            if (currentIdy - 1 >= 0 && board[currentIdx][currentIdy - 1] == 'X') {\n                res = false;\n                break;\n            }\n        } else {\n            res = true;\n            break;\n        }\n        currentIdx++;\n    }\n    // check the direction, right\n    currentIdx = idx, currentIdy = idy;\n    if (!res) {\n        res = true;\n        while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n            if (board[currentIdx][currentIdy] == 'X') {\n                if (currentIdx + 1 < (int)board.size() && board[currentIdx + 1][currentIdy] == 'X') {\n                    res = false;\n                    break;\n                }\n                if (currentIdx - 1 >= 0 && board[currentIdx - 1][currentIdy] == 'X') {\n                    res = false;\n                    break;\n                }\n            } else {\n                res = true;\n                break;\n            }\n            currentIdy++;\n        }\n    }\n    _visit(board, visited, idx, idy);\n    return res;\n}\n\nvoid _visit(vector<vector<char> > &board, int **visited, int idx, int idy) {\n    if (idx < 0 || idy < 0|| idx >= (int)board.size() || idy >= (int)board[0].size()) {\n        return;\n    }\n    if (visited[idx][idy]) {\n        return;\n    }\n    if (board[idx][idy] == '.') {\n        return;\n    }\n    visited[idx][idy] = 1;\n    _visit(board, visited, idx + 1, idy);\n    _visit(board, visited, idx, idy + 1);\n    _visit(board, visited, idx - 1, idy);\n    _visit(board, visited, idx, idy - 1);\n}\n\nint countBattleships(vector<vector<char> >& board) {\n    int* visited[board.size()];\n    for (int i = 0; i < (int)board.size(); i++) {\n        visited[i] = new int[board[0].size()];\n        memset(visited[i], 0, sizeof(int) * board[0].size());\n    }\n    int res = 0;\n    for (int idx = 0; idx < (int)board.size(); idx++) {\n        for (int idy = 0; idy < (int)board[0].size(); idy++) {\n            if (board[idx][idy] == 'X' && checkShip(board, visited, idx, idy)) {\n                res++;\n            }\n        }\n    }\n    return res;\n}\n```\n\nBut, if we can give up the visited array, just make sure the current cell's left or up have X char to mark it has been visited. It will make sense.\n\nSo, we should add these method to replace the former visited array:\n\n```\nbool isVisited(vector<vector<char> > &board, int idx, int idy) {\n    if (idx == 0 && idy == 0) {\n        return false;\n    } else if (idx == 0) {\n        return board[idx][idy - 1] == 'X';\n    } else if (idy == 0) {\n        return board[idx - 1][idy] == 'X';\n    } else {\n        return board[idx - 1][idy] == 'X' || board[idx][idy - 1] == 'X';\n    }\n}\n```\nSo, the last AC code will like these:\n\n```\nclass Solution {\n    public:\n        bool isVisited(vector<vector<char> > &board, int idx, int idy) {\n            if (idx == 0 && idy == 0) {\n                return false;\n            } else if (idx == 0) {\n                return board[idx][idy - 1] == 'X';\n            } else if (idy == 0) {\n                return board[idx - 1][idy] == 'X';\n            } else {\n                return board[idx - 1][idy] == 'X' || board[idx][idy - 1] == 'X';\n            }\n        }\n\n        bool checkShip(vector<vector<char> > &board, int idx, int idy) {\n            if (isVisited(board, idx, idy)) {\n                return false;\n            }\n\n            bool res = true;\n            // check the direction, down\n            int currentIdx = idx, currentIdy = idy;\n            while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n                if (board[currentIdx][currentIdy] == 'X') {\n                    if (currentIdy + 1 < (int)board[0].size() && board[currentIdx][currentIdy + 1] == 'X') {\n                        res = false;\n                        break;\n                    }\n                    if (currentIdy - 1 >= 0 && board[currentIdx][currentIdy - 1] == 'X') {\n                        res = false;\n                        break;\n                    }\n                } else {\n                    res = true;\n                    break;\n                }\n                currentIdx++;\n            }\n            // check the direction, right\n            currentIdx = idx, currentIdy = idy;\n            if (!res) {\n                res = true;\n                while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n                    if (board[currentIdx][currentIdy] == 'X') {\n                        if (currentIdx + 1 < (int)board.size() && board[currentIdx + 1][currentIdy] == 'X') {\n                            res = false;\n                            break;\n                        }\n                        if (currentIdx - 1 >= 0 && board[currentIdx - 1][currentIdy] == 'X') {\n                            res = false;\n                            break;\n                        }\n                    } else {\n                        res = true;\n                        break;\n                    }\n                    currentIdy++;\n                }\n            }\n            _visit(board, idx, idy);\n            return res;\n        }\n\n        void _visit(vector<vector<char> > &board, int idx, int idy) {\n            if (idx < 0 || idy < 0|| idx >= (int)board.size() || idy >= (int)board[0].size()) {\n                return;\n            }\n            if (isVisited(board, idx, idy)) {\n                return;\n            }\n            if (board[idx][idy] == '.') {\n                return;\n            }\n            // visited[idx][idy] = 1;\n            _visit(board, idx + 1, idy);\n            _visit(board, idx, idy + 1);\n            _visit(board, idx - 1, idy);\n            _visit(board, idx, idy - 1);\n        }\n\n        int countBattleships(vector<vector<char> >& board) {\n            int res = 0;\n            for (int idx = 0; idx < (int)board.size(); idx++) {\n                for (int idy = 0; idy < (int)board[0].size(); idy++) {\n                    if (board[idx][idy] == 'X' && checkShip(board, idx, idy)) {\n                        res++;\n                    }\n                }\n            }\n            return res;\n        }\n};\n```\n","source":"_posts/BattleshipsinaBoard.md","raw":"---\ntitle: Battleships in a Board\ndate: 2017-01-05 13:46:25\ntags:\n    - Simulation\n---\n\n> Given an 2D board, count how many different battleships are in it. The battleships are represented with 'X's, empty slots are represented with '.'s. You may assume the following rules:\n>\n>  + You receive a valid board, made of only battleships or empty slots.\n>  + Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.\n>  + At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.\n>\n> Example:\n>\n> X..X\n> ...X\n> ...X\n>\n> In the above board there are 2 battleships.\n>\n> Invalid Example:\n>\n> ...X\n> XXXX\n> ...X\n>\n> This is an invalid board that you will not receive - as battleships will always have a cell separating between them.\n>\n> Follow up:\n> Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?\n\n<!-- more -->\n\nThis is Leetcode 419, and it's easy enough to figure out with simulation way as following:\n\n1. find the first X char, from up to down and left to right.\n2. if found, then search up and right, to check whether it is ok.\n3. use a global flag to mark if it's good for the result.\n\nThis method will use O(n*n) array to mark the visited position, if not it will modify the value of the board to make sure no cell will visit twice.\n\nFor example, if we use a visited array to mark the visited cells. the solution will be like these:\n\n```\nbool checkShip(vector<vector<char> > &board, int **visited, int idx, int idy) {\n    if (visited[idx][idy]) {\n        return false;\n    }\n\n    bool res = true;\n    // check the direction, down\n    int currentIdx = idx, currentIdy = idy;\n    while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n        if (board[currentIdx][currentIdy] == 'X') {\n            if (currentIdy + 1 < (int)board[0].size() && board[currentIdx][currentIdy + 1] == 'X') {\n                res = false;\n                break;\n            }\n            if (currentIdy - 1 >= 0 && board[currentIdx][currentIdy - 1] == 'X') {\n                res = false;\n                break;\n            }\n        } else {\n            res = true;\n            break;\n        }\n        currentIdx++;\n    }\n    // check the direction, right\n    currentIdx = idx, currentIdy = idy;\n    if (!res) {\n        res = true;\n        while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n            if (board[currentIdx][currentIdy] == 'X') {\n                if (currentIdx + 1 < (int)board.size() && board[currentIdx + 1][currentIdy] == 'X') {\n                    res = false;\n                    break;\n                }\n                if (currentIdx - 1 >= 0 && board[currentIdx - 1][currentIdy] == 'X') {\n                    res = false;\n                    break;\n                }\n            } else {\n                res = true;\n                break;\n            }\n            currentIdy++;\n        }\n    }\n    _visit(board, visited, idx, idy);\n    return res;\n}\n\nvoid _visit(vector<vector<char> > &board, int **visited, int idx, int idy) {\n    if (idx < 0 || idy < 0|| idx >= (int)board.size() || idy >= (int)board[0].size()) {\n        return;\n    }\n    if (visited[idx][idy]) {\n        return;\n    }\n    if (board[idx][idy] == '.') {\n        return;\n    }\n    visited[idx][idy] = 1;\n    _visit(board, visited, idx + 1, idy);\n    _visit(board, visited, idx, idy + 1);\n    _visit(board, visited, idx - 1, idy);\n    _visit(board, visited, idx, idy - 1);\n}\n\nint countBattleships(vector<vector<char> >& board) {\n    int* visited[board.size()];\n    for (int i = 0; i < (int)board.size(); i++) {\n        visited[i] = new int[board[0].size()];\n        memset(visited[i], 0, sizeof(int) * board[0].size());\n    }\n    int res = 0;\n    for (int idx = 0; idx < (int)board.size(); idx++) {\n        for (int idy = 0; idy < (int)board[0].size(); idy++) {\n            if (board[idx][idy] == 'X' && checkShip(board, visited, idx, idy)) {\n                res++;\n            }\n        }\n    }\n    return res;\n}\n```\n\nBut, if we can give up the visited array, just make sure the current cell's left or up have X char to mark it has been visited. It will make sense.\n\nSo, we should add these method to replace the former visited array:\n\n```\nbool isVisited(vector<vector<char> > &board, int idx, int idy) {\n    if (idx == 0 && idy == 0) {\n        return false;\n    } else if (idx == 0) {\n        return board[idx][idy - 1] == 'X';\n    } else if (idy == 0) {\n        return board[idx - 1][idy] == 'X';\n    } else {\n        return board[idx - 1][idy] == 'X' || board[idx][idy - 1] == 'X';\n    }\n}\n```\nSo, the last AC code will like these:\n\n```\nclass Solution {\n    public:\n        bool isVisited(vector<vector<char> > &board, int idx, int idy) {\n            if (idx == 0 && idy == 0) {\n                return false;\n            } else if (idx == 0) {\n                return board[idx][idy - 1] == 'X';\n            } else if (idy == 0) {\n                return board[idx - 1][idy] == 'X';\n            } else {\n                return board[idx - 1][idy] == 'X' || board[idx][idy - 1] == 'X';\n            }\n        }\n\n        bool checkShip(vector<vector<char> > &board, int idx, int idy) {\n            if (isVisited(board, idx, idy)) {\n                return false;\n            }\n\n            bool res = true;\n            // check the direction, down\n            int currentIdx = idx, currentIdy = idy;\n            while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n                if (board[currentIdx][currentIdy] == 'X') {\n                    if (currentIdy + 1 < (int)board[0].size() && board[currentIdx][currentIdy + 1] == 'X') {\n                        res = false;\n                        break;\n                    }\n                    if (currentIdy - 1 >= 0 && board[currentIdx][currentIdy - 1] == 'X') {\n                        res = false;\n                        break;\n                    }\n                } else {\n                    res = true;\n                    break;\n                }\n                currentIdx++;\n            }\n            // check the direction, right\n            currentIdx = idx, currentIdy = idy;\n            if (!res) {\n                res = true;\n                while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n                    if (board[currentIdx][currentIdy] == 'X') {\n                        if (currentIdx + 1 < (int)board.size() && board[currentIdx + 1][currentIdy] == 'X') {\n                            res = false;\n                            break;\n                        }\n                        if (currentIdx - 1 >= 0 && board[currentIdx - 1][currentIdy] == 'X') {\n                            res = false;\n                            break;\n                        }\n                    } else {\n                        res = true;\n                        break;\n                    }\n                    currentIdy++;\n                }\n            }\n            _visit(board, idx, idy);\n            return res;\n        }\n\n        void _visit(vector<vector<char> > &board, int idx, int idy) {\n            if (idx < 0 || idy < 0|| idx >= (int)board.size() || idy >= (int)board[0].size()) {\n                return;\n            }\n            if (isVisited(board, idx, idy)) {\n                return;\n            }\n            if (board[idx][idy] == '.') {\n                return;\n            }\n            // visited[idx][idy] = 1;\n            _visit(board, idx + 1, idy);\n            _visit(board, idx, idy + 1);\n            _visit(board, idx - 1, idy);\n            _visit(board, idx, idy - 1);\n        }\n\n        int countBattleships(vector<vector<char> >& board) {\n            int res = 0;\n            for (int idx = 0; idx < (int)board.size(); idx++) {\n                for (int idy = 0; idy < (int)board[0].size(); idy++) {\n                    if (board[idx][idy] == 'X' && checkShip(board, idx, idy)) {\n                        res++;\n                    }\n                }\n            }\n            return res;\n        }\n};\n```\n","slug":"BattleshipsinaBoard","published":1,"updated":"2017-01-05T05:45:40.000Z","_id":"cixjy86n10000snf4gbiad2i0","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>Given an 2D board, count how many different battleships are in it. The battleships are represented with ‘X’s, empty slots are represented with ‘.’s. You may assume the following rules:</p>\n<ul>\n<li>You receive a valid board, made of only battleships or empty slots.</li>\n<li>Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.</li>\n<li>At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.</li>\n</ul>\n<p>Example:</p>\n<p>X..X<br>…X<br>…X</p>\n<p>In the above board there are 2 battleships.</p>\n<p>Invalid Example:</p>\n<p>…X<br>XXXX<br>…X</p>\n<p>This is an invalid board that you will not receive - as battleships will always have a cell separating between them.</p>\n<p>Follow up:<br>Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 419, and it’s easy enough to figure out with simulation way as following:</p>\n<ol>\n<li>find the first X char, from up to down and left to right.</li>\n<li>if found, then search up and right, to check whether it is ok.</li>\n<li>use a global flag to mark if it’s good for the result.</li>\n</ol>\n<p>This method will use O(n*n) array to mark the visited position, if not it will modify the value of the board to make sure no cell will visit twice.</p>\n<p>For example, if we use a visited array to mark the visited cells. the solution will be like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool checkShip(vector&lt;vector&lt;char&gt; &gt; &amp;board, int **visited, int idx, int idy) &#123;</div><div class=\"line\">    if (visited[idx][idy]) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    bool res = true;</div><div class=\"line\">    // check the direction, down</div><div class=\"line\">    int currentIdx = idx, currentIdy = idy;</div><div class=\"line\">    while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">        if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">            if (currentIdy + 1 &lt; (int)board[0].size() &amp;&amp; board[currentIdx][currentIdy + 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                res = false;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentIdy - 1 &gt;= 0 &amp;&amp; board[currentIdx][currentIdy - 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                res = false;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            res = true;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        currentIdx++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // check the direction, right</div><div class=\"line\">    currentIdx = idx, currentIdy = idy;</div><div class=\"line\">    if (!res) &#123;</div><div class=\"line\">        res = true;</div><div class=\"line\">        while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">            if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                if (currentIdx + 1 &lt; (int)board.size() &amp;&amp; board[currentIdx + 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    res = false;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (currentIdx - 1 &gt;= 0 &amp;&amp; board[currentIdx - 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    res = false;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                res = true;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentIdy++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    _visit(board, visited, idx, idy);</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void _visit(vector&lt;vector&lt;char&gt; &gt; &amp;board, int **visited, int idx, int idy) &#123;</div><div class=\"line\">    if (idx &lt; 0 || idy &lt; 0|| idx &gt;= (int)board.size() || idy &gt;= (int)board[0].size()) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (visited[idx][idy]) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (board[idx][idy] == &apos;.&apos;) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    visited[idx][idy] = 1;</div><div class=\"line\">    _visit(board, visited, idx + 1, idy);</div><div class=\"line\">    _visit(board, visited, idx, idy + 1);</div><div class=\"line\">    _visit(board, visited, idx - 1, idy);</div><div class=\"line\">    _visit(board, visited, idx, idy - 1);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int countBattleships(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</div><div class=\"line\">    int* visited[board.size()];</div><div class=\"line\">    for (int i = 0; i &lt; (int)board.size(); i++) &#123;</div><div class=\"line\">        visited[i] = new int[board[0].size()];</div><div class=\"line\">        memset(visited[i], 0, sizeof(int) * board[0].size());</div><div class=\"line\">    &#125;</div><div class=\"line\">    int res = 0;</div><div class=\"line\">    for (int idx = 0; idx &lt; (int)board.size(); idx++) &#123;</div><div class=\"line\">        for (int idy = 0; idy &lt; (int)board[0].size(); idy++) &#123;</div><div class=\"line\">            if (board[idx][idy] == &apos;X&apos; &amp;&amp; checkShip(board, visited, idx, idy)) &#123;</div><div class=\"line\">                res++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>But, if we can give up the visited array, just make sure the current cell’s left or up have X char to mark it has been visited. It will make sense.</p>\n<p>So, we should add these method to replace the former visited array:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool isVisited(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">    if (idx == 0 &amp;&amp; idy == 0) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125; else if (idx == 0) &#123;</div><div class=\"line\">        return board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">    &#125; else if (idy == 0) &#123;</div><div class=\"line\">        return board[idx - 1][idy] == &apos;X&apos;;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return board[idx - 1][idy] == &apos;X&apos; || board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>So, the last AC code will like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool isVisited(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (idx == 0 &amp;&amp; idy == 0) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125; else if (idx == 0) &#123;</div><div class=\"line\">                return board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">            &#125; else if (idy == 0) &#123;</div><div class=\"line\">                return board[idx - 1][idy] == &apos;X&apos;;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return board[idx - 1][idy] == &apos;X&apos; || board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool checkShip(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (isVisited(board, idx, idy)) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            bool res = true;</div><div class=\"line\">            // check the direction, down</div><div class=\"line\">            int currentIdx = idx, currentIdy = idy;</div><div class=\"line\">            while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">                if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    if (currentIdy + 1 &lt; (int)board[0].size() &amp;&amp; board[currentIdx][currentIdy + 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                        res = false;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    if (currentIdy - 1 &gt;= 0 &amp;&amp; board[currentIdx][currentIdy - 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                        res = false;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    res = true;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                currentIdx++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // check the direction, right</div><div class=\"line\">            currentIdx = idx, currentIdy = idy;</div><div class=\"line\">            if (!res) &#123;</div><div class=\"line\">                res = true;</div><div class=\"line\">                while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">                    if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                        if (currentIdx + 1 &lt; (int)board.size() &amp;&amp; board[currentIdx + 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                            res = false;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (currentIdx - 1 &gt;= 0 &amp;&amp; board[currentIdx - 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                            res = false;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        res = true;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    currentIdy++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            _visit(board, idx, idy);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _visit(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (idx &lt; 0 || idy &lt; 0|| idx &gt;= (int)board.size() || idy &gt;= (int)board[0].size()) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (isVisited(board, idx, idy)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (board[idx][idy] == &apos;.&apos;) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // visited[idx][idy] = 1;</div><div class=\"line\">            _visit(board, idx + 1, idy);</div><div class=\"line\">            _visit(board, idx, idy + 1);</div><div class=\"line\">            _visit(board, idx - 1, idy);</div><div class=\"line\">            _visit(board, idx, idy - 1);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int countBattleships(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)board.size(); idx++) &#123;</div><div class=\"line\">                for (int idy = 0; idy &lt; (int)board[0].size(); idy++) &#123;</div><div class=\"line\">                    if (board[idx][idy] == &apos;X&apos; &amp;&amp; checkShip(board, idx, idy)) &#123;</div><div class=\"line\">                        res++;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n","excerpt":"<blockquote>\n<p>Given an 2D board, count how many different battleships are in it. The battleships are represented with ‘X’s, empty slots are represented with ‘.’s. You may assume the following rules:</p>\n<ul>\n<li>You receive a valid board, made of only battleships or empty slots.</li>\n<li>Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.</li>\n<li>At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.</li>\n</ul>\n<p>Example:</p>\n<p>X..X<br>…X<br>…X</p>\n<p>In the above board there are 2 battleships.</p>\n<p>Invalid Example:</p>\n<p>…X<br>XXXX<br>…X</p>\n<p>This is an invalid board that you will not receive - as battleships will always have a cell separating between them.</p>\n<p>Follow up:<br>Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?</p>\n</blockquote>","more":"<p>This is Leetcode 419, and it’s easy enough to figure out with simulation way as following:</p>\n<ol>\n<li>find the first X char, from up to down and left to right.</li>\n<li>if found, then search up and right, to check whether it is ok.</li>\n<li>use a global flag to mark if it’s good for the result.</li>\n</ol>\n<p>This method will use O(n*n) array to mark the visited position, if not it will modify the value of the board to make sure no cell will visit twice.</p>\n<p>For example, if we use a visited array to mark the visited cells. the solution will be like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool checkShip(vector&lt;vector&lt;char&gt; &gt; &amp;board, int **visited, int idx, int idy) &#123;</div><div class=\"line\">    if (visited[idx][idy]) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    bool res = true;</div><div class=\"line\">    // check the direction, down</div><div class=\"line\">    int currentIdx = idx, currentIdy = idy;</div><div class=\"line\">    while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">        if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">            if (currentIdy + 1 &lt; (int)board[0].size() &amp;&amp; board[currentIdx][currentIdy + 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                res = false;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentIdy - 1 &gt;= 0 &amp;&amp; board[currentIdx][currentIdy - 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                res = false;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            res = true;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        currentIdx++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // check the direction, right</div><div class=\"line\">    currentIdx = idx, currentIdy = idy;</div><div class=\"line\">    if (!res) &#123;</div><div class=\"line\">        res = true;</div><div class=\"line\">        while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">            if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                if (currentIdx + 1 &lt; (int)board.size() &amp;&amp; board[currentIdx + 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    res = false;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (currentIdx - 1 &gt;= 0 &amp;&amp; board[currentIdx - 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    res = false;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                res = true;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentIdy++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    _visit(board, visited, idx, idy);</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void _visit(vector&lt;vector&lt;char&gt; &gt; &amp;board, int **visited, int idx, int idy) &#123;</div><div class=\"line\">    if (idx &lt; 0 || idy &lt; 0|| idx &gt;= (int)board.size() || idy &gt;= (int)board[0].size()) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (visited[idx][idy]) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (board[idx][idy] == &apos;.&apos;) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    visited[idx][idy] = 1;</div><div class=\"line\">    _visit(board, visited, idx + 1, idy);</div><div class=\"line\">    _visit(board, visited, idx, idy + 1);</div><div class=\"line\">    _visit(board, visited, idx - 1, idy);</div><div class=\"line\">    _visit(board, visited, idx, idy - 1);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int countBattleships(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</div><div class=\"line\">    int* visited[board.size()];</div><div class=\"line\">    for (int i = 0; i &lt; (int)board.size(); i++) &#123;</div><div class=\"line\">        visited[i] = new int[board[0].size()];</div><div class=\"line\">        memset(visited[i], 0, sizeof(int) * board[0].size());</div><div class=\"line\">    &#125;</div><div class=\"line\">    int res = 0;</div><div class=\"line\">    for (int idx = 0; idx &lt; (int)board.size(); idx++) &#123;</div><div class=\"line\">        for (int idy = 0; idy &lt; (int)board[0].size(); idy++) &#123;</div><div class=\"line\">            if (board[idx][idy] == &apos;X&apos; &amp;&amp; checkShip(board, visited, idx, idy)) &#123;</div><div class=\"line\">                res++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>But, if we can give up the visited array, just make sure the current cell’s left or up have X char to mark it has been visited. It will make sense.</p>\n<p>So, we should add these method to replace the former visited array:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool isVisited(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">    if (idx == 0 &amp;&amp; idy == 0) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125; else if (idx == 0) &#123;</div><div class=\"line\">        return board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">    &#125; else if (idy == 0) &#123;</div><div class=\"line\">        return board[idx - 1][idy] == &apos;X&apos;;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return board[idx - 1][idy] == &apos;X&apos; || board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>So, the last AC code will like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool isVisited(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (idx == 0 &amp;&amp; idy == 0) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125; else if (idx == 0) &#123;</div><div class=\"line\">                return board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">            &#125; else if (idy == 0) &#123;</div><div class=\"line\">                return board[idx - 1][idy] == &apos;X&apos;;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return board[idx - 1][idy] == &apos;X&apos; || board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool checkShip(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (isVisited(board, idx, idy)) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            bool res = true;</div><div class=\"line\">            // check the direction, down</div><div class=\"line\">            int currentIdx = idx, currentIdy = idy;</div><div class=\"line\">            while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">                if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    if (currentIdy + 1 &lt; (int)board[0].size() &amp;&amp; board[currentIdx][currentIdy + 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                        res = false;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    if (currentIdy - 1 &gt;= 0 &amp;&amp; board[currentIdx][currentIdy - 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                        res = false;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    res = true;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                currentIdx++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // check the direction, right</div><div class=\"line\">            currentIdx = idx, currentIdy = idy;</div><div class=\"line\">            if (!res) &#123;</div><div class=\"line\">                res = true;</div><div class=\"line\">                while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">                    if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                        if (currentIdx + 1 &lt; (int)board.size() &amp;&amp; board[currentIdx + 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                            res = false;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (currentIdx - 1 &gt;= 0 &amp;&amp; board[currentIdx - 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                            res = false;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        res = true;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    currentIdy++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            _visit(board, idx, idy);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _visit(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (idx &lt; 0 || idy &lt; 0|| idx &gt;= (int)board.size() || idy &gt;= (int)board[0].size()) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (isVisited(board, idx, idy)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (board[idx][idy] == &apos;.&apos;) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // visited[idx][idy] = 1;</div><div class=\"line\">            _visit(board, idx + 1, idy);</div><div class=\"line\">            _visit(board, idx, idy + 1);</div><div class=\"line\">            _visit(board, idx - 1, idy);</div><div class=\"line\">            _visit(board, idx, idy - 1);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int countBattleships(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)board.size(); idx++) &#123;</div><div class=\"line\">                for (int idy = 0; idy &lt; (int)board[0].size(); idy++) &#123;</div><div class=\"line\">                    if (board[idx][idy] == &apos;X&apos; &amp;&amp; checkShip(board, idx, idy)) &#123;</div><div class=\"line\">                        res++;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>"},{"title":"Partition Equal Subset Sum","date":"2017-01-06T05:46:25.000Z","_content":"\n> Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n>\n> Note:\n>\n> + Each of the array element will not exceed 100.\n> + The array size will not exceed 200.\n>\n> Example 1:\n>\n> Input: [1, 5, 11, 5]\n>\n> Output: true\n>\n> Explanation: The array can be partitioned as [1, 5, 5] and [11].\n>\n> Example 2:\n>\n> Input: [1, 2, 3, 5]\n>\n> Output: false\n>\n> Explanation: The array cannot be partitioned into equal sum subsets.\n>\n> Subscribe to see which companies asked this question\n\n<!-- more -->\n\nThis is Leetcode 416, and it is a leetweek problem. My last pass code like these:\n```\nclass Solution {\n    public:\n        bool canPartition(vector<int>& nums) {\n            if (nums.size() < 2) {\n                return false;\n            }\n            int sum = 0;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                sum = sum + nums[i];\n            }\n            if (sum % 2 != 0) {\n                return false;\n            }\n            return check(0, 0, nums, sum);\n        }\n\n        bool check(int start, int current, vector<int> nums, int sum) {\n            bool res = false;\n            if (current > sum / 2) {\n                return false;\n            }\n            if (current == sum / 2) {\n                return true;\n            }\n            for (int i = start + 1; i < (int)nums.size(); i++) {\n                res = res || check(i, current + nums[i], nums, sum);\n            }\n            return res;\n        }\n};\n```\nBecause the time complex of this recursive functoin is O(n!), the worst condition. So, we can change our mind to turn this problem into another one.\n\nFind a set of the subarray which its sum is sum / 2. And we can use the DP solution.\n\nBecause we know the sum of the array, so we make a array **dp** in size sum/2. And after a for loop. we will know the dp[num] and dp[sum/2 - num] can achieve. So, when we for twice, like:\n```\nfor (auto num : nums) {\n    for(int i = target; i >= num; i--) { // to be quick we don't visit the whole dp array\n        dp[i] = dp[i] || dp[i - num];\n    }\n}\n```\n\nSo, here comes a better solution based on DP:\n\n```\nusing namespace std;\nclass Solution {\n    public:\n        bool canPartition(vector<int>& nums) {\n            int sum = accumulate(nums.begin(), nums.end(), 0);\n            if (sum & 1) return false;\n            int half = sum >> 1;\n\n            vector<bool> accessibility(half + 1, false);\n            accessibility[0] = true;    // '0' is always reachable\n            //For all num in nums, check the accessibility from half - num to 0.\n            //If 'i' is accessible by former numbers, then 'i + num' is also accessible. (DP Algorithm)\n            for(int num: nums)\n                //Below here we must start from 'half' downto 'num', otherwise current 'num' might be multiply used.\n                //e.g.: If num == 2, then we will have 2, 4, 6... will all be accessible and lead to wrong answer.\n                for(int i = half; i >= num; i--){\n                    if (accessibility[i - num] == true){\n                        accessibility[i] = true;\n                    }\n                }\n            return accessibility[half];\n        }\n};\n```\n\nHowever it's space complex is O(n), so if you need a O(1) solution, I find a cool solution based on bitset.\n\n```\nbool canPartition(vector<int>& nums) {\n    bitset<5001> bits(1);\n    int sum = accumulate(nums.begin(), nums.end(), 0);\n    for (auto n : nums) bits |= bits << n;\n    return !(sum & 1) && bits[sum >> 1];\n}\n```\nWhy and how it works, remaining unknown.\n","source":"_posts/PartitionEqualSubsetSum.md","raw":"---\ntitle: Partition Equal Subset Sum\ndate: 2017-01-06 13:46:25\ntags:\n    - Dynamic Programming\n---\n\n> Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n>\n> Note:\n>\n> + Each of the array element will not exceed 100.\n> + The array size will not exceed 200.\n>\n> Example 1:\n>\n> Input: [1, 5, 11, 5]\n>\n> Output: true\n>\n> Explanation: The array can be partitioned as [1, 5, 5] and [11].\n>\n> Example 2:\n>\n> Input: [1, 2, 3, 5]\n>\n> Output: false\n>\n> Explanation: The array cannot be partitioned into equal sum subsets.\n>\n> Subscribe to see which companies asked this question\n\n<!-- more -->\n\nThis is Leetcode 416, and it is a leetweek problem. My last pass code like these:\n```\nclass Solution {\n    public:\n        bool canPartition(vector<int>& nums) {\n            if (nums.size() < 2) {\n                return false;\n            }\n            int sum = 0;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                sum = sum + nums[i];\n            }\n            if (sum % 2 != 0) {\n                return false;\n            }\n            return check(0, 0, nums, sum);\n        }\n\n        bool check(int start, int current, vector<int> nums, int sum) {\n            bool res = false;\n            if (current > sum / 2) {\n                return false;\n            }\n            if (current == sum / 2) {\n                return true;\n            }\n            for (int i = start + 1; i < (int)nums.size(); i++) {\n                res = res || check(i, current + nums[i], nums, sum);\n            }\n            return res;\n        }\n};\n```\nBecause the time complex of this recursive functoin is O(n!), the worst condition. So, we can change our mind to turn this problem into another one.\n\nFind a set of the subarray which its sum is sum / 2. And we can use the DP solution.\n\nBecause we know the sum of the array, so we make a array **dp** in size sum/2. And after a for loop. we will know the dp[num] and dp[sum/2 - num] can achieve. So, when we for twice, like:\n```\nfor (auto num : nums) {\n    for(int i = target; i >= num; i--) { // to be quick we don't visit the whole dp array\n        dp[i] = dp[i] || dp[i - num];\n    }\n}\n```\n\nSo, here comes a better solution based on DP:\n\n```\nusing namespace std;\nclass Solution {\n    public:\n        bool canPartition(vector<int>& nums) {\n            int sum = accumulate(nums.begin(), nums.end(), 0);\n            if (sum & 1) return false;\n            int half = sum >> 1;\n\n            vector<bool> accessibility(half + 1, false);\n            accessibility[0] = true;    // '0' is always reachable\n            //For all num in nums, check the accessibility from half - num to 0.\n            //If 'i' is accessible by former numbers, then 'i + num' is also accessible. (DP Algorithm)\n            for(int num: nums)\n                //Below here we must start from 'half' downto 'num', otherwise current 'num' might be multiply used.\n                //e.g.: If num == 2, then we will have 2, 4, 6... will all be accessible and lead to wrong answer.\n                for(int i = half; i >= num; i--){\n                    if (accessibility[i - num] == true){\n                        accessibility[i] = true;\n                    }\n                }\n            return accessibility[half];\n        }\n};\n```\n\nHowever it's space complex is O(n), so if you need a O(1) solution, I find a cool solution based on bitset.\n\n```\nbool canPartition(vector<int>& nums) {\n    bitset<5001> bits(1);\n    int sum = accumulate(nums.begin(), nums.end(), 0);\n    for (auto n : nums) bits |= bits << n;\n    return !(sum & 1) && bits[sum >> 1];\n}\n```\nWhy and how it works, remaining unknown.\n","slug":"PartitionEqualSubsetSum","published":1,"updated":"2017-01-06T08:37:24.000Z","_id":"cixljt07d0000zuf4b8pslwj4","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>\n<p>Note:</p>\n<ul>\n<li>Each of the array element will not exceed 100.</li>\n<li>The array size will not exceed 200.</li>\n</ul>\n<p>Example 1:</p>\n<p>Input: [1, 5, 11, 5]</p>\n<p>Output: true</p>\n<p>Explanation: The array can be partitioned as [1, 5, 5] and [11].</p>\n<p>Example 2:</p>\n<p>Input: [1, 2, 3, 5]</p>\n<p>Output: false</p>\n<p>Explanation: The array cannot be partitioned into equal sum subsets.</p>\n<p>Subscribe to see which companies asked this question</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 416, and it is a leetweek problem. My last pass code like these:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() &lt; 2) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int sum = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                sum = sum + nums[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (sum % 2 != 0) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return check(0, 0, nums, sum);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool check(int start, int current, vector&lt;int&gt; nums, int sum) &#123;</div><div class=\"line\">            bool res = false;</div><div class=\"line\">            if (current &gt; sum / 2) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (current == sum / 2) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = start + 1; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                res = res || check(i, current + nums[i], nums, sum);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>Because the time complex of this recursive functoin is O(n!), the worst condition. So, we can change our mind to turn this problem into another one.</p>\n<p>Find a set of the subarray which its sum is sum / 2. And we can use the DP solution.</p>\n<p>Because we know the sum of the array, so we make a array <strong>dp</strong> in size sum/2. And after a for loop. we will know the dp[num] and dp[sum/2 - num] can achieve. So, when we for twice, like:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (auto num : nums) &#123;</div><div class=\"line\">    for(int i = target; i &gt;= num; i--) &#123; // to be quick we don&apos;t visit the whole dp array</div><div class=\"line\">        dp[i] = dp[i] || dp[i - num];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>So, here comes a better solution based on DP:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            int sum = accumulate(nums.begin(), nums.end(), 0);</div><div class=\"line\">            if (sum &amp; 1) return false;</div><div class=\"line\">            int half = sum &gt;&gt; 1;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;bool&gt; accessibility(half + 1, false);</div><div class=\"line\">            accessibility[0] = true;    // &apos;0&apos; is always reachable</div><div class=\"line\">            //For all num in nums, check the accessibility from half - num to 0.</div><div class=\"line\">            //If &apos;i&apos; is accessible by former numbers, then &apos;i + num&apos; is also accessible. (DP Algorithm)</div><div class=\"line\">            for(int num: nums)</div><div class=\"line\">                //Below here we must start from &apos;half&apos; downto &apos;num&apos;, otherwise current &apos;num&apos; might be multiply used.</div><div class=\"line\">                //e.g.: If num == 2, then we will have 2, 4, 6... will all be accessible and lead to wrong answer.</div><div class=\"line\">                for(int i = half; i &gt;= num; i--)&#123;</div><div class=\"line\">                    if (accessibility[i - num] == true)&#123;</div><div class=\"line\">                        accessibility[i] = true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            return accessibility[half];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>However it’s space complex is O(n), so if you need a O(1) solution, I find a cool solution based on bitset.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    bitset&lt;5001&gt; bits(1);</div><div class=\"line\">    int sum = accumulate(nums.begin(), nums.end(), 0);</div><div class=\"line\">    for (auto n : nums) bits |= bits &lt;&lt; n;</div><div class=\"line\">    return !(sum &amp; 1) &amp;&amp; bits[sum &gt;&gt; 1];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Why and how it works, remaining unknown.</p>\n","excerpt":"<blockquote>\n<p>Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>\n<p>Note:</p>\n<ul>\n<li>Each of the array element will not exceed 100.</li>\n<li>The array size will not exceed 200.</li>\n</ul>\n<p>Example 1:</p>\n<p>Input: [1, 5, 11, 5]</p>\n<p>Output: true</p>\n<p>Explanation: The array can be partitioned as [1, 5, 5] and [11].</p>\n<p>Example 2:</p>\n<p>Input: [1, 2, 3, 5]</p>\n<p>Output: false</p>\n<p>Explanation: The array cannot be partitioned into equal sum subsets.</p>\n<p>Subscribe to see which companies asked this question</p>\n</blockquote>","more":"<p>This is Leetcode 416, and it is a leetweek problem. My last pass code like these:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() &lt; 2) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int sum = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                sum = sum + nums[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (sum % 2 != 0) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return check(0, 0, nums, sum);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool check(int start, int current, vector&lt;int&gt; nums, int sum) &#123;</div><div class=\"line\">            bool res = false;</div><div class=\"line\">            if (current &gt; sum / 2) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (current == sum / 2) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = start + 1; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                res = res || check(i, current + nums[i], nums, sum);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>Because the time complex of this recursive functoin is O(n!), the worst condition. So, we can change our mind to turn this problem into another one.</p>\n<p>Find a set of the subarray which its sum is sum / 2. And we can use the DP solution.</p>\n<p>Because we know the sum of the array, so we make a array <strong>dp</strong> in size sum/2. And after a for loop. we will know the dp[num] and dp[sum/2 - num] can achieve. So, when we for twice, like:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (auto num : nums) &#123;</div><div class=\"line\">    for(int i = target; i &gt;= num; i--) &#123; // to be quick we don&apos;t visit the whole dp array</div><div class=\"line\">        dp[i] = dp[i] || dp[i - num];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>So, here comes a better solution based on DP:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            int sum = accumulate(nums.begin(), nums.end(), 0);</div><div class=\"line\">            if (sum &amp; 1) return false;</div><div class=\"line\">            int half = sum &gt;&gt; 1;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;bool&gt; accessibility(half + 1, false);</div><div class=\"line\">            accessibility[0] = true;    // &apos;0&apos; is always reachable</div><div class=\"line\">            //For all num in nums, check the accessibility from half - num to 0.</div><div class=\"line\">            //If &apos;i&apos; is accessible by former numbers, then &apos;i + num&apos; is also accessible. (DP Algorithm)</div><div class=\"line\">            for(int num: nums)</div><div class=\"line\">                //Below here we must start from &apos;half&apos; downto &apos;num&apos;, otherwise current &apos;num&apos; might be multiply used.</div><div class=\"line\">                //e.g.: If num == 2, then we will have 2, 4, 6... will all be accessible and lead to wrong answer.</div><div class=\"line\">                for(int i = half; i &gt;= num; i--)&#123;</div><div class=\"line\">                    if (accessibility[i - num] == true)&#123;</div><div class=\"line\">                        accessibility[i] = true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            return accessibility[half];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>However it’s space complex is O(n), so if you need a O(1) solution, I find a cool solution based on bitset.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    bitset&lt;5001&gt; bits(1);</div><div class=\"line\">    int sum = accumulate(nums.begin(), nums.end(), 0);</div><div class=\"line\">    for (auto n : nums) bits |= bits &lt;&lt; n;</div><div class=\"line\">    return !(sum &amp; 1) &amp;&amp; bits[sum &gt;&gt; 1];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Why and how it works, remaining unknown.</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cixii5xns0000khf4f8v0kmrt","tag_id":"cixii5xny0002khf4gbven4oq","_id":"cixii5xo50006khf4n3w2icad"},{"post_id":"cixii5xnw0001khf402dz5rd6","tag_id":"cixii5xo40005khf4ucyy63n1","_id":"cixii5xo70008khf4yzokrr1h"},{"post_id":"cixii5xo00003khf4t26i4qih","tag_id":"cixii5xo60007khf46r1d6yvc","_id":"cixii5xo7000akhf4fkc1052p"},{"post_id":"cixii5xo20004khf4kgu5gtz9","tag_id":"cixii5xo70009khf4dig3k0df","_id":"cixii5xo7000bkhf4clkdc9rw"},{"post_id":"cixjy86n10000snf4gbiad2i0","tag_id":"cixjy86n60001snf422cl5owu","_id":"cixjy86n90002snf4jm3j6cpm"},{"post_id":"cixljt07d0000zuf4b8pslwj4","tag_id":"cixljt07k0001zuf4jg7sj1kq","_id":"cixljt07n0002zuf4de6dl7gc"}],"Tag":[{"name":"Stack","_id":"cixii5xny0002khf4gbven4oq"},{"name":"Binary Search","_id":"cixii5xo40005khf4ucyy63n1"},{"name":"Description","_id":"cixii5xo60007khf46r1d6yvc"},{"name":"Bitmap","_id":"cixii5xo70009khf4dig3k0df"},{"name":"Simulation","_id":"cixjy86n60001snf422cl5owu"},{"name":"Dynamic Programming","_id":"cixljt07k0001zuf4jg7sj1kq"}]}}