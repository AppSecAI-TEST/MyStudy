{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/gandalfr/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/gandalfr/source/css/apollo.css","path":"css/apollo.css","modified":0,"renderable":1},{"_id":"themes/gandalfr/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":0,"renderable":1},{"_id":"themes/gandalfr/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":0,"renderable":1},{"_id":"themes/gandalfr/source/scss/apollo.scss","path":"scss/apollo.scss","modified":0,"renderable":1}],"Cache":[{"_id":"themes/gandalfr/.gitignore","hash":"a006beea0877a0aa3610ee00e73f62cb1d45125b","modified":1486357309000},{"_id":"themes/gandalfr/LICENSE","hash":"e80157fea03e4ee45500ea818fceaf6ca388c17d","modified":1486365845000},{"_id":"themes/gandalfr/README.md","hash":"e672cdb86eda422c5653926df295098c550014cf","modified":1486366346000},{"_id":"themes/gandalfr/TODO.md","hash":"a4d94aa153575e4e41a40917e8a1934ea5cdac19","modified":1486366422000},{"_id":"themes/gandalfr/_config.yml","hash":"a103a02111862dd3bff38f45f7c9353853978cf0","modified":1486357309000},{"_id":"themes/gandalfr/gulpfile.js","hash":"857a026b6643a2cd52c65d4ae0dc7fe9618206ee","modified":1486357309000},{"_id":"themes/gandalfr/package.json","hash":"b788e4e2c46f1bc9bcb4f0abb96451845d818b71","modified":1486357309000},{"_id":"source/_posts/132Pattern.md","hash":"e463c3d6369981f77cbf15ada12e12163ea33a66","modified":1484276978000},{"_id":"source/_posts/BattleshipsinaBoard.md","hash":"7b802fc1894ee7a8064d72053fad5abcb5ec4a8f","modified":1483595187000},{"_id":"source/_posts/BestTimetoBuyandSellStockwithCooldown.md","hash":"e5967c09d77fd26347713818129cbd5dcc78e3ae","modified":1486370100000},{"_id":"source/_posts/CoinChange.md","hash":"a9ad85d481fa3ddabb192a6fdda89ac9d15be0ca","modified":1484395787000},{"_id":"source/_posts/CombinationSumIV.md","hash":"7f093afd316469167fbf76379d2ec4d73f648439","modified":1484276990000},{"_id":"source/_posts/DecodeString.md","hash":"8079af62e674ead7977527a3a1a3a7acab79121b","modified":1485525942000},{"_id":"source/_posts/FindModeinBinarySearchTree.md","hash":"19490351bcef175c4477f128500c5018bfac98f4","modified":1485965708000},{"_id":"source/_posts/FindtheDuplicateNumber.md","hash":"ec46ffcc4d9a0549fdecfbbfdd8013dae8922259","modified":1486529425000},{"_id":"source/_posts/GroupAnagrams.md","hash":"39347595eb85f84d972d62b137bf2c8a46ed6926","modified":1484277064000},{"_id":"source/_posts/Heaters.md","hash":"f6b1d02ddd7647d8cd6512efefe8f0b2c9205f93","modified":1483507667000},{"_id":"source/_posts/HouseRobberIII.md","hash":"85aa9dc4954e88abdf1bc639e846238689daf6f1","modified":1485009038000},{"_id":"source/_posts/IncreasingSubsequences.md","hash":"01685747e4812efad6593dfc8cc97953b65c56de","modified":1485704340000},{"_id":"source/_posts/IntersectionofTwoArraysII.md","hash":"99d1ce4e9874ac725ecf2079404fcf40ab4f4faf","modified":1483887680000},{"_id":"source/_posts/IntegerReplacement.md","hash":"51c8dfaf049ceb5b448009bf05d1238aa76838a3","modified":1485272461000},{"_id":"source/_posts/LargestDivisibleSubset.md","hash":"549acae7f7b6f7f01cabb4f508ca5369ee9af559","modified":1484395907000},{"_id":"source/_posts/LicenseKeyFormatting.md","hash":"3fc30a342173883a86126b490ab49adb7da1ac94","modified":1484667180000},{"_id":"source/_posts/LongestIncreasingPathinaMatrix.md","hash":"b0c9d9cc27c46fd7d00e96a11eee85694aa63ab0","modified":1483950266000},{"_id":"source/_posts/MatchstickstoSquare.md","hash":"c322da8438dba110f82734999ba0a116d48bcf5a","modified":1486194549000},{"_id":"source/_posts/MaxConsecutiveOnesII.md","hash":"a9760cb3278a7fa40ec94e5158da7a781d18bf0b","modified":1484461913000},{"_id":"source/_posts/MaximumProductofWordLengths.md","hash":"a473acb044875d93b72311bcf390bbf38011a498","modified":1485526112000},{"_id":"source/_posts/MinimumMovestoEqualArrayElementsII.md","hash":"a5414a770a4279f3ad2b188118ab734a6d8c5259","modified":1485442375000},{"_id":"source/_posts/MostFrequentSubtreeSum.md","hash":"42dc27f8e90a5723c4882b857117f73d4547703e","modified":1486432821000},{"_id":"source/_posts/NewStart.md","hash":"8e373a9c4e54ad72603e05d0edd11cdfeb3a0673","modified":1483426041000},{"_id":"source/_posts/NextGreaterElementI.md","hash":"0d4fe0c3278b3544288b7d7b08db4ebcdd8c06e1","modified":1486276056000},{"_id":"source/_posts/NumberComplement.md","hash":"7b6a24daf1a7d7c5478d9ddee083f4bb2e620062","modified":1485273094000},{"_id":"source/_posts/OnesandZeroes.md","hash":"1db9b0fd255ea9a02593ee7b19f15a349cb23968","modified":1484929423000},{"_id":"source/_posts/PartitionEqualSubsetSum.md","hash":"2827ec318420479702406f9becd5a4df120550ed","modified":1484277030000},{"_id":"source/_posts/PathSumIII.md","hash":"a130adbb00393e837e3243522a8502bb57d4c73e","modified":1483804827000},{"_id":"source/_posts/PerfectSquares.md","hash":"f780574e45803d0562454812f066e6d2cd2d6029","modified":1484554268000},{"_id":"source/_posts/PredicttheWinner.md","hash":"aa1979cfe6126cf87fca5b2e497519f1bd325d48","modified":1486194619000},{"_id":"source/_posts/RansomNote.md","hash":"c7d244c776cd29768df6800b24e7666342208fdd","modified":1484236683000},{"_id":"source/_posts/RelativeRanks.md","hash":"4a9609dbf63265f9a6601562381880857ed2b819","modified":1486277334000},{"_id":"source/_posts/TargetSum.md","hash":"064b84c71bbfb4c2f5599fdd42b1c7a4101740bc","modified":1485618060000},{"_id":"source/_posts/TeemoAttacking.md","hash":"d4586c75ec7794fd8ae62c49a24cb4c5e6d5e107","modified":1486039618000},{"_id":"source/_posts/TotalHammingDistance.md","hash":"3543dc2fb9cd9417061fd0377a0725999b835a6b","modified":1484277003000},{"_id":"source/_posts/UniqueSubstringsinWraparoundString.md","hash":"c027d2558f269dc70155641f9c05e5f0d4158873","modified":1485788870000},{"_id":"source/_posts/ValidPerfectSquare.md","hash":"894e31eaa400441be33bdb1ebcaae08fadf202cb","modified":1485354344000},{"_id":"source/tags/index.md","hash":"c7903929418ffa391eb94fa1ee0cb8238a53132d","modified":1484113382000},{"_id":"themes/gandalfr/.git/COMMIT_EDITMSG","hash":"5d89d12d22f04a3b7bed4f07db6af55dde146c6e","modified":1486366447000},{"_id":"themes/gandalfr/.git/FETCH_HEAD","hash":"a3853c150da68808ab327a94696105c590c56823","modified":1486357308000},{"_id":"themes/gandalfr/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1486357308000},{"_id":"themes/gandalfr/.git/ORIG_HEAD","hash":"31587fbb6657cd468ed3b12a662831307701010c","modified":1486357309000},{"_id":"themes/gandalfr/.git/config","hash":"a70f111fb8b3d18c7007d06ff9bd6c5c6e6bdee6","modified":1486365832000},{"_id":"themes/gandalfr/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1486357308000},{"_id":"themes/gandalfr/.git/index","hash":"a886a9589ff40010ec8db8a3ec3d3df53b5ee761","modified":1486366441000},{"_id":"themes/gandalfr/.git/packed-refs","hash":"6f299e362770d70250edb034cd187c9f3988f689","modified":1486357309000},{"_id":"themes/gandalfr/languages/en.yml","hash":"40292f2a48e4e6361132033a47c516cb33127b6c","modified":1486357309000},{"_id":"themes/gandalfr/languages/zh-cn.yml","hash":"9e4b03e14c094000257ea254fd660dde4c7af63c","modified":1486357309000},{"_id":"themes/gandalfr/layout/archive.jade","hash":"93b4be131156409bd4fae3d8777f9a8e025ee6bd","modified":1486530238000},{"_id":"themes/gandalfr/layout/index.jade","hash":"55f2f1b4b5364a0e09cb18e1112664c6415fb881","modified":1486357309000},{"_id":"themes/gandalfr/layout/post.jade","hash":"245c26244c075c3632d1545c3b228ee9d112f15d","modified":1486357309000},{"_id":"themes/gandalfr/source/favicon.ico","hash":"b8eb4ec54a6ce48e939cfdcb775493d3d0ab58ef","modified":1486357309000},{"_id":"themes/gandalfr/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1486357308000},{"_id":"themes/gandalfr/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1486357308000},{"_id":"themes/gandalfr/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1486357308000},{"_id":"themes/gandalfr/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1486357308000},{"_id":"themes/gandalfr/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1486357308000},{"_id":"themes/gandalfr/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1486357308000},{"_id":"themes/gandalfr/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1486357308000},{"_id":"themes/gandalfr/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1486357308000},{"_id":"themes/gandalfr/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1486357308000},{"_id":"themes/gandalfr/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1486357308000},{"_id":"themes/gandalfr/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1486357308000},{"_id":"themes/gandalfr/.git/logs/HEAD","hash":"d1d6102096f0d5a43300bf7d33a625f12cf08b82","modified":1486366447000},{"_id":"themes/gandalfr/layout/mixins/paginator.jade","hash":"f4ee2fb61a32e199b48cf93771749edc8a007391","modified":1486357309000},{"_id":"themes/gandalfr/layout/mixins/post.jade","hash":"cd9447e9b0ad22213e6a17d9a9b948f9f998f921","modified":1486357309000},{"_id":"themes/gandalfr/layout/partial/comment.jade","hash":"ff0a2c269c2434da2ac5529872f1d6184a71f96d","modified":1486357309000},{"_id":"themes/gandalfr/layout/partial/copyright.jade","hash":"217f8b17054e5079f2d30bb7e2e4e36c0f2161b7","modified":1486357309000},{"_id":"themes/gandalfr/layout/partial/head.jade","hash":"05c64904bc0cd04bc2a07ad3850d4f38a70f628e","modified":1486357309000},{"_id":"themes/gandalfr/layout/partial/layout.jade","hash":"d28fa3c39fca9624a87e7e83736cf2509dc14a43","modified":1486357309000},{"_id":"themes/gandalfr/layout/partial/nav.jade","hash":"f4842d9d3d763fbb823d112a6f49f24cc42a0ad4","modified":1486357309000},{"_id":"themes/gandalfr/layout/partial/scripts.jade","hash":"a7cacee5f538129eb3357861b8afde49df62d329","modified":1486357309000},{"_id":"themes/gandalfr/source/css/apollo.css","hash":"a9c2cdda57df7e869932a1dc315670ecdce49d2f","modified":1486530029000},{"_id":"themes/gandalfr/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1486357309000},{"_id":"themes/gandalfr/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1486357309000},{"_id":"themes/gandalfr/source/scss/apollo.scss","hash":"e0092f469264b55b25e0d441274f1c812147e7d1","modified":1486357309000},{"_id":"themes/gandalfr/.git/objects/03/a4daceda4a86c7290ee2d6676e5793e3caf612","hash":"f8931603e85e2e0ade5a4dab3d9a08826dcbeb91","modified":1486357308000},{"_id":"themes/gandalfr/.git/objects/07/4534af8ec2edd564a8259b7bb8e7a21d7182c8","hash":"0f8bb864299b91796e293a8503f4ac57a9393c4c","modified":1486357308000},{"_id":"themes/gandalfr/.git/objects/14/419d0eacc69f94d4088cf997a2f56207868936","hash":"9102fb83e611935306160e28e0253b9587de99cf","modified":1486366447000},{"_id":"themes/gandalfr/.git/objects/17/377efb8e0267265a6ff7fa87cd650d0bc0381e","hash":"6af21855b5ee959da67e74c00c86b8c758553b00","modified":1486357308000},{"_id":"themes/gandalfr/.git/objects/17/7c5fbcaca9fa33ba77c9e726c49bdde2af409e","hash":"ade633c471f352845defccdd563131137b703368","modified":1486366354000},{"_id":"themes/gandalfr/.git/objects/22/41852961d858172563a257543edddac950794d","hash":"d81019f0163110beea00aaf0173a15cbf6aebe19","modified":1486366441000},{"_id":"themes/gandalfr/.git/objects/28/1a7edcfb058c75411772c64154ee7214745578","hash":"240b661cc2e7074211c293e165949a801118c6c2","modified":1486357308000},{"_id":"themes/gandalfr/.git/objects/3e/7af7d4c647d118a70ac9a8fe35c796051f15ab","hash":"57062988d9fe84487026f025ed6a40151a09d0dc","modified":1486357308000},{"_id":"themes/gandalfr/.git/objects/3e/d1b5d6e3a710a1aab87ea992e4a57475b33365","hash":"f0605d1d3e3ad94e9f2365a9d464927a72859813","modified":1486357308000},{"_id":"themes/gandalfr/.git/objects/41/3250856bbaffc947b375254d430a95c378ab60","hash":"1fb36bcb7a1aa7a6e1a10c08a1a47dd9ee5a79df","modified":1486357308000},{"_id":"themes/gandalfr/.git/objects/43/41154002ed8d4075ee2ba2c3c0c540a6a94f81","hash":"c6185978443da7a444f5063d069bb4b21dd1f6f1","modified":1486357308000},{"_id":"themes/gandalfr/.git/objects/4b/861463f27eebef3004f5bb37425d4dd0de96b4","hash":"a150feb72fc23f008777b638c7b0ac2d8968d431","modified":1486366354000},{"_id":"themes/gandalfr/.git/objects/4b/9e23506733a1139ca8d93d43b46cbc21b90078","hash":"260d1b9e70f68bca5fefeb214e4a764dda219530","modified":1486366354000},{"_id":"themes/gandalfr/.git/objects/4c/515037a4492ff48cb92bbb0585579bf57dc1f4","hash":"a60d33d46f9e48be70cbd9e2aeb4cc3d38e98f26","modified":1486357308000},{"_id":"themes/gandalfr/.git/objects/4e/5c3e5508ebb91661430093677dc8779c38e856","hash":"3877e10733e40060acdf7136d28025c301a71346","modified":1486357308000},{"_id":"themes/gandalfr/.git/objects/4f/eedc178fed7867454e0db2177e9f4eef8f5621","hash":"58ae085736f293a561df97334392323e043570e4","modified":1486357308000},{"_id":"themes/gandalfr/.git/objects/50/b57c0e0d07379317a7ae3839fe7904cd9a76c4","hash":"db3adc5f9cccb5106f48c7d50731fbb4e7c6b258","modified":1486357308000},{"_id":"themes/gandalfr/.git/objects/61/06a0a6b941f6ce64aac809853c7f370d7ab0fc","hash":"22dc13931c762778f49bd75e423e6e8940d11887","modified":1486366354000},{"_id":"themes/gandalfr/.git/objects/67/da59d7293eb24fd4d78b199b7faff66cb83446","hash":"820d868d7af53d14148d9376930da1561020f356","modified":1486366354000},{"_id":"themes/gandalfr/.git/objects/7d/5fecd018a26510045f6f7e9f2780f8c0a5da9d","hash":"ede593eeea0424b4d1023be0dd051f814211830e","modified":1486357308000},{"_id":"themes/gandalfr/.git/objects/9d/eb46ac143f2de2b2db89da337cf7bc2422c2e0","hash":"9ba3579f33bd9e06648fecc5e55201210c165ba4","modified":1486366354000},{"_id":"themes/gandalfr/.git/objects/a6/4855ce27347de08a26eb47186d1ae660698ead","hash":"48bc9ba754902f3cc7d3008ed244f958793f7d5b","modified":1486357308000},{"_id":"themes/gandalfr/.git/objects/84/62330f03e259dd0ab33c5d2ebe39eda3f3cc35","hash":"a3ff60b46cba0f46d2d321c180df7f2e359236f5","modified":1486366432000},{"_id":"themes/gandalfr/.git/objects/af/424ab1db9e70d0bbc35ced4cb09556da9a1057","hash":"95490a278d6e18323704edf46156e30f33da9665","modified":1486357308000},{"_id":"themes/gandalfr/.git/objects/b5/4733bd911acd53ee188e3af09517bb27cfacc0","hash":"6e2dedf4409ec46edf5a28b5513b6e827350e7f1","modified":1486357308000},{"_id":"themes/gandalfr/.git/objects/b6/0f0a1afd8224a3c2ba27928e5b22506fa79a01","hash":"b7ec513a51ee402fafee17d2385daf77f56b86b9","modified":1486366354000},{"_id":"themes/gandalfr/.git/objects/ce/09ce5051e238808c05dee70d2b460f9c138b22","hash":"8a9656c028fe9c2ac24f5ac52e8d8aee6628cead","modified":1486357308000},{"_id":"themes/gandalfr/.git/objects/cd/9be3d673dd6d8b967c258751556f1a727623af","hash":"684794cbe04eb236ea9e73293764f0e14b099926","modified":1486357308000},{"_id":"themes/gandalfr/.git/objects/d1/b6879929de0f3202981c3450e2dae2c5de809c","hash":"7677c18f8ab8d71dd4e678ca0846b2efc3cbc8bf","modified":1486366354000},{"_id":"themes/gandalfr/.git/objects/d2/704ffa794c7db2902523736433f729981b3264","hash":"2adbba7e023730dd83d6f05abbfdf06099fbb48c","modified":1486366440000},{"_id":"themes/gandalfr/.git/objects/de/02385c6f97ba5bf99e3c92897babb00d2584be","hash":"92387e11cbdb467f44d93bf22aa3518044b896a1","modified":1486357308000},{"_id":"themes/gandalfr/.git/objects/ef/555095e4386f98b8275b7fc21aeaa9bea39ded","hash":"2a36b28345d5b81c5c098648becf4e349786d8ed","modified":1486357308000},{"_id":"themes/gandalfr/.git/objects/ef/88d79424a9fcf327ee8a648039f6ad4bbfe729","hash":"7f144455f88c4f61be80ed47baa0c71398669115","modified":1486366354000},{"_id":"themes/gandalfr/.git/objects/f5/77036cf2ba7d638f197e188825a7d56adf5eeb","hash":"8bdcb5818c82b8096f4d015d96df57f2ed0c1c46","modified":1486366354000},{"_id":"themes/gandalfr/.git/objects/f6/3b1de4e1ef9b70c211cc99c146ca085847677a","hash":"7900180e6e355a52210f32a4a139582fabc3ae69","modified":1486357309000},{"_id":"themes/gandalfr/.git/objects/f6/d133ba8a0453830a129a6613048559350f0e67","hash":"d9cb87188649b2a82513bb583e4b4c3bad329892","modified":1486357309000},{"_id":"themes/gandalfr/.git/objects/pack/pack-45a21a80109c48dff7a583ed686467a5aa8e7c15.idx","hash":"264aab8e71a9a6b6b2a8fa1e91952f52ca5d6958","modified":1486357309000},{"_id":"themes/gandalfr/.git/refs/heads/master","hash":"fd037c138e3bad50b2b57c101ab2b8b7499aa362","modified":1486366447000},{"_id":"themes/gandalfr/source/scss/_partial/archive-post-list.scss","hash":"b173328f07795f64769fe552b5c2749f4159d050","modified":1486529518000},{"_id":"themes/gandalfr/source/scss/_partial/base.scss","hash":"ae967b2049ecb9b8c4e139ecce32fd9fb5358ac5","modified":1486357309000},{"_id":"themes/gandalfr/source/scss/_partial/copyright.scss","hash":"1309667e3000037170cfbb5b8c9c65f4ffcf6814","modified":1486357309000},{"_id":"themes/gandalfr/source/scss/_partial/footer.scss","hash":"094aca6e52f11b139ac7980ca03fa7b9d8fc7b2f","modified":1486357309000},{"_id":"themes/gandalfr/source/scss/_partial/header.scss","hash":"153bde88bf8ffeae4ffd813d8cc694dd83d33d94","modified":1486357309000},{"_id":"themes/gandalfr/source/scss/_partial/home-post-list.scss","hash":"6b5c59f3d2295944f934aee2c1156012a3306d5d","modified":1486357309000},{"_id":"themes/gandalfr/source/scss/_partial/post.scss","hash":"1998f207541a2590a5624549f96c5e65d136690a","modified":1486357309000},{"_id":"themes/gandalfr/source/scss/_partial/mq.scss","hash":"fc5dda52cfbb10e27e2471e03f4606fb3d588225","modified":1486357309000},{"_id":"themes/gandalfr/source/scss/_partial/normalize.scss","hash":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1486357309000},{"_id":"themes/gandalfr/.git/logs/refs/heads/master","hash":"d1d6102096f0d5a43300bf7d33a625f12cf08b82","modified":1486366447000},{"_id":"themes/gandalfr/.git/refs/remotes/origin/master","hash":"fd037c138e3bad50b2b57c101ab2b8b7499aa362","modified":1486366457000},{"_id":"themes/gandalfr/.git/logs/refs/remotes/origin/master","hash":"6a2ccf372d17080ccdc5ed2902766ffbdaea1f67","modified":1486366457000},{"_id":"themes/gandalfr/.git/objects/pack/pack-45a21a80109c48dff7a583ed686467a5aa8e7c15.pack","hash":"fa8aff67d51f4307c747e3e514795c3196f4e6b8","modified":1486357309000},{"_id":"public/atom.xml","hash":"b022c21f8a5ea788c10ad00f6413021b28496d55","modified":1486530245946},{"_id":"public/sitemap.xml","hash":"3a47e48a820749fc4b3af5aa230bd4abee189209","modified":1486530245961},{"_id":"public/tags/index.html","hash":"b5686a9d415e132c0df1a226327aef7770499f43","modified":1486530245971},{"_id":"public/2017/02/08/FindtheDuplicateNumber/index.html","hash":"580e92a968ea8b295045b897949448215b222ed2","modified":1486530245971},{"_id":"public/2017/02/07/MostFrequentSubtreeSum/index.html","hash":"a76341d9b83e9063fb36cbccdfc2c877912f52b0","modified":1486530245971},{"_id":"public/2017/02/06/BestTimetoBuyandSellStockwithCooldown/index.html","hash":"654ab47cef6b6b1f84472c1f415a75e3ac135c52","modified":1486530245971},{"_id":"public/2017/02/05/NextGreaterElementI/index.html","hash":"0720bad80c5ca95d2f084b850f2391856959e915","modified":1486530245971},{"_id":"public/2017/02/05/RelativeRanks/index.html","hash":"c6175ada967852910d147b1d416adf2e0faa2683","modified":1486530245971},{"_id":"public/2017/02/04/MatchstickstoSquare/index.html","hash":"d255d99e3f2e0fb693af04951ed170abffe7cd7c","modified":1486530245972},{"_id":"public/2017/02/03/PredicttheWinner/index.html","hash":"24673f8b186913bc01ad9b2fe70d197d0f0c5ce7","modified":1486530245972},{"_id":"public/2017/02/02/TeemoAttacking/index.html","hash":"ee235e238cec191d804eed92789ef5602ba0c3b3","modified":1486530245972},{"_id":"public/2017/02/01/FindModeinBinarySearchTree/index.html","hash":"8e9e10c317b45b606784e25f45df1a51b3cd379c","modified":1486530245972},{"_id":"public/2017/01/30/UniqueSubstringsinWraparoundString/index.html","hash":"fd55750dbf2b349a42f953d6237038be89e644a0","modified":1486530245972},{"_id":"public/2017/01/29/IncreasingSubsequences/index.html","hash":"bb0f998f950822be460a64b4e8dc9dc4aaca28cf","modified":1486530245972},{"_id":"public/2017/01/28/TargetSum/index.html","hash":"b1c3269e2e8ff8faed04f8ce3225bc9a3284b432","modified":1486530245972},{"_id":"public/2017/01/27/DecodeString/index.html","hash":"cb666bca966c52bfdfc425ebbc7663a5862519b3","modified":1486530245972},{"_id":"public/2017/01/26/MinimumMovestoEqualArrayElementsII/index.html","hash":"2ce030f8f1c46caffc11def5f6c99dc9b45dc634","modified":1486530245972},{"_id":"public/2017/01/25/ValidPerfectSquare/index.html","hash":"8731c7c32d1d107f8c8ecfabba9a19f329c299d1","modified":1486530245972},{"_id":"public/2017/01/24/NumberComplement/index.html","hash":"a09aad45c7b1332b3988d108b91de49b131ed144","modified":1486530245972},{"_id":"public/2017/01/22/IntegerReplacement/index.html","hash":"5db2f1b8f1d34402404fb4222908d716edcfcef8","modified":1486530245972},{"_id":"public/2017/01/21/HouseRobberIII/index.html","hash":"1e3e06d18491e003e228ff1903311f94784a1cba","modified":1486530245972},{"_id":"public/2017/01/20/OnesandZeroes/index.html","hash":"86bd0b1929e858ecda6b72b00622de72f1b7316b","modified":1486530245972},{"_id":"public/2017/01/18/MaximumProductofWordLengths/index.html","hash":"b80f25d9df767de80e617875e54bb86cc89956df","modified":1486530245972},{"_id":"public/2017/01/17/LicenseKeyFormatting/index.html","hash":"e1330d80f9d2517822dda32ceb693177b5b50679","modified":1486530245972},{"_id":"public/2017/01/16/PerfectSquares/index.html","hash":"df34fef42a77d8ded9f156ca4d57e68d654067a7","modified":1486530245972},{"_id":"public/2017/01/15/MaxConsecutiveOnesII/index.html","hash":"a4f6e730fe9f09722470bbe28b919ae24e2b0ba1","modified":1486530245972},{"_id":"public/2017/01/14/CoinChange/index.html","hash":"a3b6feb032d94c369be56cbc7e9584afce13fee0","modified":1486530245972},{"_id":"public/2017/01/13/LargestDivisibleSubset/index.html","hash":"4fa9b06b669276d08b2a9fe125bdaed6b170d050","modified":1486530245972},{"_id":"public/2017/01/12/RansomNote/index.html","hash":"8bca06494f302d1d389821a151e1359bb2c705ea","modified":1486530245972},{"_id":"public/2017/01/11/CombinationSumIV/index.html","hash":"63d6180edac16e2ee3185ee6469434a72ed05758","modified":1486530245972},{"_id":"public/2017/01/10/GroupAnagrams/index.html","hash":"c9b97b14797e1c1196886f0a41e4404158ec7dd6","modified":1486530245972},{"_id":"public/2017/01/09/LongestIncreasingPathinaMatrix/index.html","hash":"e720b92e10a24d9d8a54305c1c88ab80485010f4","modified":1486530245972},{"_id":"public/2017/01/08/IntersectionofTwoArraysII/index.html","hash":"3f17d5a3bbacbd7acba764539b1f5982d4f57c77","modified":1486530245973},{"_id":"public/2017/01/07/PathSumIII/index.html","hash":"56ba7a79c6638903bbc2c126f100ff3a63b80214","modified":1486530245973},{"_id":"public/2017/01/06/PartitionEqualSubsetSum/index.html","hash":"ef88ffb82c89ff6b181b3dc97ef16815dda45171","modified":1486530245973},{"_id":"public/2017/01/04/Heaters/index.html","hash":"60e45ed0c3fe721052dda55c140ae8a663258941","modified":1486530245973},{"_id":"public/2017/01/03/132Pattern/index.html","hash":"35cdcc2b17c0c21f4f0b1ba6252f82eadc5fc705","modified":1486530245973},{"_id":"public/2017/01/02/TotalHammingDistance/index.html","hash":"06a9d896e3f600f7a64e1f4dd8ed1e71060de75f","modified":1486530245973},{"_id":"public/2017/01/01/NewStart/index.html","hash":"72f3b749bea09bc47136718e0ed60649edf5dbc4","modified":1486530245973},{"_id":"public/archives/index.html","hash":"517fc3d27a824faa73d07d3e47bfa9ec11475451","modified":1486530245973},{"_id":"public/archives/2017/01/index.html","hash":"7ed1fb60ed19de63c399c926dd4d7600441be425","modified":1486530245973},{"_id":"public/archives/2017/02/index.html","hash":"4e1574251458e63b1e50d1b2e43f998d45b4a17d","modified":1486530245973},{"_id":"public/archives/2017/index.html","hash":"cf8b54a8855dc38fdfa6802e87261300f613bfc8","modified":1486530245973},{"_id":"public/index.html","hash":"7ee4275a7f34a95f976f5b598ab819689b1174fd","modified":1486530245973},{"_id":"public/page/4/index.html","hash":"ca5794d43cc59da0b23774637ef1ccea7049928e","modified":1486530245973},{"_id":"public/page/2/index.html","hash":"39727d406ecfb1f3e6dc5e25d3b6f62c204ba2a1","modified":1486530245973},{"_id":"public/page/3/index.html","hash":"e7d67a24bf795b8a2685b2541e8f6b794d2ff605","modified":1486530245973},{"_id":"public/page/5/index.html","hash":"8665356cfbd29531ddf34da69b3e008321f7ac3d","modified":1486530245974},{"_id":"public/page/6/index.html","hash":"ce5b7c69b3069ebd4e48b82c9640bcb90b1e9d1d","modified":1486530245974},{"_id":"public/page/7/index.html","hash":"ae187828470d3282a07a877a2847c7dec8e26b5d","modified":1486530245974},{"_id":"public/page/8/index.html","hash":"496ee0d6fdcb411d45dc91a754bc098242b37abd","modified":1486530245974},{"_id":"public/tags/Stack/index.html","hash":"ae38d1ebca70b4f86f411ef0ddf5b79011f76706","modified":1486530245974},{"_id":"public/tags/Simulation/index.html","hash":"78a0134d273c19e3d2c97410e68b64dbff7d3f6b","modified":1486530245974},{"_id":"public/tags/Dynamic-Programming/index.html","hash":"95ec4f9b413a46898a7d1d5a03250ea2ee5dd7d3","modified":1486530245974},{"_id":"public/tags/Depth-first-Search/index.html","hash":"587e65f90f56297b347ceab7ca5c4d9e5c5eab93","modified":1486530245974},{"_id":"public/tags/Tree/index.html","hash":"d3d55abb9ac0567a2c19886f40afe9c309b92dd1","modified":1486530245974},{"_id":"public/tags/Binary-Search/index.html","hash":"de7420b6f777545a5a82168fbf34dccb78806677","modified":1486530245974},{"_id":"public/tags/Array/index.html","hash":"1f23c027596d814e0173f067eb5812f441e65d75","modified":1486530245974},{"_id":"public/tags/Two-Pointers/index.html","hash":"a429d5f67d53adca00dc3d9821c979f6f5c84283","modified":1486530245974},{"_id":"public/tags/Hash-Table/index.html","hash":"721b46eee8771a16e1f8d719c81604b2333cb293","modified":1486530245974},{"_id":"public/tags/String/index.html","hash":"ae4749ed214263adae2f47677513378e9d282edf","modified":1486530245974},{"_id":"public/tags/Sort/index.html","hash":"f905ba79abb21979a13f73e3894b0fb4043b8e4a","modified":1486530245974},{"_id":"public/tags/Math/index.html","hash":"862b9e6b1f9f2ad2db863fd7e1ee2e1c70019727","modified":1486530245974},{"_id":"public/tags/Bitmap/index.html","hash":"85eded9412bf4dd1140cbd0618f4eecff2033ef9","modified":1486530245974},{"_id":"public/tags/Memoization/index.html","hash":"0884ae3baec252195c019093bb0455c88f9b977a","modified":1486530245974},{"_id":"public/tags/Topological-sort/index.html","hash":"0884ae3baec252195c019093bb0455c88f9b977a","modified":1486530245974},{"_id":"public/tags/Description/index.html","hash":"9d6e95c27c06b6eae68b750203ba3207084c8ef6","modified":1486530245974},{"_id":"public/tags/Breadth-first-Search/index.html","hash":"fbf3c8af2d3dd430b3e923c565969e21bce8d763","modified":1486530245974},{"_id":"public/tags/Minimax/index.html","hash":"ba46455bea0e9a76a4704b8443f2d977bfae6681","modified":1486530245974},{"_id":"public/2017/01/05/BattleshipsinaBoard/index.html","hash":"42b2b585c8ecd3ead00eab1201717d896333b832","modified":1486530245974},{"_id":"public/favicon.ico","hash":"b8eb4ec54a6ce48e939cfdcb775493d3d0ab58ef","modified":1486530245978},{"_id":"public/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1486530245978},{"_id":"public/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1486530245978},{"_id":"public/css/apollo.css","hash":"a9c2cdda57df7e869932a1dc315670ecdce49d2f","modified":1486530245985},{"_id":"public/scss/apollo.css","hash":"b5e7f4a99a97128a1ae6b03fde83aa91885de29e","modified":1486530246000}],"Category":[],"Data":[],"Page":[{"title":"tags","date":"2017-01-11T05:42:42.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-01-11 13:42:42\ntype: \"tags\"\n---\n","updated":"2017-01-11T05:43:02.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ciywhq662003kpff4b1z2br0q","content":"","excerpt":"","more":""}],"Post":[{"title":"132 Pattern","date":"2017-01-03T05:46:25.000Z","_content":"\n> Given a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such that i < j < k and ai < ak < aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.\n>\n> Note: n will be less than 15,000.\n>\n> Example 1:\n> Input: [1, 2, 3, 4]\n> Output: False\n>\n> Explanation: There is no 132 pattern in the sequence.\n> \n> Example 2:\n> Input: [3, 1, 4, 2]\n> Output: True\n>\n> Explanation: There is a 132 pattern in the sequence: [1, 4, 2].\n>\n> Example 3:\n> Input: [-1, 3, 2, 0]\n> Output: True\n>\n> Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\n\n<!--more-->\n\nThis is Leetcode 456. As the problem description, we can quickly write this solution like this:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        bool find132pattern(vector<int>& nums) {\n            for (int i = 0; i < (int)nums.size() - 2; i++) {\n                for (int j = i + 1; j < (int)nums.size() - 1; j++) {\n                    for (int k = j + 1; k < (int)nums.size(); k++) {\n                        if (check(nums, i, j, k)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        bool check(vector<int> &nums, int idx, int idy, int idz) {\n            if (nums[idx] < nums[idy]\n                    && nums[idz] < nums[idy]\n                    && nums[idx] < nums[idz]) {\n                return true;\n            }\n            return false;\n        }\n};\n```\nBut it's time complex is O(n^3), and it will get TLE. So, we try to think another way. As a similar problem, try to find a array S1 < S2 < S3, we will find use two pointers to aim at the start and the end of the array.\n\nSo, here we can use a similar solution. We can use a stack to store the num which is bigger than S3, and store it try to find the possible S3.\n\nFor more detail, use [9, 11, 8, 9, 10, 7, 9] as an example:\n\nEXAMPLE:\n + i = 6, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = None, Stack = Empty\n + i = 5, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 7, S3 candidate = None, Stack = [9]\n + i = 4, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 10, S3 candidate = None, Stack = [9,7]\n + i = 3, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = 9, Stack = [10]\n + i = 2, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 8, S3 candidate = 9, Stack = [10,9] We have 8 < 9, sequence found!\n\nSo, the solution is:\n\n```\nbool find132pattern(vector<int>& nums) {\n    int s3 = INT_MIN, s1;\n    std::stack<int> stack;\n    for (int i = nums.size() - 1; i >= 0; i--) {\n        s1 = nums[i];\n        if (s3 > s1) {\n            return true;\n        } else {\n            while (!stack.empty() && nums[i] > stack.top()) {\n                s3 = stack.top();\n                stack.pop();\n            }\n        }\n        stack.push(nums[i]);\n    }\n    return false;\n}\n```\n","source":"_posts/132Pattern.md","raw":"---\ntitle: 132 Pattern\ndate: 2017-01-03 13:46:25\ntags:\n    - Stack\n---\n\n> Given a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such that i < j < k and ai < ak < aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.\n>\n> Note: n will be less than 15,000.\n>\n> Example 1:\n> Input: [1, 2, 3, 4]\n> Output: False\n>\n> Explanation: There is no 132 pattern in the sequence.\n> \n> Example 2:\n> Input: [3, 1, 4, 2]\n> Output: True\n>\n> Explanation: There is a 132 pattern in the sequence: [1, 4, 2].\n>\n> Example 3:\n> Input: [-1, 3, 2, 0]\n> Output: True\n>\n> Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\n\n<!--more-->\n\nThis is Leetcode 456. As the problem description, we can quickly write this solution like this:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        bool find132pattern(vector<int>& nums) {\n            for (int i = 0; i < (int)nums.size() - 2; i++) {\n                for (int j = i + 1; j < (int)nums.size() - 1; j++) {\n                    for (int k = j + 1; k < (int)nums.size(); k++) {\n                        if (check(nums, i, j, k)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        bool check(vector<int> &nums, int idx, int idy, int idz) {\n            if (nums[idx] < nums[idy]\n                    && nums[idz] < nums[idy]\n                    && nums[idx] < nums[idz]) {\n                return true;\n            }\n            return false;\n        }\n};\n```\nBut it's time complex is O(n^3), and it will get TLE. So, we try to think another way. As a similar problem, try to find a array S1 < S2 < S3, we will find use two pointers to aim at the start and the end of the array.\n\nSo, here we can use a similar solution. We can use a stack to store the num which is bigger than S3, and store it try to find the possible S3.\n\nFor more detail, use [9, 11, 8, 9, 10, 7, 9] as an example:\n\nEXAMPLE:\n + i = 6, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = None, Stack = Empty\n + i = 5, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 7, S3 candidate = None, Stack = [9]\n + i = 4, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 10, S3 candidate = None, Stack = [9,7]\n + i = 3, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = 9, Stack = [10]\n + i = 2, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 8, S3 candidate = 9, Stack = [10,9] We have 8 < 9, sequence found!\n\nSo, the solution is:\n\n```\nbool find132pattern(vector<int>& nums) {\n    int s3 = INT_MIN, s1;\n    std::stack<int> stack;\n    for (int i = nums.size() - 1; i >= 0; i--) {\n        s1 = nums[i];\n        if (s3 > s1) {\n            return true;\n        } else {\n            while (!stack.empty() && nums[i] > stack.top()) {\n                s3 = stack.top();\n                stack.pop();\n            }\n        }\n        stack.push(nums[i]);\n    }\n    return false;\n}\n```\n","slug":"132Pattern","published":1,"updated":"2017-01-13T03:09:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5pk0000pff4ucah6t66","content":"<blockquote>\n<p>Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.</p>\n<p>Note: n will be less than 15,000.</p>\n<p>Example 1:<br>Input: [1, 2, 3, 4]<br>Output: False</p>\n<p>Explanation: There is no 132 pattern in the sequence.</p>\n<p>Example 2:<br>Input: [3, 1, 4, 2]<br>Output: True</p>\n<p>Explanation: There is a 132 pattern in the sequence: [1, 4, 2].</p>\n<p>Example 3:<br>Input: [-1, 3, 2, 0]<br>Output: True</p>\n<p>Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 456. As the problem description, we can quickly write this solution like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool find132pattern(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size() - 2; i++) &#123;</div><div class=\"line\">                for (int j = i + 1; j &lt; (int)nums.size() - 1; j++) &#123;</div><div class=\"line\">                    for (int k = j + 1; k &lt; (int)nums.size(); k++) &#123;</div><div class=\"line\">                        if (check(nums, i, j, k)) &#123;</div><div class=\"line\">                            return true;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool check(vector&lt;int&gt; &amp;nums, int idx, int idy, int idz) &#123;</div><div class=\"line\">            if (nums[idx] &lt; nums[idy]</div><div class=\"line\">                    &amp;&amp; nums[idz] &lt; nums[idy]</div><div class=\"line\">                    &amp;&amp; nums[idx] &lt; nums[idz]) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>But it’s time complex is O(n^3), and it will get TLE. So, we try to think another way. As a similar problem, try to find a array S1 &lt; S2 &lt; S3, we will find use two pointers to aim at the start and the end of the array.</p>\n<p>So, here we can use a similar solution. We can use a stack to store the num which is bigger than S3, and store it try to find the possible S3.</p>\n<p>For more detail, use [9, 11, 8, 9, 10, 7, 9] as an example:</p>\n<p>EXAMPLE:</p>\n<ul>\n<li>i = 6, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = None, Stack = Empty</li>\n<li>i = 5, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 7, S3 candidate = None, Stack = [9]</li>\n<li>i = 4, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 10, S3 candidate = None, Stack = [9,7]</li>\n<li>i = 3, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = 9, Stack = [10]</li>\n<li>i = 2, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 8, S3 candidate = 9, Stack = [10,9] We have 8 &lt; 9, sequence found!</li>\n</ul>\n<p>So, the solution is:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool find132pattern(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    int s3 = INT_MIN, s1;</div><div class=\"line\">    std::stack&lt;int&gt; stack;</div><div class=\"line\">    for (int i = nums.size() - 1; i &gt;= 0; i--) &#123;</div><div class=\"line\">        s1 = nums[i];</div><div class=\"line\">        if (s3 &gt; s1) &#123;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            while (!stack.empty() &amp;&amp; nums[i] &gt; stack.top()) &#123;</div><div class=\"line\">                s3 = stack.top();</div><div class=\"line\">                stack.pop();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        stack.push(nums[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<blockquote>\n<p>Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.</p>\n<p>Note: n will be less than 15,000.</p>\n<p>Example 1:<br>Input: [1, 2, 3, 4]<br>Output: False</p>\n<p>Explanation: There is no 132 pattern in the sequence.</p>\n<p>Example 2:<br>Input: [3, 1, 4, 2]<br>Output: True</p>\n<p>Explanation: There is a 132 pattern in the sequence: [1, 4, 2].</p>\n<p>Example 3:<br>Input: [-1, 3, 2, 0]<br>Output: True</p>\n<p>Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].</p>\n</blockquote>","more":"<p>This is Leetcode 456. As the problem description, we can quickly write this solution like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool find132pattern(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size() - 2; i++) &#123;</div><div class=\"line\">                for (int j = i + 1; j &lt; (int)nums.size() - 1; j++) &#123;</div><div class=\"line\">                    for (int k = j + 1; k &lt; (int)nums.size(); k++) &#123;</div><div class=\"line\">                        if (check(nums, i, j, k)) &#123;</div><div class=\"line\">                            return true;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool check(vector&lt;int&gt; &amp;nums, int idx, int idy, int idz) &#123;</div><div class=\"line\">            if (nums[idx] &lt; nums[idy]</div><div class=\"line\">                    &amp;&amp; nums[idz] &lt; nums[idy]</div><div class=\"line\">                    &amp;&amp; nums[idx] &lt; nums[idz]) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>But it’s time complex is O(n^3), and it will get TLE. So, we try to think another way. As a similar problem, try to find a array S1 &lt; S2 &lt; S3, we will find use two pointers to aim at the start and the end of the array.</p>\n<p>So, here we can use a similar solution. We can use a stack to store the num which is bigger than S3, and store it try to find the possible S3.</p>\n<p>For more detail, use [9, 11, 8, 9, 10, 7, 9] as an example:</p>\n<p>EXAMPLE:</p>\n<ul>\n<li>i = 6, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = None, Stack = Empty</li>\n<li>i = 5, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 7, S3 candidate = None, Stack = [9]</li>\n<li>i = 4, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 10, S3 candidate = None, Stack = [9,7]</li>\n<li>i = 3, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = 9, Stack = [10]</li>\n<li>i = 2, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 8, S3 candidate = 9, Stack = [10,9] We have 8 &lt; 9, sequence found!</li>\n</ul>\n<p>So, the solution is:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool find132pattern(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    int s3 = INT_MIN, s1;</div><div class=\"line\">    std::stack&lt;int&gt; stack;</div><div class=\"line\">    for (int i = nums.size() - 1; i &gt;= 0; i--) &#123;</div><div class=\"line\">        s1 = nums[i];</div><div class=\"line\">        if (s3 &gt; s1) &#123;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            while (!stack.empty() &amp;&amp; nums[i] &gt; stack.top()) &#123;</div><div class=\"line\">                s3 = stack.top();</div><div class=\"line\">                stack.pop();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        stack.push(nums[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"Coin Change","date":"2017-01-14T05:54:51.000Z","_content":"\n> You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n>\n> Example 1:\n> coins = [1, 2, 5], amount = 11\n> return 3 (11 = 5 + 5 + 1)\n>\n> Example 2:\n> coins = [2], amount = 3\n> return -1.\n>\n> Note: You may assume that you have an infinite number of each kind of coin.\n\n<!--more-->\n\nThis is Leetcode 322, and it's quite a DP problem, so I first find this solution:\n1. use a DP array to store all the result from 0 to amount\n2. foreach add the coins to match the amount. for instance, we can find such an example:\n```\n  --- 2\n1 --- 3\n  --- 6\n  --- 3\n2 --- 4\n  --- 7\n    ...\n```\n3. So, after all this match we can finally find the result.\n\nSo, I write such solution code:\n\n```\nclass Solution {\n    public:\n        int coinChange(vector<int>& coins, int amount) {\n            sort(coins.begin(), coins.end());\n            if (amount == 0) {\n                return 0;\n            }\n            if (coins[0] > amount) {\n                return -1;\n            }\n\n\n            vector<long> DP(amount + 1, INT_MAX);\n            map<long, set<long> > coinMap;\n            long level = 1;\n            set<long> zeroN;\n            zeroN.insert(0);\n            coinMap.insert(pair<long, set<long> >(0, zeroN));\n            DP[0] = 0;\n\n            while (DP[amount] == INT_MAX) {\n                coinMap.insert(pair<long, set<long> >(level, set<long>()));\n                for (int preCoin : coinMap[level - 1]) {\n                    for (int coin : coins) {\n                        if (preCoin + (long)coin <= (long)amount) {\n                            coinMap[level].insert(preCoin + coin);\n                            DP[preCoin + coin] = min(DP[preCoin] + 1, DP[coin + preCoin]);\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                if (coinMap[level].size() == 0) {\n                    return -1;\n                }\n                level++;\n            }\n            return DP[amount];\n        }\n};\n```\n\nBut, it gets TLE. So I want to find where I am wrong. I think I use too much unnecessary maps. So I simplfy my code:\n```\nclass Solution {\n    public:\n        int coinChange(vector<int>& coins, int amount) {\n            vector<long> DP(amount + 1, INT_MAX);\n\n            sort(coins.begin(), coins.end());\n            if (amount == 0) {\n                return 0;\n            }\n            if (coins[0] > amount) {\n                return -1;\n            }\n\n            long start = 0;\n            long end = 0;\n\n            DP[0] = 0;\n\n            while (start <= amount) {\n                for (int pre = start; pre <= end; pre++) {\n                    for (int coin : coins) {\n                        if ((long)coin + (long)pre <= (long)amount) {\n                            DP[coin + pre] = min(DP[pre] + 1, DP[coin + pre]);\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                start = coins[0] + start;\n                end = min((long)coins[coins.size() - 1] + (long)end, (long)amount);\n            }\n\n            return DP[amount] == INT_MAX ? -1 : DP[amount];\n        }\n};\n```\n\nHowever it still gets a TLE. Then I realize, how about just change the form of code, use the DP array as the standard:\n\n```\nclass Solution {\n    public:\n        int coinChange(vector<int>& coins, int amount) {\n            vector<long> DP(amount + 1, INT_MAX);\n\n            sort(coins.begin(), coins.end());\n            if (amount == 0) {\n                return 0;\n            }\n            if (coins[0] > amount) {\n                return -1;\n            }\n\n            DP[0] = 0;\n            for (int pre = 1; pre <= amount; pre++) {\n                for (int current : coins) {\n                    if (pre >= current) {\n                        DP[pre] = min(DP[pre - current] + 1, DP[pre]);\n                    } else {\n                        break;\n                    }\n                }\n            }\n            return DP[amount] == INT_MAX ? -1 : DP[amount];\n        }\n};\n```\n\nThis solution is as much as the above but its form changed, and its time complex is O(NM), and it gets AC.\n","source":"_posts/CoinChange.md","raw":"---\ntitle: Coin Change\ndate: 2017-01-14 13:54:51\ntags:\n    - Dynamic Programming\n---\n\n> You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n>\n> Example 1:\n> coins = [1, 2, 5], amount = 11\n> return 3 (11 = 5 + 5 + 1)\n>\n> Example 2:\n> coins = [2], amount = 3\n> return -1.\n>\n> Note: You may assume that you have an infinite number of each kind of coin.\n\n<!--more-->\n\nThis is Leetcode 322, and it's quite a DP problem, so I first find this solution:\n1. use a DP array to store all the result from 0 to amount\n2. foreach add the coins to match the amount. for instance, we can find such an example:\n```\n  --- 2\n1 --- 3\n  --- 6\n  --- 3\n2 --- 4\n  --- 7\n    ...\n```\n3. So, after all this match we can finally find the result.\n\nSo, I write such solution code:\n\n```\nclass Solution {\n    public:\n        int coinChange(vector<int>& coins, int amount) {\n            sort(coins.begin(), coins.end());\n            if (amount == 0) {\n                return 0;\n            }\n            if (coins[0] > amount) {\n                return -1;\n            }\n\n\n            vector<long> DP(amount + 1, INT_MAX);\n            map<long, set<long> > coinMap;\n            long level = 1;\n            set<long> zeroN;\n            zeroN.insert(0);\n            coinMap.insert(pair<long, set<long> >(0, zeroN));\n            DP[0] = 0;\n\n            while (DP[amount] == INT_MAX) {\n                coinMap.insert(pair<long, set<long> >(level, set<long>()));\n                for (int preCoin : coinMap[level - 1]) {\n                    for (int coin : coins) {\n                        if (preCoin + (long)coin <= (long)amount) {\n                            coinMap[level].insert(preCoin + coin);\n                            DP[preCoin + coin] = min(DP[preCoin] + 1, DP[coin + preCoin]);\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                if (coinMap[level].size() == 0) {\n                    return -1;\n                }\n                level++;\n            }\n            return DP[amount];\n        }\n};\n```\n\nBut, it gets TLE. So I want to find where I am wrong. I think I use too much unnecessary maps. So I simplfy my code:\n```\nclass Solution {\n    public:\n        int coinChange(vector<int>& coins, int amount) {\n            vector<long> DP(amount + 1, INT_MAX);\n\n            sort(coins.begin(), coins.end());\n            if (amount == 0) {\n                return 0;\n            }\n            if (coins[0] > amount) {\n                return -1;\n            }\n\n            long start = 0;\n            long end = 0;\n\n            DP[0] = 0;\n\n            while (start <= amount) {\n                for (int pre = start; pre <= end; pre++) {\n                    for (int coin : coins) {\n                        if ((long)coin + (long)pre <= (long)amount) {\n                            DP[coin + pre] = min(DP[pre] + 1, DP[coin + pre]);\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                start = coins[0] + start;\n                end = min((long)coins[coins.size() - 1] + (long)end, (long)amount);\n            }\n\n            return DP[amount] == INT_MAX ? -1 : DP[amount];\n        }\n};\n```\n\nHowever it still gets a TLE. Then I realize, how about just change the form of code, use the DP array as the standard:\n\n```\nclass Solution {\n    public:\n        int coinChange(vector<int>& coins, int amount) {\n            vector<long> DP(amount + 1, INT_MAX);\n\n            sort(coins.begin(), coins.end());\n            if (amount == 0) {\n                return 0;\n            }\n            if (coins[0] > amount) {\n                return -1;\n            }\n\n            DP[0] = 0;\n            for (int pre = 1; pre <= amount; pre++) {\n                for (int current : coins) {\n                    if (pre >= current) {\n                        DP[pre] = min(DP[pre - current] + 1, DP[pre]);\n                    } else {\n                        break;\n                    }\n                }\n            }\n            return DP[amount] == INT_MAX ? -1 : DP[amount];\n        }\n};\n```\n\nThis solution is as much as the above but its form changed, and its time complex is O(NM), and it gets AC.\n","slug":"CoinChange","published":1,"updated":"2017-01-14T12:09:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5po0001pff4nh2393lr","content":"<blockquote>\n<p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>\n<p>Example 1:<br>coins = [1, 2, 5], amount = 11<br>return 3 (11 = 5 + 5 + 1)</p>\n<p>Example 2:<br>coins = [2], amount = 3<br>return -1.</p>\n<p>Note: You may assume that you have an infinite number of each kind of coin.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 322, and it’s quite a DP problem, so I first find this solution:</p>\n<ol>\n<li>use a DP array to store all the result from 0 to amount</li>\n<li><p>foreach add the coins to match the amount. for instance, we can find such an example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">  --- 2</div><div class=\"line\">1 --- 3</div><div class=\"line\">  --- 6</div><div class=\"line\">  --- 3</div><div class=\"line\">2 --- 4</div><div class=\"line\">  --- 7</div><div class=\"line\">    ...</div></pre></td></tr></table></figure>\n</li>\n<li><p>So, after all this match we can finally find the result.</p>\n</li>\n</ol>\n<p>So, I write such solution code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</div><div class=\"line\">            sort(coins.begin(), coins.end());</div><div class=\"line\">            if (amount == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (coins[0] &gt; amount) &#123;</div><div class=\"line\">                return -1;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">            vector&lt;long&gt; DP(amount + 1, INT_MAX);</div><div class=\"line\">            map&lt;long, set&lt;long&gt; &gt; coinMap;</div><div class=\"line\">            long level = 1;</div><div class=\"line\">            set&lt;long&gt; zeroN;</div><div class=\"line\">            zeroN.insert(0);</div><div class=\"line\">            coinMap.insert(pair&lt;long, set&lt;long&gt; &gt;(0, zeroN));</div><div class=\"line\">            DP[0] = 0;</div><div class=\"line\"></div><div class=\"line\">            while (DP[amount] == INT_MAX) &#123;</div><div class=\"line\">                coinMap.insert(pair&lt;long, set&lt;long&gt; &gt;(level, set&lt;long&gt;()));</div><div class=\"line\">                for (int preCoin : coinMap[level - 1]) &#123;</div><div class=\"line\">                    for (int coin : coins) &#123;</div><div class=\"line\">                        if (preCoin + (long)coin &lt;= (long)amount) &#123;</div><div class=\"line\">                            coinMap[level].insert(preCoin + coin);</div><div class=\"line\">                            DP[preCoin + coin] = min(DP[preCoin] + 1, DP[coin + preCoin]);</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (coinMap[level].size() == 0) &#123;</div><div class=\"line\">                    return -1;</div><div class=\"line\">                &#125;</div><div class=\"line\">                level++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return DP[amount];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>But, it gets TLE. So I want to find where I am wrong. I think I use too much unnecessary maps. So I simplfy my code:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</div><div class=\"line\">            vector&lt;long&gt; DP(amount + 1, INT_MAX);</div><div class=\"line\"></div><div class=\"line\">            sort(coins.begin(), coins.end());</div><div class=\"line\">            if (amount == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (coins[0] &gt; amount) &#123;</div><div class=\"line\">                return -1;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            long start = 0;</div><div class=\"line\">            long end = 0;</div><div class=\"line\"></div><div class=\"line\">            DP[0] = 0;</div><div class=\"line\"></div><div class=\"line\">            while (start &lt;= amount) &#123;</div><div class=\"line\">                for (int pre = start; pre &lt;= end; pre++) &#123;</div><div class=\"line\">                    for (int coin : coins) &#123;</div><div class=\"line\">                        if ((long)coin + (long)pre &lt;= (long)amount) &#123;</div><div class=\"line\">                            DP[coin + pre] = min(DP[pre] + 1, DP[coin + pre]);</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                start = coins[0] + start;</div><div class=\"line\">                end = min((long)coins[coins.size() - 1] + (long)end, (long)amount);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return DP[amount] == INT_MAX ? -1 : DP[amount];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>However it still gets a TLE. Then I realize, how about just change the form of code, use the DP array as the standard:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</div><div class=\"line\">            vector&lt;long&gt; DP(amount + 1, INT_MAX);</div><div class=\"line\"></div><div class=\"line\">            sort(coins.begin(), coins.end());</div><div class=\"line\">            if (amount == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (coins[0] &gt; amount) &#123;</div><div class=\"line\">                return -1;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            DP[0] = 0;</div><div class=\"line\">            for (int pre = 1; pre &lt;= amount; pre++) &#123;</div><div class=\"line\">                for (int current : coins) &#123;</div><div class=\"line\">                    if (pre &gt;= current) &#123;</div><div class=\"line\">                        DP[pre] = min(DP[pre - current] + 1, DP[pre]);</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return DP[amount] == INT_MAX ? -1 : DP[amount];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>This solution is as much as the above but its form changed, and its time complex is O(NM), and it gets AC.</p>\n","excerpt":"<blockquote>\n<p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>\n<p>Example 1:<br>coins = [1, 2, 5], amount = 11<br>return 3 (11 = 5 + 5 + 1)</p>\n<p>Example 2:<br>coins = [2], amount = 3<br>return -1.</p>\n<p>Note: You may assume that you have an infinite number of each kind of coin.</p>\n</blockquote>","more":"<p>This is Leetcode 322, and it’s quite a DP problem, so I first find this solution:</p>\n<ol>\n<li>use a DP array to store all the result from 0 to amount</li>\n<li><p>foreach add the coins to match the amount. for instance, we can find such an example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">  --- 2</div><div class=\"line\">1 --- 3</div><div class=\"line\">  --- 6</div><div class=\"line\">  --- 3</div><div class=\"line\">2 --- 4</div><div class=\"line\">  --- 7</div><div class=\"line\">    ...</div></pre></td></tr></table></figure>\n</li>\n<li><p>So, after all this match we can finally find the result.</p>\n</li>\n</ol>\n<p>So, I write such solution code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</div><div class=\"line\">            sort(coins.begin(), coins.end());</div><div class=\"line\">            if (amount == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (coins[0] &gt; amount) &#123;</div><div class=\"line\">                return -1;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">            vector&lt;long&gt; DP(amount + 1, INT_MAX);</div><div class=\"line\">            map&lt;long, set&lt;long&gt; &gt; coinMap;</div><div class=\"line\">            long level = 1;</div><div class=\"line\">            set&lt;long&gt; zeroN;</div><div class=\"line\">            zeroN.insert(0);</div><div class=\"line\">            coinMap.insert(pair&lt;long, set&lt;long&gt; &gt;(0, zeroN));</div><div class=\"line\">            DP[0] = 0;</div><div class=\"line\"></div><div class=\"line\">            while (DP[amount] == INT_MAX) &#123;</div><div class=\"line\">                coinMap.insert(pair&lt;long, set&lt;long&gt; &gt;(level, set&lt;long&gt;()));</div><div class=\"line\">                for (int preCoin : coinMap[level - 1]) &#123;</div><div class=\"line\">                    for (int coin : coins) &#123;</div><div class=\"line\">                        if (preCoin + (long)coin &lt;= (long)amount) &#123;</div><div class=\"line\">                            coinMap[level].insert(preCoin + coin);</div><div class=\"line\">                            DP[preCoin + coin] = min(DP[preCoin] + 1, DP[coin + preCoin]);</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (coinMap[level].size() == 0) &#123;</div><div class=\"line\">                    return -1;</div><div class=\"line\">                &#125;</div><div class=\"line\">                level++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return DP[amount];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>But, it gets TLE. So I want to find where I am wrong. I think I use too much unnecessary maps. So I simplfy my code:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</div><div class=\"line\">            vector&lt;long&gt; DP(amount + 1, INT_MAX);</div><div class=\"line\"></div><div class=\"line\">            sort(coins.begin(), coins.end());</div><div class=\"line\">            if (amount == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (coins[0] &gt; amount) &#123;</div><div class=\"line\">                return -1;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            long start = 0;</div><div class=\"line\">            long end = 0;</div><div class=\"line\"></div><div class=\"line\">            DP[0] = 0;</div><div class=\"line\"></div><div class=\"line\">            while (start &lt;= amount) &#123;</div><div class=\"line\">                for (int pre = start; pre &lt;= end; pre++) &#123;</div><div class=\"line\">                    for (int coin : coins) &#123;</div><div class=\"line\">                        if ((long)coin + (long)pre &lt;= (long)amount) &#123;</div><div class=\"line\">                            DP[coin + pre] = min(DP[pre] + 1, DP[coin + pre]);</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                start = coins[0] + start;</div><div class=\"line\">                end = min((long)coins[coins.size() - 1] + (long)end, (long)amount);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return DP[amount] == INT_MAX ? -1 : DP[amount];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>However it still gets a TLE. Then I realize, how about just change the form of code, use the DP array as the standard:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</div><div class=\"line\">            vector&lt;long&gt; DP(amount + 1, INT_MAX);</div><div class=\"line\"></div><div class=\"line\">            sort(coins.begin(), coins.end());</div><div class=\"line\">            if (amount == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (coins[0] &gt; amount) &#123;</div><div class=\"line\">                return -1;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            DP[0] = 0;</div><div class=\"line\">            for (int pre = 1; pre &lt;= amount; pre++) &#123;</div><div class=\"line\">                for (int current : coins) &#123;</div><div class=\"line\">                    if (pre &gt;= current) &#123;</div><div class=\"line\">                        DP[pre] = min(DP[pre - current] + 1, DP[pre]);</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return DP[amount] == INT_MAX ? -1 : DP[amount];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>This solution is as much as the above but its form changed, and its time complex is O(NM), and it gets AC.</p>"},{"title":"Battleships in a Board","date":"2017-01-05T05:46:25.000Z","_content":"\n> Given an 2D board, count how many different battleships are in it. The battleships are represented with 'X's, empty slots are represented with '.'s. You may assume the following rules:\n>\n>  + You receive a valid board, made of only battleships or empty slots.\n>  + Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.\n>  + At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.\n>\n> Example:\n>\n> X..X\n> ...X\n> ...X\n>\n> In the above board there are 2 battleships.\n>\n> Invalid Example:\n>\n> ...X\n> XXXX\n> ...X\n>\n> This is an invalid board that you will not receive - as battleships will always have a cell separating between them.\n>\n> Follow up:\n> Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?\n\n<!-- more -->\n\nThis is Leetcode 419, and it's easy enough to figure out with simulation way as following:\n\n1. find the first X char, from up to down and left to right.\n2. if found, then search up and right, to check whether it is ok.\n3. use a global flag to mark if it's good for the result.\n\nThis method will use O(n*n) array to mark the visited position, if not it will modify the value of the board to make sure no cell will visit twice.\n\nFor example, if we use a visited array to mark the visited cells. the solution will be like these:\n\n```\nbool checkShip(vector<vector<char> > &board, int **visited, int idx, int idy) {\n    if (visited[idx][idy]) {\n        return false;\n    }\n\n    bool res = true;\n    // check the direction, down\n    int currentIdx = idx, currentIdy = idy;\n    while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n        if (board[currentIdx][currentIdy] == 'X') {\n            if (currentIdy + 1 < (int)board[0].size() && board[currentIdx][currentIdy + 1] == 'X') {\n                res = false;\n                break;\n            }\n            if (currentIdy - 1 >= 0 && board[currentIdx][currentIdy - 1] == 'X') {\n                res = false;\n                break;\n            }\n        } else {\n            res = true;\n            break;\n        }\n        currentIdx++;\n    }\n    // check the direction, right\n    currentIdx = idx, currentIdy = idy;\n    if (!res) {\n        res = true;\n        while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n            if (board[currentIdx][currentIdy] == 'X') {\n                if (currentIdx + 1 < (int)board.size() && board[currentIdx + 1][currentIdy] == 'X') {\n                    res = false;\n                    break;\n                }\n                if (currentIdx - 1 >= 0 && board[currentIdx - 1][currentIdy] == 'X') {\n                    res = false;\n                    break;\n                }\n            } else {\n                res = true;\n                break;\n            }\n            currentIdy++;\n        }\n    }\n    _visit(board, visited, idx, idy);\n    return res;\n}\n\nvoid _visit(vector<vector<char> > &board, int **visited, int idx, int idy) {\n    if (idx < 0 || idy < 0|| idx >= (int)board.size() || idy >= (int)board[0].size()) {\n        return;\n    }\n    if (visited[idx][idy]) {\n        return;\n    }\n    if (board[idx][idy] == '.') {\n        return;\n    }\n    visited[idx][idy] = 1;\n    _visit(board, visited, idx + 1, idy);\n    _visit(board, visited, idx, idy + 1);\n    _visit(board, visited, idx - 1, idy);\n    _visit(board, visited, idx, idy - 1);\n}\n\nint countBattleships(vector<vector<char> >& board) {\n    int* visited[board.size()];\n    for (int i = 0; i < (int)board.size(); i++) {\n        visited[i] = new int[board[0].size()];\n        memset(visited[i], 0, sizeof(int) * board[0].size());\n    }\n    int res = 0;\n    for (int idx = 0; idx < (int)board.size(); idx++) {\n        for (int idy = 0; idy < (int)board[0].size(); idy++) {\n            if (board[idx][idy] == 'X' && checkShip(board, visited, idx, idy)) {\n                res++;\n            }\n        }\n    }\n    return res;\n}\n```\n\nBut, if we can give up the visited array, just make sure the current cell's left or up have X char to mark it has been visited. It will make sense.\n\nSo, we should add these method to replace the former visited array:\n\n```\nbool isVisited(vector<vector<char> > &board, int idx, int idy) {\n    if (idx == 0 && idy == 0) {\n        return false;\n    } else if (idx == 0) {\n        return board[idx][idy - 1] == 'X';\n    } else if (idy == 0) {\n        return board[idx - 1][idy] == 'X';\n    } else {\n        return board[idx - 1][idy] == 'X' || board[idx][idy - 1] == 'X';\n    }\n}\n```\nSo, the last AC code will like these:\n\n```\nclass Solution {\n    public:\n        bool isVisited(vector<vector<char> > &board, int idx, int idy) {\n            if (idx == 0 && idy == 0) {\n                return false;\n            } else if (idx == 0) {\n                return board[idx][idy - 1] == 'X';\n            } else if (idy == 0) {\n                return board[idx - 1][idy] == 'X';\n            } else {\n                return board[idx - 1][idy] == 'X' || board[idx][idy - 1] == 'X';\n            }\n        }\n\n        bool checkShip(vector<vector<char> > &board, int idx, int idy) {\n            if (isVisited(board, idx, idy)) {\n                return false;\n            }\n\n            bool res = true;\n            // check the direction, down\n            int currentIdx = idx, currentIdy = idy;\n            while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n                if (board[currentIdx][currentIdy] == 'X') {\n                    if (currentIdy + 1 < (int)board[0].size() && board[currentIdx][currentIdy + 1] == 'X') {\n                        res = false;\n                        break;\n                    }\n                    if (currentIdy - 1 >= 0 && board[currentIdx][currentIdy - 1] == 'X') {\n                        res = false;\n                        break;\n                    }\n                } else {\n                    res = true;\n                    break;\n                }\n                currentIdx++;\n            }\n            // check the direction, right\n            currentIdx = idx, currentIdy = idy;\n            if (!res) {\n                res = true;\n                while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n                    if (board[currentIdx][currentIdy] == 'X') {\n                        if (currentIdx + 1 < (int)board.size() && board[currentIdx + 1][currentIdy] == 'X') {\n                            res = false;\n                            break;\n                        }\n                        if (currentIdx - 1 >= 0 && board[currentIdx - 1][currentIdy] == 'X') {\n                            res = false;\n                            break;\n                        }\n                    } else {\n                        res = true;\n                        break;\n                    }\n                    currentIdy++;\n                }\n            }\n            _visit(board, idx, idy);\n            return res;\n        }\n\n        void _visit(vector<vector<char> > &board, int idx, int idy) {\n            if (idx < 0 || idy < 0|| idx >= (int)board.size() || idy >= (int)board[0].size()) {\n                return;\n            }\n            if (isVisited(board, idx, idy)) {\n                return;\n            }\n            if (board[idx][idy] == '.') {\n                return;\n            }\n            // visited[idx][idy] = 1;\n            _visit(board, idx + 1, idy);\n            _visit(board, idx, idy + 1);\n            _visit(board, idx - 1, idy);\n            _visit(board, idx, idy - 1);\n        }\n\n        int countBattleships(vector<vector<char> >& board) {\n            int res = 0;\n            for (int idx = 0; idx < (int)board.size(); idx++) {\n                for (int idy = 0; idy < (int)board[0].size(); idy++) {\n                    if (board[idx][idy] == 'X' && checkShip(board, idx, idy)) {\n                        res++;\n                    }\n                }\n            }\n            return res;\n        }\n};\n```\n","source":"_posts/BattleshipsinaBoard.md","raw":"---\ntitle: Battleships in a Board\ndate: 2017-01-05 13:46:25\ntags:\n    - Simulation\n---\n\n> Given an 2D board, count how many different battleships are in it. The battleships are represented with 'X's, empty slots are represented with '.'s. You may assume the following rules:\n>\n>  + You receive a valid board, made of only battleships or empty slots.\n>  + Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.\n>  + At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.\n>\n> Example:\n>\n> X..X\n> ...X\n> ...X\n>\n> In the above board there are 2 battleships.\n>\n> Invalid Example:\n>\n> ...X\n> XXXX\n> ...X\n>\n> This is an invalid board that you will not receive - as battleships will always have a cell separating between them.\n>\n> Follow up:\n> Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?\n\n<!-- more -->\n\nThis is Leetcode 419, and it's easy enough to figure out with simulation way as following:\n\n1. find the first X char, from up to down and left to right.\n2. if found, then search up and right, to check whether it is ok.\n3. use a global flag to mark if it's good for the result.\n\nThis method will use O(n*n) array to mark the visited position, if not it will modify the value of the board to make sure no cell will visit twice.\n\nFor example, if we use a visited array to mark the visited cells. the solution will be like these:\n\n```\nbool checkShip(vector<vector<char> > &board, int **visited, int idx, int idy) {\n    if (visited[idx][idy]) {\n        return false;\n    }\n\n    bool res = true;\n    // check the direction, down\n    int currentIdx = idx, currentIdy = idy;\n    while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n        if (board[currentIdx][currentIdy] == 'X') {\n            if (currentIdy + 1 < (int)board[0].size() && board[currentIdx][currentIdy + 1] == 'X') {\n                res = false;\n                break;\n            }\n            if (currentIdy - 1 >= 0 && board[currentIdx][currentIdy - 1] == 'X') {\n                res = false;\n                break;\n            }\n        } else {\n            res = true;\n            break;\n        }\n        currentIdx++;\n    }\n    // check the direction, right\n    currentIdx = idx, currentIdy = idy;\n    if (!res) {\n        res = true;\n        while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n            if (board[currentIdx][currentIdy] == 'X') {\n                if (currentIdx + 1 < (int)board.size() && board[currentIdx + 1][currentIdy] == 'X') {\n                    res = false;\n                    break;\n                }\n                if (currentIdx - 1 >= 0 && board[currentIdx - 1][currentIdy] == 'X') {\n                    res = false;\n                    break;\n                }\n            } else {\n                res = true;\n                break;\n            }\n            currentIdy++;\n        }\n    }\n    _visit(board, visited, idx, idy);\n    return res;\n}\n\nvoid _visit(vector<vector<char> > &board, int **visited, int idx, int idy) {\n    if (idx < 0 || idy < 0|| idx >= (int)board.size() || idy >= (int)board[0].size()) {\n        return;\n    }\n    if (visited[idx][idy]) {\n        return;\n    }\n    if (board[idx][idy] == '.') {\n        return;\n    }\n    visited[idx][idy] = 1;\n    _visit(board, visited, idx + 1, idy);\n    _visit(board, visited, idx, idy + 1);\n    _visit(board, visited, idx - 1, idy);\n    _visit(board, visited, idx, idy - 1);\n}\n\nint countBattleships(vector<vector<char> >& board) {\n    int* visited[board.size()];\n    for (int i = 0; i < (int)board.size(); i++) {\n        visited[i] = new int[board[0].size()];\n        memset(visited[i], 0, sizeof(int) * board[0].size());\n    }\n    int res = 0;\n    for (int idx = 0; idx < (int)board.size(); idx++) {\n        for (int idy = 0; idy < (int)board[0].size(); idy++) {\n            if (board[idx][idy] == 'X' && checkShip(board, visited, idx, idy)) {\n                res++;\n            }\n        }\n    }\n    return res;\n}\n```\n\nBut, if we can give up the visited array, just make sure the current cell's left or up have X char to mark it has been visited. It will make sense.\n\nSo, we should add these method to replace the former visited array:\n\n```\nbool isVisited(vector<vector<char> > &board, int idx, int idy) {\n    if (idx == 0 && idy == 0) {\n        return false;\n    } else if (idx == 0) {\n        return board[idx][idy - 1] == 'X';\n    } else if (idy == 0) {\n        return board[idx - 1][idy] == 'X';\n    } else {\n        return board[idx - 1][idy] == 'X' || board[idx][idy - 1] == 'X';\n    }\n}\n```\nSo, the last AC code will like these:\n\n```\nclass Solution {\n    public:\n        bool isVisited(vector<vector<char> > &board, int idx, int idy) {\n            if (idx == 0 && idy == 0) {\n                return false;\n            } else if (idx == 0) {\n                return board[idx][idy - 1] == 'X';\n            } else if (idy == 0) {\n                return board[idx - 1][idy] == 'X';\n            } else {\n                return board[idx - 1][idy] == 'X' || board[idx][idy - 1] == 'X';\n            }\n        }\n\n        bool checkShip(vector<vector<char> > &board, int idx, int idy) {\n            if (isVisited(board, idx, idy)) {\n                return false;\n            }\n\n            bool res = true;\n            // check the direction, down\n            int currentIdx = idx, currentIdy = idy;\n            while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n                if (board[currentIdx][currentIdy] == 'X') {\n                    if (currentIdy + 1 < (int)board[0].size() && board[currentIdx][currentIdy + 1] == 'X') {\n                        res = false;\n                        break;\n                    }\n                    if (currentIdy - 1 >= 0 && board[currentIdx][currentIdy - 1] == 'X') {\n                        res = false;\n                        break;\n                    }\n                } else {\n                    res = true;\n                    break;\n                }\n                currentIdx++;\n            }\n            // check the direction, right\n            currentIdx = idx, currentIdy = idy;\n            if (!res) {\n                res = true;\n                while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n                    if (board[currentIdx][currentIdy] == 'X') {\n                        if (currentIdx + 1 < (int)board.size() && board[currentIdx + 1][currentIdy] == 'X') {\n                            res = false;\n                            break;\n                        }\n                        if (currentIdx - 1 >= 0 && board[currentIdx - 1][currentIdy] == 'X') {\n                            res = false;\n                            break;\n                        }\n                    } else {\n                        res = true;\n                        break;\n                    }\n                    currentIdy++;\n                }\n            }\n            _visit(board, idx, idy);\n            return res;\n        }\n\n        void _visit(vector<vector<char> > &board, int idx, int idy) {\n            if (idx < 0 || idy < 0|| idx >= (int)board.size() || idy >= (int)board[0].size()) {\n                return;\n            }\n            if (isVisited(board, idx, idy)) {\n                return;\n            }\n            if (board[idx][idy] == '.') {\n                return;\n            }\n            // visited[idx][idy] = 1;\n            _visit(board, idx + 1, idy);\n            _visit(board, idx, idy + 1);\n            _visit(board, idx - 1, idy);\n            _visit(board, idx, idy - 1);\n        }\n\n        int countBattleships(vector<vector<char> >& board) {\n            int res = 0;\n            for (int idx = 0; idx < (int)board.size(); idx++) {\n                for (int idy = 0; idy < (int)board[0].size(); idy++) {\n                    if (board[idx][idy] == 'X' && checkShip(board, idx, idy)) {\n                        res++;\n                    }\n                }\n            }\n            return res;\n        }\n};\n```\n","slug":"BattleshipsinaBoard","published":1,"updated":"2017-01-05T05:46:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5pu0003pff41r8fjk4b","content":"<blockquote>\n<p>Given an 2D board, count how many different battleships are in it. The battleships are represented with ‘X’s, empty slots are represented with ‘.’s. You may assume the following rules:</p>\n<ul>\n<li>You receive a valid board, made of only battleships or empty slots.</li>\n<li>Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.</li>\n<li>At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.</li>\n</ul>\n<p>Example:</p>\n<p>X..X<br>…X<br>…X</p>\n<p>In the above board there are 2 battleships.</p>\n<p>Invalid Example:</p>\n<p>…X<br>XXXX<br>…X</p>\n<p>This is an invalid board that you will not receive - as battleships will always have a cell separating between them.</p>\n<p>Follow up:<br>Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 419, and it’s easy enough to figure out with simulation way as following:</p>\n<ol>\n<li>find the first X char, from up to down and left to right.</li>\n<li>if found, then search up and right, to check whether it is ok.</li>\n<li>use a global flag to mark if it’s good for the result.</li>\n</ol>\n<p>This method will use O(n*n) array to mark the visited position, if not it will modify the value of the board to make sure no cell will visit twice.</p>\n<p>For example, if we use a visited array to mark the visited cells. the solution will be like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool checkShip(vector&lt;vector&lt;char&gt; &gt; &amp;board, int **visited, int idx, int idy) &#123;</div><div class=\"line\">    if (visited[idx][idy]) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    bool res = true;</div><div class=\"line\">    // check the direction, down</div><div class=\"line\">    int currentIdx = idx, currentIdy = idy;</div><div class=\"line\">    while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">        if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">            if (currentIdy + 1 &lt; (int)board[0].size() &amp;&amp; board[currentIdx][currentIdy + 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                res = false;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentIdy - 1 &gt;= 0 &amp;&amp; board[currentIdx][currentIdy - 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                res = false;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            res = true;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        currentIdx++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // check the direction, right</div><div class=\"line\">    currentIdx = idx, currentIdy = idy;</div><div class=\"line\">    if (!res) &#123;</div><div class=\"line\">        res = true;</div><div class=\"line\">        while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">            if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                if (currentIdx + 1 &lt; (int)board.size() &amp;&amp; board[currentIdx + 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    res = false;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (currentIdx - 1 &gt;= 0 &amp;&amp; board[currentIdx - 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    res = false;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                res = true;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentIdy++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    _visit(board, visited, idx, idy);</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void _visit(vector&lt;vector&lt;char&gt; &gt; &amp;board, int **visited, int idx, int idy) &#123;</div><div class=\"line\">    if (idx &lt; 0 || idy &lt; 0|| idx &gt;= (int)board.size() || idy &gt;= (int)board[0].size()) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (visited[idx][idy]) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (board[idx][idy] == &apos;.&apos;) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    visited[idx][idy] = 1;</div><div class=\"line\">    _visit(board, visited, idx + 1, idy);</div><div class=\"line\">    _visit(board, visited, idx, idy + 1);</div><div class=\"line\">    _visit(board, visited, idx - 1, idy);</div><div class=\"line\">    _visit(board, visited, idx, idy - 1);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int countBattleships(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</div><div class=\"line\">    int* visited[board.size()];</div><div class=\"line\">    for (int i = 0; i &lt; (int)board.size(); i++) &#123;</div><div class=\"line\">        visited[i] = new int[board[0].size()];</div><div class=\"line\">        memset(visited[i], 0, sizeof(int) * board[0].size());</div><div class=\"line\">    &#125;</div><div class=\"line\">    int res = 0;</div><div class=\"line\">    for (int idx = 0; idx &lt; (int)board.size(); idx++) &#123;</div><div class=\"line\">        for (int idy = 0; idy &lt; (int)board[0].size(); idy++) &#123;</div><div class=\"line\">            if (board[idx][idy] == &apos;X&apos; &amp;&amp; checkShip(board, visited, idx, idy)) &#123;</div><div class=\"line\">                res++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>But, if we can give up the visited array, just make sure the current cell’s left or up have X char to mark it has been visited. It will make sense.</p>\n<p>So, we should add these method to replace the former visited array:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool isVisited(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">    if (idx == 0 &amp;&amp; idy == 0) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125; else if (idx == 0) &#123;</div><div class=\"line\">        return board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">    &#125; else if (idy == 0) &#123;</div><div class=\"line\">        return board[idx - 1][idy] == &apos;X&apos;;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return board[idx - 1][idy] == &apos;X&apos; || board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>So, the last AC code will like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool isVisited(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (idx == 0 &amp;&amp; idy == 0) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125; else if (idx == 0) &#123;</div><div class=\"line\">                return board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">            &#125; else if (idy == 0) &#123;</div><div class=\"line\">                return board[idx - 1][idy] == &apos;X&apos;;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return board[idx - 1][idy] == &apos;X&apos; || board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool checkShip(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (isVisited(board, idx, idy)) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            bool res = true;</div><div class=\"line\">            // check the direction, down</div><div class=\"line\">            int currentIdx = idx, currentIdy = idy;</div><div class=\"line\">            while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">                if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    if (currentIdy + 1 &lt; (int)board[0].size() &amp;&amp; board[currentIdx][currentIdy + 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                        res = false;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    if (currentIdy - 1 &gt;= 0 &amp;&amp; board[currentIdx][currentIdy - 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                        res = false;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    res = true;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                currentIdx++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // check the direction, right</div><div class=\"line\">            currentIdx = idx, currentIdy = idy;</div><div class=\"line\">            if (!res) &#123;</div><div class=\"line\">                res = true;</div><div class=\"line\">                while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">                    if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                        if (currentIdx + 1 &lt; (int)board.size() &amp;&amp; board[currentIdx + 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                            res = false;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (currentIdx - 1 &gt;= 0 &amp;&amp; board[currentIdx - 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                            res = false;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        res = true;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    currentIdy++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            _visit(board, idx, idy);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _visit(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (idx &lt; 0 || idy &lt; 0|| idx &gt;= (int)board.size() || idy &gt;= (int)board[0].size()) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (isVisited(board, idx, idy)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (board[idx][idy] == &apos;.&apos;) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // visited[idx][idy] = 1;</div><div class=\"line\">            _visit(board, idx + 1, idy);</div><div class=\"line\">            _visit(board, idx, idy + 1);</div><div class=\"line\">            _visit(board, idx - 1, idy);</div><div class=\"line\">            _visit(board, idx, idy - 1);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int countBattleships(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)board.size(); idx++) &#123;</div><div class=\"line\">                for (int idy = 0; idy &lt; (int)board[0].size(); idy++) &#123;</div><div class=\"line\">                    if (board[idx][idy] == &apos;X&apos; &amp;&amp; checkShip(board, idx, idy)) &#123;</div><div class=\"line\">                        res++;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n","excerpt":"<blockquote>\n<p>Given an 2D board, count how many different battleships are in it. The battleships are represented with ‘X’s, empty slots are represented with ‘.’s. You may assume the following rules:</p>\n<ul>\n<li>You receive a valid board, made of only battleships or empty slots.</li>\n<li>Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.</li>\n<li>At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.</li>\n</ul>\n<p>Example:</p>\n<p>X..X<br>…X<br>…X</p>\n<p>In the above board there are 2 battleships.</p>\n<p>Invalid Example:</p>\n<p>…X<br>XXXX<br>…X</p>\n<p>This is an invalid board that you will not receive - as battleships will always have a cell separating between them.</p>\n<p>Follow up:<br>Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?</p>\n</blockquote>","more":"<p>This is Leetcode 419, and it’s easy enough to figure out with simulation way as following:</p>\n<ol>\n<li>find the first X char, from up to down and left to right.</li>\n<li>if found, then search up and right, to check whether it is ok.</li>\n<li>use a global flag to mark if it’s good for the result.</li>\n</ol>\n<p>This method will use O(n*n) array to mark the visited position, if not it will modify the value of the board to make sure no cell will visit twice.</p>\n<p>For example, if we use a visited array to mark the visited cells. the solution will be like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool checkShip(vector&lt;vector&lt;char&gt; &gt; &amp;board, int **visited, int idx, int idy) &#123;</div><div class=\"line\">    if (visited[idx][idy]) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    bool res = true;</div><div class=\"line\">    // check the direction, down</div><div class=\"line\">    int currentIdx = idx, currentIdy = idy;</div><div class=\"line\">    while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">        if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">            if (currentIdy + 1 &lt; (int)board[0].size() &amp;&amp; board[currentIdx][currentIdy + 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                res = false;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentIdy - 1 &gt;= 0 &amp;&amp; board[currentIdx][currentIdy - 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                res = false;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            res = true;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        currentIdx++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // check the direction, right</div><div class=\"line\">    currentIdx = idx, currentIdy = idy;</div><div class=\"line\">    if (!res) &#123;</div><div class=\"line\">        res = true;</div><div class=\"line\">        while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">            if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                if (currentIdx + 1 &lt; (int)board.size() &amp;&amp; board[currentIdx + 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    res = false;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (currentIdx - 1 &gt;= 0 &amp;&amp; board[currentIdx - 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    res = false;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                res = true;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentIdy++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    _visit(board, visited, idx, idy);</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void _visit(vector&lt;vector&lt;char&gt; &gt; &amp;board, int **visited, int idx, int idy) &#123;</div><div class=\"line\">    if (idx &lt; 0 || idy &lt; 0|| idx &gt;= (int)board.size() || idy &gt;= (int)board[0].size()) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (visited[idx][idy]) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (board[idx][idy] == &apos;.&apos;) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    visited[idx][idy] = 1;</div><div class=\"line\">    _visit(board, visited, idx + 1, idy);</div><div class=\"line\">    _visit(board, visited, idx, idy + 1);</div><div class=\"line\">    _visit(board, visited, idx - 1, idy);</div><div class=\"line\">    _visit(board, visited, idx, idy - 1);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int countBattleships(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</div><div class=\"line\">    int* visited[board.size()];</div><div class=\"line\">    for (int i = 0; i &lt; (int)board.size(); i++) &#123;</div><div class=\"line\">        visited[i] = new int[board[0].size()];</div><div class=\"line\">        memset(visited[i], 0, sizeof(int) * board[0].size());</div><div class=\"line\">    &#125;</div><div class=\"line\">    int res = 0;</div><div class=\"line\">    for (int idx = 0; idx &lt; (int)board.size(); idx++) &#123;</div><div class=\"line\">        for (int idy = 0; idy &lt; (int)board[0].size(); idy++) &#123;</div><div class=\"line\">            if (board[idx][idy] == &apos;X&apos; &amp;&amp; checkShip(board, visited, idx, idy)) &#123;</div><div class=\"line\">                res++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>But, if we can give up the visited array, just make sure the current cell’s left or up have X char to mark it has been visited. It will make sense.</p>\n<p>So, we should add these method to replace the former visited array:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool isVisited(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">    if (idx == 0 &amp;&amp; idy == 0) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125; else if (idx == 0) &#123;</div><div class=\"line\">        return board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">    &#125; else if (idy == 0) &#123;</div><div class=\"line\">        return board[idx - 1][idy] == &apos;X&apos;;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return board[idx - 1][idy] == &apos;X&apos; || board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>So, the last AC code will like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool isVisited(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (idx == 0 &amp;&amp; idy == 0) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125; else if (idx == 0) &#123;</div><div class=\"line\">                return board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">            &#125; else if (idy == 0) &#123;</div><div class=\"line\">                return board[idx - 1][idy] == &apos;X&apos;;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return board[idx - 1][idy] == &apos;X&apos; || board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool checkShip(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (isVisited(board, idx, idy)) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            bool res = true;</div><div class=\"line\">            // check the direction, down</div><div class=\"line\">            int currentIdx = idx, currentIdy = idy;</div><div class=\"line\">            while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">                if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    if (currentIdy + 1 &lt; (int)board[0].size() &amp;&amp; board[currentIdx][currentIdy + 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                        res = false;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    if (currentIdy - 1 &gt;= 0 &amp;&amp; board[currentIdx][currentIdy - 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                        res = false;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    res = true;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                currentIdx++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // check the direction, right</div><div class=\"line\">            currentIdx = idx, currentIdy = idy;</div><div class=\"line\">            if (!res) &#123;</div><div class=\"line\">                res = true;</div><div class=\"line\">                while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">                    if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                        if (currentIdx + 1 &lt; (int)board.size() &amp;&amp; board[currentIdx + 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                            res = false;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (currentIdx - 1 &gt;= 0 &amp;&amp; board[currentIdx - 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                            res = false;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        res = true;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    currentIdy++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            _visit(board, idx, idy);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _visit(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (idx &lt; 0 || idy &lt; 0|| idx &gt;= (int)board.size() || idy &gt;= (int)board[0].size()) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (isVisited(board, idx, idy)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (board[idx][idy] == &apos;.&apos;) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // visited[idx][idy] = 1;</div><div class=\"line\">            _visit(board, idx + 1, idy);</div><div class=\"line\">            _visit(board, idx, idy + 1);</div><div class=\"line\">            _visit(board, idx - 1, idy);</div><div class=\"line\">            _visit(board, idx, idy - 1);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int countBattleships(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)board.size(); idx++) &#123;</div><div class=\"line\">                for (int idy = 0; idy &lt; (int)board[0].size(); idy++) &#123;</div><div class=\"line\">                    if (board[idx][idy] == &apos;X&apos; &amp;&amp; checkShip(board, idx, idy)) &#123;</div><div class=\"line\">                        res++;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>"},{"title":"Best Time to Buy and Sell Stock with Cooldown","date":"2017-02-06T07:44:45.000Z","_content":"\n> Say you have an array for which the ith element is the price of a given stock on day i.\n>\n> Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:\n>\n> + You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\n> + After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)\n>\n> Example:\n> + prices = [1, 2, 3, 0, 2]\n> + maxProfit = 3\n> + transactions = [buy, sell, cooldown, buy, sell]\n\n<!--more-->\n\nThis is Leetcode No.309, and it is a such a DP problem. The important thing is to find the relationship of the condition transition.\n\nFirst, you can define two status, No.1 is cooldown, No.2 is hold, No.2 is none.\n\n+ When status = 0, you can only do go on.\n\n+ When status = 1, you can sell or hold.\n\n+ When status = 2, you can buy and go on.\n\nSo, quickly find the solution:\n\n```\nclass Solution {\n    public:\n        int res;\n        int maxProfit(vector<int>& prices) {\n            res = INT_MIN;\n\n            _calc(prices, 2, 0, 0, 0);\n\n            return res;\n        }\n\n        // status: 0 cooldown, 1 hold, 2 none\n        void _calc(vector<int> prices, int currentStatus, int currentIdx, int currentProfit, int holdPrice) {\n            if (currentProfit > res) {\n                res = currentProfit;\n            }\n            if (currentIdx >= (int)prices.size()) {\n                return;\n            }\n            if (currentStatus == 0) {\n                _calc(prices, 2, currentIdx + 1, currentProfit, 0);\n            }\n            if (currentStatus == 1) {\n                // sell if larger than hold\n                if (prices[currentIdx] > holdPrice) {\n                    _calc(prices, 0, currentIdx + 1, currentProfit + prices[currentIdx] - holdPrice, 0);\n                }\n                _calc(prices, 1, currentIdx + 1, currentProfit, holdPrice);\n            }\n            if (currentStatus == 2) {\n                _calc(prices, 2, currentIdx + 1, currentProfit, 0);\n                _calc(prices, 1, currentIdx + 1, currentProfit, prices[currentIdx]);\n            }\n        }\n};\n```\n\nIt is right, but it gets TLE. So, it should need a DP improvement.\n\nSo, we can use three status array to store the status of current to present our profit.\n\nAs, what I say above, we will have three status. So, we can define the DP representation:\n\n+ none[i] = max(none[i - 1], cooldown[i - 1]); // Stay at none, or rest from cooldown\n+ hold[i] = max(hold[i - 1], none[i - 1] - prices[i]); // Stay at hold, or buy from none\n+ cooldown[i] = hold[i - 1] + prices[i]; // Only one way from hold\n\nSo, the initial status is:\n\n+ none[0] = 0;\n+ hold[0] = -prices[0];\n+ cooldown = 0;\n\nSo, the solution is as following:\n\n```\nclass Solution {\n    public:\n        int maxProfit(vector<int>& prices){\n            if (prices.size() <= 1) return 0;\n            vector<int> none(prices.size(), 0);\n            vector<int> hold(prices.size(), 0);\n            vector<int> cooldown(prices.size(), 0);\n            hold[0] = -prices[0];\n            none[0] = 0;\n            cooldown[0] = INT_MIN;\n            for (int i = 1; i < (int)prices.size(); i++) {\n                none[i] = max(none[i - 1], cooldown[i - 1]);\n                hold[i] = max(hold[i - 1], none[i - 1] - prices[i]);\n                cooldown[i] = hold[i - 1] + prices[i];\n            }\n            return max(none[prices.size() - 1], cooldown[prices.size() - 1]);\n        }\n};\n```\n\nAnd it gets AC.\n","source":"_posts/BestTimetoBuyandSellStockwithCooldown.md","raw":"---\ntitle: Best Time to Buy and Sell Stock with Cooldown\ndate: 2017-02-06 15:44:45\ntags:\n    - Dynamic Programming\n---\n\n> Say you have an array for which the ith element is the price of a given stock on day i.\n>\n> Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:\n>\n> + You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\n> + After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)\n>\n> Example:\n> + prices = [1, 2, 3, 0, 2]\n> + maxProfit = 3\n> + transactions = [buy, sell, cooldown, buy, sell]\n\n<!--more-->\n\nThis is Leetcode No.309, and it is a such a DP problem. The important thing is to find the relationship of the condition transition.\n\nFirst, you can define two status, No.1 is cooldown, No.2 is hold, No.2 is none.\n\n+ When status = 0, you can only do go on.\n\n+ When status = 1, you can sell or hold.\n\n+ When status = 2, you can buy and go on.\n\nSo, quickly find the solution:\n\n```\nclass Solution {\n    public:\n        int res;\n        int maxProfit(vector<int>& prices) {\n            res = INT_MIN;\n\n            _calc(prices, 2, 0, 0, 0);\n\n            return res;\n        }\n\n        // status: 0 cooldown, 1 hold, 2 none\n        void _calc(vector<int> prices, int currentStatus, int currentIdx, int currentProfit, int holdPrice) {\n            if (currentProfit > res) {\n                res = currentProfit;\n            }\n            if (currentIdx >= (int)prices.size()) {\n                return;\n            }\n            if (currentStatus == 0) {\n                _calc(prices, 2, currentIdx + 1, currentProfit, 0);\n            }\n            if (currentStatus == 1) {\n                // sell if larger than hold\n                if (prices[currentIdx] > holdPrice) {\n                    _calc(prices, 0, currentIdx + 1, currentProfit + prices[currentIdx] - holdPrice, 0);\n                }\n                _calc(prices, 1, currentIdx + 1, currentProfit, holdPrice);\n            }\n            if (currentStatus == 2) {\n                _calc(prices, 2, currentIdx + 1, currentProfit, 0);\n                _calc(prices, 1, currentIdx + 1, currentProfit, prices[currentIdx]);\n            }\n        }\n};\n```\n\nIt is right, but it gets TLE. So, it should need a DP improvement.\n\nSo, we can use three status array to store the status of current to present our profit.\n\nAs, what I say above, we will have three status. So, we can define the DP representation:\n\n+ none[i] = max(none[i - 1], cooldown[i - 1]); // Stay at none, or rest from cooldown\n+ hold[i] = max(hold[i - 1], none[i - 1] - prices[i]); // Stay at hold, or buy from none\n+ cooldown[i] = hold[i - 1] + prices[i]; // Only one way from hold\n\nSo, the initial status is:\n\n+ none[0] = 0;\n+ hold[0] = -prices[0];\n+ cooldown = 0;\n\nSo, the solution is as following:\n\n```\nclass Solution {\n    public:\n        int maxProfit(vector<int>& prices){\n            if (prices.size() <= 1) return 0;\n            vector<int> none(prices.size(), 0);\n            vector<int> hold(prices.size(), 0);\n            vector<int> cooldown(prices.size(), 0);\n            hold[0] = -prices[0];\n            none[0] = 0;\n            cooldown[0] = INT_MIN;\n            for (int i = 1; i < (int)prices.size(); i++) {\n                none[i] = max(none[i - 1], cooldown[i - 1]);\n                hold[i] = max(hold[i - 1], none[i - 1] - prices[i]);\n                cooldown[i] = hold[i - 1] + prices[i];\n            }\n            return max(none[prices.size() - 1], cooldown[prices.size() - 1]);\n        }\n};\n```\n\nAnd it gets AC.\n","slug":"BestTimetoBuyandSellStockwithCooldown","published":1,"updated":"2017-02-06T08:35:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5pv0004pff43gk7tz63","content":"<blockquote>\n<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>\n<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>\n<ul>\n<li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li>\n<li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li>\n</ul>\n<p>Example:</p>\n<ul>\n<li>prices = [1, 2, 3, 0, 2]</li>\n<li>maxProfit = 3</li>\n<li>transactions = [buy, sell, cooldown, buy, sell]</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.309, and it is a such a DP problem. The important thing is to find the relationship of the condition transition.</p>\n<p>First, you can define two status, No.1 is cooldown, No.2 is hold, No.2 is none.</p>\n<ul>\n<li><p>When status = 0, you can only do go on.</p>\n</li>\n<li><p>When status = 1, you can sell or hold.</p>\n</li>\n<li><p>When status = 2, you can buy and go on.</p>\n</li>\n</ul>\n<p>So, quickly find the solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int res;</div><div class=\"line\">        int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</div><div class=\"line\">            res = INT_MIN;</div><div class=\"line\"></div><div class=\"line\">            _calc(prices, 2, 0, 0, 0);</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // status: 0 cooldown, 1 hold, 2 none</div><div class=\"line\">        void _calc(vector&lt;int&gt; prices, int currentStatus, int currentIdx, int currentProfit, int holdPrice) &#123;</div><div class=\"line\">            if (currentProfit &gt; res) &#123;</div><div class=\"line\">                res = currentProfit;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentIdx &gt;= (int)prices.size()) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentStatus == 0) &#123;</div><div class=\"line\">                _calc(prices, 2, currentIdx + 1, currentProfit, 0);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentStatus == 1) &#123;</div><div class=\"line\">                // sell if larger than hold</div><div class=\"line\">                if (prices[currentIdx] &gt; holdPrice) &#123;</div><div class=\"line\">                    _calc(prices, 0, currentIdx + 1, currentProfit + prices[currentIdx] - holdPrice, 0);</div><div class=\"line\">                &#125;</div><div class=\"line\">                _calc(prices, 1, currentIdx + 1, currentProfit, holdPrice);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentStatus == 2) &#123;</div><div class=\"line\">                _calc(prices, 2, currentIdx + 1, currentProfit, 0);</div><div class=\"line\">                _calc(prices, 1, currentIdx + 1, currentProfit, prices[currentIdx]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It is right, but it gets TLE. So, it should need a DP improvement.</p>\n<p>So, we can use three status array to store the status of current to present our profit.</p>\n<p>As, what I say above, we will have three status. So, we can define the DP representation:</p>\n<ul>\n<li>none[i] = max(none[i - 1], cooldown[i - 1]); // Stay at none, or rest from cooldown</li>\n<li>hold[i] = max(hold[i - 1], none[i - 1] - prices[i]); // Stay at hold, or buy from none</li>\n<li>cooldown[i] = hold[i - 1] + prices[i]; // Only one way from hold</li>\n</ul>\n<p>So, the initial status is:</p>\n<ul>\n<li>none[0] = 0;</li>\n<li>hold[0] = -prices[0];</li>\n<li>cooldown = 0;</li>\n</ul>\n<p>So, the solution is as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int maxProfit(vector&lt;int&gt;&amp; prices)&#123;</div><div class=\"line\">            if (prices.size() &lt;= 1) return 0;</div><div class=\"line\">            vector&lt;int&gt; none(prices.size(), 0);</div><div class=\"line\">            vector&lt;int&gt; hold(prices.size(), 0);</div><div class=\"line\">            vector&lt;int&gt; cooldown(prices.size(), 0);</div><div class=\"line\">            hold[0] = -prices[0];</div><div class=\"line\">            none[0] = 0;</div><div class=\"line\">            cooldown[0] = INT_MIN;</div><div class=\"line\">            for (int i = 1; i &lt; (int)prices.size(); i++) &#123;</div><div class=\"line\">                none[i] = max(none[i - 1], cooldown[i - 1]);</div><div class=\"line\">                hold[i] = max(hold[i - 1], none[i - 1] - prices[i]);</div><div class=\"line\">                cooldown[i] = hold[i - 1] + prices[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            return max(none[prices.size() - 1], cooldown[prices.size() - 1]);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>\n<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>\n<ul>\n<li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li>\n<li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li>\n</ul>\n<p>Example:</p>\n<ul>\n<li>prices = [1, 2, 3, 0, 2]</li>\n<li>maxProfit = 3</li>\n<li>transactions = [buy, sell, cooldown, buy, sell]</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode No.309, and it is a such a DP problem. The important thing is to find the relationship of the condition transition.</p>\n<p>First, you can define two status, No.1 is cooldown, No.2 is hold, No.2 is none.</p>\n<ul>\n<li><p>When status = 0, you can only do go on.</p>\n</li>\n<li><p>When status = 1, you can sell or hold.</p>\n</li>\n<li><p>When status = 2, you can buy and go on.</p>\n</li>\n</ul>\n<p>So, quickly find the solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int res;</div><div class=\"line\">        int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</div><div class=\"line\">            res = INT_MIN;</div><div class=\"line\"></div><div class=\"line\">            _calc(prices, 2, 0, 0, 0);</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // status: 0 cooldown, 1 hold, 2 none</div><div class=\"line\">        void _calc(vector&lt;int&gt; prices, int currentStatus, int currentIdx, int currentProfit, int holdPrice) &#123;</div><div class=\"line\">            if (currentProfit &gt; res) &#123;</div><div class=\"line\">                res = currentProfit;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentIdx &gt;= (int)prices.size()) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentStatus == 0) &#123;</div><div class=\"line\">                _calc(prices, 2, currentIdx + 1, currentProfit, 0);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentStatus == 1) &#123;</div><div class=\"line\">                // sell if larger than hold</div><div class=\"line\">                if (prices[currentIdx] &gt; holdPrice) &#123;</div><div class=\"line\">                    _calc(prices, 0, currentIdx + 1, currentProfit + prices[currentIdx] - holdPrice, 0);</div><div class=\"line\">                &#125;</div><div class=\"line\">                _calc(prices, 1, currentIdx + 1, currentProfit, holdPrice);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentStatus == 2) &#123;</div><div class=\"line\">                _calc(prices, 2, currentIdx + 1, currentProfit, 0);</div><div class=\"line\">                _calc(prices, 1, currentIdx + 1, currentProfit, prices[currentIdx]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It is right, but it gets TLE. So, it should need a DP improvement.</p>\n<p>So, we can use three status array to store the status of current to present our profit.</p>\n<p>As, what I say above, we will have three status. So, we can define the DP representation:</p>\n<ul>\n<li>none[i] = max(none[i - 1], cooldown[i - 1]); // Stay at none, or rest from cooldown</li>\n<li>hold[i] = max(hold[i - 1], none[i - 1] - prices[i]); // Stay at hold, or buy from none</li>\n<li>cooldown[i] = hold[i - 1] + prices[i]; // Only one way from hold</li>\n</ul>\n<p>So, the initial status is:</p>\n<ul>\n<li>none[0] = 0;</li>\n<li>hold[0] = -prices[0];</li>\n<li>cooldown = 0;</li>\n</ul>\n<p>So, the solution is as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int maxProfit(vector&lt;int&gt;&amp; prices)&#123;</div><div class=\"line\">            if (prices.size() &lt;= 1) return 0;</div><div class=\"line\">            vector&lt;int&gt; none(prices.size(), 0);</div><div class=\"line\">            vector&lt;int&gt; hold(prices.size(), 0);</div><div class=\"line\">            vector&lt;int&gt; cooldown(prices.size(), 0);</div><div class=\"line\">            hold[0] = -prices[0];</div><div class=\"line\">            none[0] = 0;</div><div class=\"line\">            cooldown[0] = INT_MIN;</div><div class=\"line\">            for (int i = 1; i &lt; (int)prices.size(); i++) &#123;</div><div class=\"line\">                none[i] = max(none[i - 1], cooldown[i - 1]);</div><div class=\"line\">                hold[i] = max(hold[i - 1], none[i - 1] - prices[i]);</div><div class=\"line\">                cooldown[i] = hold[i - 1] + prices[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            return max(none[prices.size() - 1], cooldown[prices.size() - 1]);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>"},{"title":"Combination Sum IV","date":"2017-01-11T01:36:11.000Z","_content":"\n> Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.\n>\n> Example:\n>\n> nums = [1, 2, 3] , target = 4\n>\n> The possible combination ways are:\n> (1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 3), (2, 1, 1), (2, 2), (3, 1)\n>\n> Note that different sequences are counted as different combinations.\n>\n> Therefore the output is 7.\n>\n> Follow up:\n> What if negative numbers are allowed in the given array?\n> How does it change the problem?\n> What limitation we need to add to the question to allow negative number.\n\n<!--more-->\n\nThis is Leetcode 377, we can quickly find a DFS solution like these:\n\n```\nclass Solution {\n    public:\n        int res;\n        int combinationSum4(vector<int>& nums, int target) {\n            sort(nums.begin(), nums.end());\n            res = 0;\n            DFS(nums, target, 0);\n            return res;\n        }\n\n        void DFS(vector<int> &nums, int target, int currentSum) {\n            for (int i = 0; i < (int)nums.size(); i++) {\n                if (currentSum + nums[i] > target) {\n                    return;\n                } else if (currentSum + nums[i] == target) {\n                    res++;\n                } else {\n                    DFS(nums, target, currentSum + nums[i]);\n                }\n            }\n        }\n};\n```\n\nIt will solve this problem but it's too slow to get AC. So, we can think in another way.\n\nPicture this, we based on the sum. Make a DP array to store the value of the sum kinds of nums which sumed as the key.\n\nSo, the solution is as following:\n\n```\nclass Solution {\n    public:\n        int res;\n        int combinationSum4(vector<int>& nums, int target) {\n            vector<int> res(target + 1, 0);\n            sort(nums.begin(), nums.end());\n            for (int i = 1; i <= target; i++) {\n                for (int num : nums) {\n                    if (num > i) {\n                        break;\n                    } else if (num == i) {\n                        res[num]++;\n                    } else {\n                        res[i] = res[i - num] + res[i];\n                    }\n                }\n            }\n            return res[target];\n        }\n};\n```\n\nAnd it gets AC.\n","source":"_posts/CombinationSumIV.md","raw":"---\ntitle: Combination Sum IV\ndate: 2017-01-11 09:36:11\ntags:\n    - Dynamic Programming\n---\n\n> Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.\n>\n> Example:\n>\n> nums = [1, 2, 3] , target = 4\n>\n> The possible combination ways are:\n> (1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 3), (2, 1, 1), (2, 2), (3, 1)\n>\n> Note that different sequences are counted as different combinations.\n>\n> Therefore the output is 7.\n>\n> Follow up:\n> What if negative numbers are allowed in the given array?\n> How does it change the problem?\n> What limitation we need to add to the question to allow negative number.\n\n<!--more-->\n\nThis is Leetcode 377, we can quickly find a DFS solution like these:\n\n```\nclass Solution {\n    public:\n        int res;\n        int combinationSum4(vector<int>& nums, int target) {\n            sort(nums.begin(), nums.end());\n            res = 0;\n            DFS(nums, target, 0);\n            return res;\n        }\n\n        void DFS(vector<int> &nums, int target, int currentSum) {\n            for (int i = 0; i < (int)nums.size(); i++) {\n                if (currentSum + nums[i] > target) {\n                    return;\n                } else if (currentSum + nums[i] == target) {\n                    res++;\n                } else {\n                    DFS(nums, target, currentSum + nums[i]);\n                }\n            }\n        }\n};\n```\n\nIt will solve this problem but it's too slow to get AC. So, we can think in another way.\n\nPicture this, we based on the sum. Make a DP array to store the value of the sum kinds of nums which sumed as the key.\n\nSo, the solution is as following:\n\n```\nclass Solution {\n    public:\n        int res;\n        int combinationSum4(vector<int>& nums, int target) {\n            vector<int> res(target + 1, 0);\n            sort(nums.begin(), nums.end());\n            for (int i = 1; i <= target; i++) {\n                for (int num : nums) {\n                    if (num > i) {\n                        break;\n                    } else if (num == i) {\n                        res[num]++;\n                    } else {\n                        res[i] = res[i - num] + res[i];\n                    }\n                }\n            }\n            return res[target];\n        }\n};\n```\n\nAnd it gets AC.\n","slug":"CombinationSumIV","published":1,"updated":"2017-01-13T03:09:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5py0005pff47rm9pv72","content":"<blockquote>\n<p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p>\n<p>Example:</p>\n<p>nums = [1, 2, 3] , target = 4</p>\n<p>The possible combination ways are:<br>(1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 3), (2, 1, 1), (2, 2), (3, 1)</p>\n<p>Note that different sequences are counted as different combinations.</p>\n<p>Therefore the output is 7.</p>\n<p>Follow up:<br>What if negative numbers are allowed in the given array?<br>How does it change the problem?<br>What limitation we need to add to the question to allow negative number.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 377, we can quickly find a DFS solution like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int res;</div><div class=\"line\">        int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class=\"line\">            sort(nums.begin(), nums.end());</div><div class=\"line\">            res = 0;</div><div class=\"line\">            DFS(nums, target, 0);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void DFS(vector&lt;int&gt; &amp;nums, int target, int currentSum) &#123;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (currentSum + nums[i] &gt; target) &#123;</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125; else if (currentSum + nums[i] == target) &#123;</div><div class=\"line\">                    res++;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    DFS(nums, target, currentSum + nums[i]);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It will solve this problem but it’s too slow to get AC. So, we can think in another way.</p>\n<p>Picture this, we based on the sum. Make a DP array to store the value of the sum kinds of nums which sumed as the key.</p>\n<p>So, the solution is as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int res;</div><div class=\"line\">        int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class=\"line\">            vector&lt;int&gt; res(target + 1, 0);</div><div class=\"line\">            sort(nums.begin(), nums.end());</div><div class=\"line\">            for (int i = 1; i &lt;= target; i++) &#123;</div><div class=\"line\">                for (int num : nums) &#123;</div><div class=\"line\">                    if (num &gt; i) &#123;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125; else if (num == i) &#123;</div><div class=\"line\">                        res[num]++;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        res[i] = res[i - num] + res[i];</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res[target];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p>\n<p>Example:</p>\n<p>nums = [1, 2, 3] , target = 4</p>\n<p>The possible combination ways are:<br>(1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 3), (2, 1, 1), (2, 2), (3, 1)</p>\n<p>Note that different sequences are counted as different combinations.</p>\n<p>Therefore the output is 7.</p>\n<p>Follow up:<br>What if negative numbers are allowed in the given array?<br>How does it change the problem?<br>What limitation we need to add to the question to allow negative number.</p>\n</blockquote>","more":"<p>This is Leetcode 377, we can quickly find a DFS solution like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int res;</div><div class=\"line\">        int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class=\"line\">            sort(nums.begin(), nums.end());</div><div class=\"line\">            res = 0;</div><div class=\"line\">            DFS(nums, target, 0);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void DFS(vector&lt;int&gt; &amp;nums, int target, int currentSum) &#123;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (currentSum + nums[i] &gt; target) &#123;</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125; else if (currentSum + nums[i] == target) &#123;</div><div class=\"line\">                    res++;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    DFS(nums, target, currentSum + nums[i]);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It will solve this problem but it’s too slow to get AC. So, we can think in another way.</p>\n<p>Picture this, we based on the sum. Make a DP array to store the value of the sum kinds of nums which sumed as the key.</p>\n<p>So, the solution is as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int res;</div><div class=\"line\">        int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class=\"line\">            vector&lt;int&gt; res(target + 1, 0);</div><div class=\"line\">            sort(nums.begin(), nums.end());</div><div class=\"line\">            for (int i = 1; i &lt;= target; i++) &#123;</div><div class=\"line\">                for (int num : nums) &#123;</div><div class=\"line\">                    if (num &gt; i) &#123;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125; else if (num == i) &#123;</div><div class=\"line\">                        res[num]++;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        res[i] = res[i - num] + res[i];</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res[target];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>"},{"title":"Decode String","date":"2017-01-27T15:11:47.000Z","_content":"\n> Given an encoded string, return it's decoded string.\n>\n> The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\n>\n> You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\n>\n> Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].\n>\n> Examples:\n>\n> + s = \"3[a]2[bc]\", return \"aaabcbc\".\n> + s = \"3[a2[c]]\", return \"accaccacc\".\n> + s = \"2[abc]3[cd]ef\", return \"abcabccdcdcdef\".\n\n<!--more-->\n\nThis is Leetcode 394, and it's a problem with much fun. I have two solutions here. The first one is like what I use to write my own url rule parser. You can find [here - https://mikecoder.cn/post/164](https://mikecoder.cn/post/164).\n\nBut, its time complex is O(n^2). So, I should find a better solution. For example I can decode and read the string at the same time not just to find the pattern.\n\nSo, I will use two stacks to store the value:\n\n```\nclass Solution {\n    public:\n        string decodeString(string str) {\n            stack<string> chars;\n            stack<int> nums;\n            string res;\n            int num = 0;\n            for(char c: str) {\n                if(isdigit(c)) {\n                    num = num*10 + (c - '0');\n                } else if(isalpha(c)) {\n                    res.push_back(c);\n                } else if(c == '[') {\n                    chars.push(res);\n                    nums.push(num);\n                    res = \"\";\n                    num = 0;\n                } else if(c == ']') {\n                    string tmp = res;\n                    for(int i = 0; i < nums.top()-1; ++i) {\n                        res += tmp;\n                    }\n                    res = chars.top() + res;\n                    chars.pop(); nums.pop();\n                }\n            }\n            return res;\n        }\n};\n```\n\nHere is the solution and it gets AC.\n","source":"_posts/DecodeString.md","raw":"---\ntitle: Decode String\ndate: 2017-01-27 23:11:47\ntags:\n    - Stack\n    - Depth-first Search\n---\n\n> Given an encoded string, return it's decoded string.\n>\n> The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\n>\n> You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\n>\n> Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].\n>\n> Examples:\n>\n> + s = \"3[a]2[bc]\", return \"aaabcbc\".\n> + s = \"3[a2[c]]\", return \"accaccacc\".\n> + s = \"2[abc]3[cd]ef\", return \"abcabccdcdcdef\".\n\n<!--more-->\n\nThis is Leetcode 394, and it's a problem with much fun. I have two solutions here. The first one is like what I use to write my own url rule parser. You can find [here - https://mikecoder.cn/post/164](https://mikecoder.cn/post/164).\n\nBut, its time complex is O(n^2). So, I should find a better solution. For example I can decode and read the string at the same time not just to find the pattern.\n\nSo, I will use two stacks to store the value:\n\n```\nclass Solution {\n    public:\n        string decodeString(string str) {\n            stack<string> chars;\n            stack<int> nums;\n            string res;\n            int num = 0;\n            for(char c: str) {\n                if(isdigit(c)) {\n                    num = num*10 + (c - '0');\n                } else if(isalpha(c)) {\n                    res.push_back(c);\n                } else if(c == '[') {\n                    chars.push(res);\n                    nums.push(num);\n                    res = \"\";\n                    num = 0;\n                } else if(c == ']') {\n                    string tmp = res;\n                    for(int i = 0; i < nums.top()-1; ++i) {\n                        res += tmp;\n                    }\n                    res = chars.top() + res;\n                    chars.pop(); nums.pop();\n                }\n            }\n            return res;\n        }\n};\n```\n\nHere is the solution and it gets AC.\n","slug":"DecodeString","published":1,"updated":"2017-01-27T14:05:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5q10008pff4eaqpv7hr","content":"<blockquote>\n<p>Given an encoded string, return it’s decoded string.</p>\n<p>The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.</p>\n<p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>\n<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4].</p>\n<p>Examples:</p>\n<ul>\n<li>s = “3[a]2[bc]”, return “aaabcbc”.</li>\n<li>s = “3[a2[c]]”, return “accaccacc”.</li>\n<li>s = “2[abc]3[cd]ef”, return “abcabccdcdcdef”.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 394, and it’s a problem with much fun. I have two solutions here. The first one is like what I use to write my own url rule parser. You can find <a href=\"https://mikecoder.cn/post/164\" target=\"_blank\" rel=\"external\">here - https://mikecoder.cn/post/164</a>.</p>\n<p>But, its time complex is O(n^2). So, I should find a better solution. For example I can decode and read the string at the same time not just to find the pattern.</p>\n<p>So, I will use two stacks to store the value:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        string decodeString(string str) &#123;</div><div class=\"line\">            stack&lt;string&gt; chars;</div><div class=\"line\">            stack&lt;int&gt; nums;</div><div class=\"line\">            string res;</div><div class=\"line\">            int num = 0;</div><div class=\"line\">            for(char c: str) &#123;</div><div class=\"line\">                if(isdigit(c)) &#123;</div><div class=\"line\">                    num = num*10 + (c - &apos;0&apos;);</div><div class=\"line\">                &#125; else if(isalpha(c)) &#123;</div><div class=\"line\">                    res.push_back(c);</div><div class=\"line\">                &#125; else if(c == &apos;[&apos;) &#123;</div><div class=\"line\">                    chars.push(res);</div><div class=\"line\">                    nums.push(num);</div><div class=\"line\">                    res = &quot;&quot;;</div><div class=\"line\">                    num = 0;</div><div class=\"line\">                &#125; else if(c == &apos;]&apos;) &#123;</div><div class=\"line\">                    string tmp = res;</div><div class=\"line\">                    for(int i = 0; i &lt; nums.top()-1; ++i) &#123;</div><div class=\"line\">                        res += tmp;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    res = chars.top() + res;</div><div class=\"line\">                    chars.pop(); nums.pop();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Here is the solution and it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given an encoded string, return it’s decoded string.</p>\n<p>The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.</p>\n<p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>\n<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4].</p>\n<p>Examples:</p>\n<ul>\n<li>s = “3[a]2[bc]”, return “aaabcbc”.</li>\n<li>s = “3[a2[c]]”, return “accaccacc”.</li>\n<li>s = “2[abc]3[cd]ef”, return “abcabccdcdcdef”.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 394, and it’s a problem with much fun. I have two solutions here. The first one is like what I use to write my own url rule parser. You can find <a href=\"https://mikecoder.cn/post/164\">here - https://mikecoder.cn/post/164</a>.</p>\n<p>But, its time complex is O(n^2). So, I should find a better solution. For example I can decode and read the string at the same time not just to find the pattern.</p>\n<p>So, I will use two stacks to store the value:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        string decodeString(string str) &#123;</div><div class=\"line\">            stack&lt;string&gt; chars;</div><div class=\"line\">            stack&lt;int&gt; nums;</div><div class=\"line\">            string res;</div><div class=\"line\">            int num = 0;</div><div class=\"line\">            for(char c: str) &#123;</div><div class=\"line\">                if(isdigit(c)) &#123;</div><div class=\"line\">                    num = num*10 + (c - &apos;0&apos;);</div><div class=\"line\">                &#125; else if(isalpha(c)) &#123;</div><div class=\"line\">                    res.push_back(c);</div><div class=\"line\">                &#125; else if(c == &apos;[&apos;) &#123;</div><div class=\"line\">                    chars.push(res);</div><div class=\"line\">                    nums.push(num);</div><div class=\"line\">                    res = &quot;&quot;;</div><div class=\"line\">                    num = 0;</div><div class=\"line\">                &#125; else if(c == &apos;]&apos;) &#123;</div><div class=\"line\">                    string tmp = res;</div><div class=\"line\">                    for(int i = 0; i &lt; nums.top()-1; ++i) &#123;</div><div class=\"line\">                        res += tmp;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    res = chars.top() + res;</div><div class=\"line\">                    chars.pop(); nums.pop();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Here is the solution and it gets AC.</p>"},{"title":"Find Mode in Binary Search Tree","date":"2017-02-01T15:59:43.000Z","_content":"\n> Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.\n>\n> Assume a BST is defined as follows:\n>\n> + The left subtree of a node contains only nodes with keys less than or equal to the node's key.\n> + The right subtree of a node contains only nodes with keys greater than or equal to the node's key.\n> + Both the left and right subtrees must also be binary search trees.\n>\n> For example:\n> + Given BST [1,null,2,2],\n> + return [2].\n>\n> Note: If a tree has more than one mode, you can return them in any order.\n>\n> Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).\n\n<!--more-->\n\nThis is Leetcode 501. And it is a easy one. You can just use pre-order visit the tree and store the value and its appearances. Return the max times.\n\nSo, here comes the answer:\n\n```\nclass Solution {\n    public:\n        map<int, int> nodes;\n\n        vector<int> findMode(TreeNode* root) {\n            nodes.clear();\n\n            _preOrder(root);\n\n            int times = INT_MIN;\n            for (auto i : nodes) {\n                if (i.second > times) {\n                    times = i.second;\n                }\n            }\n\n            vector<int> res;\n            for (auto i : nodes) {\n                if (i.second == times) {\n                    res.push_back(i.first);\n                }\n            }\n\n            return res;\n        }\n\n        void _preOrder(TreeNode* node) {\n            if (node == NULL) {\n                return;\n            }\n            _visit(node);\n            _preOrder(node->left);\n            _preOrder(node->right);\n        }\n\n        void _visit(TreeNode* node) {\n            if (nodes.find(node->val) == nodes.end()) {\n                nodes.insert(pair<int, int>(node->val, 1));\n            } else {\n                nodes.find(node->val)->second++;\n            }\n        }\n};\n```\n\n**Follow up:**\n\nIt's easy to improve the code. Because we can use the BST feature, we can know the current node's value how many times.\n\nNot now for the result.\n\n\n","source":"_posts/FindModeinBinarySearchTree.md","raw":"---\ntitle: Find Mode in Binary Search Tree\ndate: 2017-02-01 23:59:43\ntags:\n    - Tree\n---\n\n> Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.\n>\n> Assume a BST is defined as follows:\n>\n> + The left subtree of a node contains only nodes with keys less than or equal to the node's key.\n> + The right subtree of a node contains only nodes with keys greater than or equal to the node's key.\n> + Both the left and right subtrees must also be binary search trees.\n>\n> For example:\n> + Given BST [1,null,2,2],\n> + return [2].\n>\n> Note: If a tree has more than one mode, you can return them in any order.\n>\n> Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).\n\n<!--more-->\n\nThis is Leetcode 501. And it is a easy one. You can just use pre-order visit the tree and store the value and its appearances. Return the max times.\n\nSo, here comes the answer:\n\n```\nclass Solution {\n    public:\n        map<int, int> nodes;\n\n        vector<int> findMode(TreeNode* root) {\n            nodes.clear();\n\n            _preOrder(root);\n\n            int times = INT_MIN;\n            for (auto i : nodes) {\n                if (i.second > times) {\n                    times = i.second;\n                }\n            }\n\n            vector<int> res;\n            for (auto i : nodes) {\n                if (i.second == times) {\n                    res.push_back(i.first);\n                }\n            }\n\n            return res;\n        }\n\n        void _preOrder(TreeNode* node) {\n            if (node == NULL) {\n                return;\n            }\n            _visit(node);\n            _preOrder(node->left);\n            _preOrder(node->right);\n        }\n\n        void _visit(TreeNode* node) {\n            if (nodes.find(node->val) == nodes.end()) {\n                nodes.insert(pair<int, int>(node->val, 1));\n            } else {\n                nodes.find(node->val)->second++;\n            }\n        }\n};\n```\n\n**Follow up:**\n\nIt's easy to improve the code. Because we can use the BST feature, we can know the current node's value how many times.\n\nNot now for the result.\n\n\n","slug":"FindModeinBinarySearchTree","published":1,"updated":"2017-02-01T16:15:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5q30009pff4p1lmmb6r","content":"<blockquote>\n<p>Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.</p>\n<p>Assume a BST is defined as follows:</p>\n<ul>\n<li>The left subtree of a node contains only nodes with keys less than or equal to the node’s key.</li>\n<li>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</li>\n<li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n<p>For example:</p>\n<ul>\n<li>Given BST [1,null,2,2],</li>\n<li>return [2].</li>\n</ul>\n<p>Note: If a tree has more than one mode, you can return them in any order.</p>\n<p>Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 501. And it is a easy one. You can just use pre-order visit the tree and store the value and its appearances. Return the max times.</p>\n<p>So, here comes the answer:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        map&lt;int, int&gt; nodes;</div><div class=\"line\"></div><div class=\"line\">        vector&lt;int&gt; findMode(TreeNode* root) &#123;</div><div class=\"line\">            nodes.clear();</div><div class=\"line\"></div><div class=\"line\">            _preOrder(root);</div><div class=\"line\"></div><div class=\"line\">            int times = INT_MIN;</div><div class=\"line\">            for (auto i : nodes) &#123;</div><div class=\"line\">                if (i.second &gt; times) &#123;</div><div class=\"line\">                    times = i.second;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\">            for (auto i : nodes) &#123;</div><div class=\"line\">                if (i.second == times) &#123;</div><div class=\"line\">                    res.push_back(i.first);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _preOrder(TreeNode* node) &#123;</div><div class=\"line\">            if (node == NULL) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            _visit(node);</div><div class=\"line\">            _preOrder(node-&gt;left);</div><div class=\"line\">            _preOrder(node-&gt;right);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _visit(TreeNode* node) &#123;</div><div class=\"line\">            if (nodes.find(node-&gt;val) == nodes.end()) &#123;</div><div class=\"line\">                nodes.insert(pair&lt;int, int&gt;(node-&gt;val, 1));</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                nodes.find(node-&gt;val)-&gt;second++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><strong>Follow up:</strong></p>\n<p>It’s easy to improve the code. Because we can use the BST feature, we can know the current node’s value how many times.</p>\n<p>Not now for the result.</p>\n","excerpt":"<blockquote>\n<p>Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.</p>\n<p>Assume a BST is defined as follows:</p>\n<ul>\n<li>The left subtree of a node contains only nodes with keys less than or equal to the node’s key.</li>\n<li>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</li>\n<li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n<p>For example:</p>\n<ul>\n<li>Given BST [1,null,2,2],</li>\n<li>return [2].</li>\n</ul>\n<p>Note: If a tree has more than one mode, you can return them in any order.</p>\n<p>Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).</p>\n</blockquote>","more":"<p>This is Leetcode 501. And it is a easy one. You can just use pre-order visit the tree and store the value and its appearances. Return the max times.</p>\n<p>So, here comes the answer:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        map&lt;int, int&gt; nodes;</div><div class=\"line\"></div><div class=\"line\">        vector&lt;int&gt; findMode(TreeNode* root) &#123;</div><div class=\"line\">            nodes.clear();</div><div class=\"line\"></div><div class=\"line\">            _preOrder(root);</div><div class=\"line\"></div><div class=\"line\">            int times = INT_MIN;</div><div class=\"line\">            for (auto i : nodes) &#123;</div><div class=\"line\">                if (i.second &gt; times) &#123;</div><div class=\"line\">                    times = i.second;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\">            for (auto i : nodes) &#123;</div><div class=\"line\">                if (i.second == times) &#123;</div><div class=\"line\">                    res.push_back(i.first);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _preOrder(TreeNode* node) &#123;</div><div class=\"line\">            if (node == NULL) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            _visit(node);</div><div class=\"line\">            _preOrder(node-&gt;left);</div><div class=\"line\">            _preOrder(node-&gt;right);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _visit(TreeNode* node) &#123;</div><div class=\"line\">            if (nodes.find(node-&gt;val) == nodes.end()) &#123;</div><div class=\"line\">                nodes.insert(pair&lt;int, int&gt;(node-&gt;val, 1));</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                nodes.find(node-&gt;val)-&gt;second++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><strong>Follow up:</strong></p>\n<p>It’s easy to improve the code. Because we can use the BST feature, we can know the current node’s value how many times.</p>\n<p>Not now for the result.</p>"},{"title":"Find the Duplicate Number","date":"2017-02-08T01:35:17.000Z","_content":"\n> Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.\n>\n> Note:\n>  + You must not modify the array (assume the array is read only).\n>  + You must use only constant, O(1) extra space.\n>  + Your runtime complexity should be less than O(n2).\n>  + There is only one duplicate number in the array, but it could be repeated more than once.\n\n<!--more-->\n\nThis is Leetcode 287, and it is easy if you can modify this array. Sort and find, O(NlogN) time complexity.\n\nIf you can use O(N) space, you can use a array to store all the num and check whether it is appeared once.\n\nHowever, you can not modify, so you need to find another solution.\n\nI don't know if I use bitset is ok? If it is good, I can finish this with O(1) space and O(n) time.\n\nAnd if I can use the O(n2) time complexity, I can use the two loops solution.\n\nIf the duplicate number can only be repeated once. U can make this problem into a Math problem.\n\nSo, I come up with such a solution:\n\n```\nclass Solution {\n    public:\n        int findDuplicate(vector<int>& nums) {\n            if (nums.size() <= 1) {\n                return -1;\n            }\n\n            int n = nums.size();\n            int slow = n;\n            int fast = n;\n            do {\n                slow = nums[slow - 1];\n                fast = nums[nums[fast - 1] - 1];\n            } while (slow != fast);\n            slow = n;\n            while (slow != fast) {\n                slow = nums[slow - 1];\n                fast = nums[fast - 1];\n            }\n            return slow;\n        }\n};\n```\n\nFor the explaination:\n\nsuppose the array is\n\n + index: 0 1 2 3 4 5\n + value: 2 5 1 1 4 3\n\nfirst subtract 1 from each element in the array, so it is much easy to understand.\nuse the value as pointer. the array becomes:\n \n + index: 0 1 2 3 4 5\n + value: 1 4 0 0 3 2\n\nenter image description here\n\n![description](http://cyukang.com/images/cycle3.png)\n\nSecond if the array is\n\n + index: 0 1 2 3 4 5\n + value: 0 1 2 4 2 3\n\nwe must choose the last element as the head of the linked list. If we choose 0, we can not detect the cycle.\n\nNow the problem is the same as find the cycle in linkedlist!\n","source":"_posts/FindtheDuplicateNumber.md","raw":"---\ntitle: Find the Duplicate Number\ndate: 2017-02-08 09:35:17\ntags:\n    - Binary Search\n    - Array\n    - Two Pointers\n---\n\n> Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.\n>\n> Note:\n>  + You must not modify the array (assume the array is read only).\n>  + You must use only constant, O(1) extra space.\n>  + Your runtime complexity should be less than O(n2).\n>  + There is only one duplicate number in the array, but it could be repeated more than once.\n\n<!--more-->\n\nThis is Leetcode 287, and it is easy if you can modify this array. Sort and find, O(NlogN) time complexity.\n\nIf you can use O(N) space, you can use a array to store all the num and check whether it is appeared once.\n\nHowever, you can not modify, so you need to find another solution.\n\nI don't know if I use bitset is ok? If it is good, I can finish this with O(1) space and O(n) time.\n\nAnd if I can use the O(n2) time complexity, I can use the two loops solution.\n\nIf the duplicate number can only be repeated once. U can make this problem into a Math problem.\n\nSo, I come up with such a solution:\n\n```\nclass Solution {\n    public:\n        int findDuplicate(vector<int>& nums) {\n            if (nums.size() <= 1) {\n                return -1;\n            }\n\n            int n = nums.size();\n            int slow = n;\n            int fast = n;\n            do {\n                slow = nums[slow - 1];\n                fast = nums[nums[fast - 1] - 1];\n            } while (slow != fast);\n            slow = n;\n            while (slow != fast) {\n                slow = nums[slow - 1];\n                fast = nums[fast - 1];\n            }\n            return slow;\n        }\n};\n```\n\nFor the explaination:\n\nsuppose the array is\n\n + index: 0 1 2 3 4 5\n + value: 2 5 1 1 4 3\n\nfirst subtract 1 from each element in the array, so it is much easy to understand.\nuse the value as pointer. the array becomes:\n \n + index: 0 1 2 3 4 5\n + value: 1 4 0 0 3 2\n\nenter image description here\n\n![description](http://cyukang.com/images/cycle3.png)\n\nSecond if the array is\n\n + index: 0 1 2 3 4 5\n + value: 0 1 2 4 2 3\n\nwe must choose the last element as the head of the linked list. If we choose 0, we can not detect the cycle.\n\nNow the problem is the same as find the cycle in linkedlist!\n","slug":"FindtheDuplicateNumber","published":1,"updated":"2017-02-08T04:50:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5q9000bpff44sdu2eew","content":"<blockquote>\n<p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>\n<p>Note:</p>\n<ul>\n<li>You must not modify the array (assume the array is read only).</li>\n<li>You must use only constant, O(1) extra space.</li>\n<li>Your runtime complexity should be less than O(n2).</li>\n<li>There is only one duplicate number in the array, but it could be repeated more than once.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 287, and it is easy if you can modify this array. Sort and find, O(NlogN) time complexity.</p>\n<p>If you can use O(N) space, you can use a array to store all the num and check whether it is appeared once.</p>\n<p>However, you can not modify, so you need to find another solution.</p>\n<p>I don’t know if I use bitset is ok? If it is good, I can finish this with O(1) space and O(n) time.</p>\n<p>And if I can use the O(n2) time complexity, I can use the two loops solution.</p>\n<p>If the duplicate number can only be repeated once. U can make this problem into a Math problem.</p>\n<p>So, I come up with such a solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() &lt;= 1) &#123;</div><div class=\"line\">                return -1;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int n = nums.size();</div><div class=\"line\">            int slow = n;</div><div class=\"line\">            int fast = n;</div><div class=\"line\">            do &#123;</div><div class=\"line\">                slow = nums[slow - 1];</div><div class=\"line\">                fast = nums[nums[fast - 1] - 1];</div><div class=\"line\">            &#125; while (slow != fast);</div><div class=\"line\">            slow = n;</div><div class=\"line\">            while (slow != fast) &#123;</div><div class=\"line\">                slow = nums[slow - 1];</div><div class=\"line\">                fast = nums[fast - 1];</div><div class=\"line\">            &#125;</div><div class=\"line\">            return slow;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>For the explaination:</p>\n<p>suppose the array is</p>\n<ul>\n<li>index: 0 1 2 3 4 5</li>\n<li>value: 2 5 1 1 4 3</li>\n</ul>\n<p>first subtract 1 from each element in the array, so it is much easy to understand.<br>use the value as pointer. the array becomes:</p>\n<ul>\n<li>index: 0 1 2 3 4 5</li>\n<li>value: 1 4 0 0 3 2</li>\n</ul>\n<p>enter image description here</p>\n<p><img src=\"http://cyukang.com/images/cycle3.png\" alt=\"description\"></p>\n<p>Second if the array is</p>\n<ul>\n<li>index: 0 1 2 3 4 5</li>\n<li>value: 0 1 2 4 2 3</li>\n</ul>\n<p>we must choose the last element as the head of the linked list. If we choose 0, we can not detect the cycle.</p>\n<p>Now the problem is the same as find the cycle in linkedlist!</p>\n","excerpt":"<blockquote>\n<p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>\n<p>Note:</p>\n<ul>\n<li>You must not modify the array (assume the array is read only).</li>\n<li>You must use only constant, O(1) extra space.</li>\n<li>Your runtime complexity should be less than O(n2).</li>\n<li>There is only one duplicate number in the array, but it could be repeated more than once.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 287, and it is easy if you can modify this array. Sort and find, O(NlogN) time complexity.</p>\n<p>If you can use O(N) space, you can use a array to store all the num and check whether it is appeared once.</p>\n<p>However, you can not modify, so you need to find another solution.</p>\n<p>I don’t know if I use bitset is ok? If it is good, I can finish this with O(1) space and O(n) time.</p>\n<p>And if I can use the O(n2) time complexity, I can use the two loops solution.</p>\n<p>If the duplicate number can only be repeated once. U can make this problem into a Math problem.</p>\n<p>So, I come up with such a solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() &lt;= 1) &#123;</div><div class=\"line\">                return -1;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int n = nums.size();</div><div class=\"line\">            int slow = n;</div><div class=\"line\">            int fast = n;</div><div class=\"line\">            do &#123;</div><div class=\"line\">                slow = nums[slow - 1];</div><div class=\"line\">                fast = nums[nums[fast - 1] - 1];</div><div class=\"line\">            &#125; while (slow != fast);</div><div class=\"line\">            slow = n;</div><div class=\"line\">            while (slow != fast) &#123;</div><div class=\"line\">                slow = nums[slow - 1];</div><div class=\"line\">                fast = nums[fast - 1];</div><div class=\"line\">            &#125;</div><div class=\"line\">            return slow;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>For the explaination:</p>\n<p>suppose the array is</p>\n<ul>\n<li>index: 0 1 2 3 4 5</li>\n<li>value: 2 5 1 1 4 3</li>\n</ul>\n<p>first subtract 1 from each element in the array, so it is much easy to understand.<br>use the value as pointer. the array becomes:</p>\n<ul>\n<li>index: 0 1 2 3 4 5</li>\n<li>value: 1 4 0 0 3 2</li>\n</ul>\n<p>enter image description here</p>\n<p><img src=\"http://cyukang.com/images/cycle3.png\" alt=\"description\"></p>\n<p>Second if the array is</p>\n<ul>\n<li>index: 0 1 2 3 4 5</li>\n<li>value: 0 1 2 4 2 3</li>\n</ul>\n<p>we must choose the last element as the head of the linked list. If we choose 0, we can not detect the cycle.</p>\n<p>Now the problem is the same as find the cycle in linkedlist!</p>"},{"title":"Group Anagrams","date":"2017-01-10T06:07:57.000Z","_content":"\n> Given an array of strings, group anagrams together.\n>\n> For example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],\n> Return:\n>\n>       [\n>           [\"ate\", \"eat\",\"tea\"],\n>           [\"nat\",\"tan\"],\n>           [\"bat\"]\n>       ]\n>\n> Note: All inputs will be in lower-case.\n\n<!--more-->\n\nThis is Leetcode 49, what a easy problem. We can quickly figure out two method:\n\nThe first one is:\n> 1. choose one string as the standard one.\n> 2. for each to check if this one has the same chars as the standard.\n> 3. if same, than, mark it has been used, and store it to the result.\n\nThe time complex of this method is O(n^2*m), m is dependent on the length of the string. It's is not a fast method, but it uses the least memory.\n\nThe second one is to use the map or hash map to help.\n> 1. for each to count its structure. for example, tae can be descriped as '1a0b0c0d1e0f0g0h0i0j0k0l0m0n0o0p0q0r0s1t0u0v0w0x0y0z'\n> 2. then make the key to the map and check each word which has the same structure.\n\nThe time copolex of this method is O(n*m).\n\nSo, I use the second one to write the result code as following:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        vector<vector<string> > groupAnagrams(vector<string>& strs) {\n            vector<string> keys;\n            map<string, vector<string> > retMap;\n            for (int i = 0; i < (int)strs.size(); i++) {\n                int chars[26] = {0};\n                for (int j = 0; j < (int)strs[i].length(); j++) {\n                    chars[strs[i][j] - 'a']++;\n                }\n                string currentKey = \"\";\n                for (int j = 0; j < 26; j++) {\n                    currentKey = currentKey + (char)('0' + chars[j]);\n                    currentKey = currentKey + (char)('a' + j);\n                }\n\n                if (retMap.find(currentKey) != retMap.end()) {\n                    retMap[currentKey].push_back(strs[i]);\n                } else {\n                    vector<string> currentValue;\n                    currentValue.push_back(strs[i]);\n                    retMap.insert(pair<string, vector<string> >(currentKey, currentValue));\n                }\n            }\n\n            vector<vector<string> > res;\n            for (pair<string, vector<string> > values: retMap) {\n                res.push_back(values.second);\n            }\n            return res;\n        }\n};\n```\n\nAnd it gets AC.\n","source":"_posts/GroupAnagrams.md","raw":"---\ntitle: Group Anagrams\ndate: 2017-01-10 14:07:57\ntags:\n    - Hash Table\n    - String\n---\n\n> Given an array of strings, group anagrams together.\n>\n> For example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],\n> Return:\n>\n>       [\n>           [\"ate\", \"eat\",\"tea\"],\n>           [\"nat\",\"tan\"],\n>           [\"bat\"]\n>       ]\n>\n> Note: All inputs will be in lower-case.\n\n<!--more-->\n\nThis is Leetcode 49, what a easy problem. We can quickly figure out two method:\n\nThe first one is:\n> 1. choose one string as the standard one.\n> 2. for each to check if this one has the same chars as the standard.\n> 3. if same, than, mark it has been used, and store it to the result.\n\nThe time complex of this method is O(n^2*m), m is dependent on the length of the string. It's is not a fast method, but it uses the least memory.\n\nThe second one is to use the map or hash map to help.\n> 1. for each to count its structure. for example, tae can be descriped as '1a0b0c0d1e0f0g0h0i0j0k0l0m0n0o0p0q0r0s1t0u0v0w0x0y0z'\n> 2. then make the key to the map and check each word which has the same structure.\n\nThe time copolex of this method is O(n*m).\n\nSo, I use the second one to write the result code as following:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        vector<vector<string> > groupAnagrams(vector<string>& strs) {\n            vector<string> keys;\n            map<string, vector<string> > retMap;\n            for (int i = 0; i < (int)strs.size(); i++) {\n                int chars[26] = {0};\n                for (int j = 0; j < (int)strs[i].length(); j++) {\n                    chars[strs[i][j] - 'a']++;\n                }\n                string currentKey = \"\";\n                for (int j = 0; j < 26; j++) {\n                    currentKey = currentKey + (char)('0' + chars[j]);\n                    currentKey = currentKey + (char)('a' + j);\n                }\n\n                if (retMap.find(currentKey) != retMap.end()) {\n                    retMap[currentKey].push_back(strs[i]);\n                } else {\n                    vector<string> currentValue;\n                    currentValue.push_back(strs[i]);\n                    retMap.insert(pair<string, vector<string> >(currentKey, currentValue));\n                }\n            }\n\n            vector<vector<string> > res;\n            for (pair<string, vector<string> > values: retMap) {\n                res.push_back(values.second);\n            }\n            return res;\n        }\n};\n```\n\nAnd it gets AC.\n","slug":"GroupAnagrams","published":1,"updated":"2017-01-13T03:11:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5qa000dpff4naulfqgm","content":"<blockquote>\n<p>Given an array of strings, group anagrams together.</p>\n<p>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>Return:</p>\n<pre><code>[\n    [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;],\n    [&quot;nat&quot;,&quot;tan&quot;],\n    [&quot;bat&quot;]\n]\n</code></pre><p>Note: All inputs will be in lower-case.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 49, what a easy problem. We can quickly figure out two method:</p>\n<p>The first one is:</p>\n<blockquote>\n<ol>\n<li>choose one string as the standard one.</li>\n<li>for each to check if this one has the same chars as the standard.</li>\n<li>if same, than, mark it has been used, and store it to the result.</li>\n</ol>\n</blockquote>\n<p>The time complex of this method is O(n^2*m), m is dependent on the length of the string. It’s is not a fast method, but it uses the least memory.</p>\n<p>The second one is to use the map or hash map to help.</p>\n<blockquote>\n<ol>\n<li>for each to count its structure. for example, tae can be descriped as ‘1a0b0c0d1e0f0g0h0i0j0k0l0m0n0o0p0q0r0s1t0u0v0w0x0y0z’</li>\n<li>then make the key to the map and check each word which has the same structure.</li>\n</ol>\n</blockquote>\n<p>The time copolex of this method is O(n*m).</p>\n<p>So, I use the second one to write the result code as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;vector&lt;string&gt; &gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</div><div class=\"line\">            vector&lt;string&gt; keys;</div><div class=\"line\">            map&lt;string, vector&lt;string&gt; &gt; retMap;</div><div class=\"line\">            for (int i = 0; i &lt; (int)strs.size(); i++) &#123;</div><div class=\"line\">                int chars[26] = &#123;0&#125;;</div><div class=\"line\">                for (int j = 0; j &lt; (int)strs[i].length(); j++) &#123;</div><div class=\"line\">                    chars[strs[i][j] - &apos;a&apos;]++;</div><div class=\"line\">                &#125;</div><div class=\"line\">                string currentKey = &quot;&quot;;</div><div class=\"line\">                for (int j = 0; j &lt; 26; j++) &#123;</div><div class=\"line\">                    currentKey = currentKey + (char)(&apos;0&apos; + chars[j]);</div><div class=\"line\">                    currentKey = currentKey + (char)(&apos;a&apos; + j);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                if (retMap.find(currentKey) != retMap.end()) &#123;</div><div class=\"line\">                    retMap[currentKey].push_back(strs[i]);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    vector&lt;string&gt; currentValue;</div><div class=\"line\">                    currentValue.push_back(strs[i]);</div><div class=\"line\">                    retMap.insert(pair&lt;string, vector&lt;string&gt; &gt;(currentKey, currentValue));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;vector&lt;string&gt; &gt; res;</div><div class=\"line\">            for (pair&lt;string, vector&lt;string&gt; &gt; values: retMap) &#123;</div><div class=\"line\">                res.push_back(values.second);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given an array of strings, group anagrams together.</p>\n<p>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>Return:</p>\n<pre><code>[\n    [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;],\n    [&quot;nat&quot;,&quot;tan&quot;],\n    [&quot;bat&quot;]\n]\n</code></pre><p>Note: All inputs will be in lower-case.</p>\n</blockquote>","more":"<p>This is Leetcode 49, what a easy problem. We can quickly figure out two method:</p>\n<p>The first one is:</p>\n<blockquote>\n<ol>\n<li>choose one string as the standard one.</li>\n<li>for each to check if this one has the same chars as the standard.</li>\n<li>if same, than, mark it has been used, and store it to the result.</li>\n</ol>\n</blockquote>\n<p>The time complex of this method is O(n^2*m), m is dependent on the length of the string. It’s is not a fast method, but it uses the least memory.</p>\n<p>The second one is to use the map or hash map to help.</p>\n<blockquote>\n<ol>\n<li>for each to count its structure. for example, tae can be descriped as ‘1a0b0c0d1e0f0g0h0i0j0k0l0m0n0o0p0q0r0s1t0u0v0w0x0y0z’</li>\n<li>then make the key to the map and check each word which has the same structure.</li>\n</ol>\n</blockquote>\n<p>The time copolex of this method is O(n*m).</p>\n<p>So, I use the second one to write the result code as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;vector&lt;string&gt; &gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</div><div class=\"line\">            vector&lt;string&gt; keys;</div><div class=\"line\">            map&lt;string, vector&lt;string&gt; &gt; retMap;</div><div class=\"line\">            for (int i = 0; i &lt; (int)strs.size(); i++) &#123;</div><div class=\"line\">                int chars[26] = &#123;0&#125;;</div><div class=\"line\">                for (int j = 0; j &lt; (int)strs[i].length(); j++) &#123;</div><div class=\"line\">                    chars[strs[i][j] - &apos;a&apos;]++;</div><div class=\"line\">                &#125;</div><div class=\"line\">                string currentKey = &quot;&quot;;</div><div class=\"line\">                for (int j = 0; j &lt; 26; j++) &#123;</div><div class=\"line\">                    currentKey = currentKey + (char)(&apos;0&apos; + chars[j]);</div><div class=\"line\">                    currentKey = currentKey + (char)(&apos;a&apos; + j);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                if (retMap.find(currentKey) != retMap.end()) &#123;</div><div class=\"line\">                    retMap[currentKey].push_back(strs[i]);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    vector&lt;string&gt; currentValue;</div><div class=\"line\">                    currentValue.push_back(strs[i]);</div><div class=\"line\">                    retMap.insert(pair&lt;string, vector&lt;string&gt; &gt;(currentKey, currentValue));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;vector&lt;string&gt; &gt; res;</div><div class=\"line\">            for (pair&lt;string, vector&lt;string&gt; &gt; values: retMap) &#123;</div><div class=\"line\">                res.push_back(values.second);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>"},{"title":"House Robber III","date":"2017-01-21T12:45:21.000Z","_content":"\n> The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the \"root.\" Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that \"all houses in this place forms a binary tree\". It will automatically contact the police if two directly-linked houses were broken into on the same night.\n>\n> Determine the maximum amount of money the thief can rob tonight without alerting the police.\n>\n> Example 1:\n>\n>      3\n>      / \\\n>     2   3\n>      \\   \\ \n>       3   1\n>\n> Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n>\n> Example 2:\n>\n>        3\n>        / \\\n>       4   5\n>      / \\   \\ \n>     1   3   1\n>\n> Maximum amount of money the thief can rob = 4 + 5 = 9.\n\n<!--more-->\n\nThis is Leetcode 337, I think this is a kind of DP problem or recursive solution problem. I get the recursive relationship.\n\nTo some Node, I can tell it's max value when it's robbed or not robbed:\n\n```\nif (isRobCurrent) {\n    return current->val + _rob(current->left, false) + _rob(current->right, false);\n} else {\n    return max(\n            max(_rob(current->left, false) + _rob(current->right, false),\n                _rob(current->left, false) + _rob(current->right, true)),\n            max(_rob(current->left, true) + _rob(current->right, false),\n                _rob(current->left, true) + _rob(current->right, true))\n            );\n}\n```\n\nObviously, it gets a TLE. So, I think about using a hashmap to store the value of the node's value. Because I find see some node has been counted for more than one time.\n\nSo, here is the better solution:\n\n```\nclass Solution {\n    public:\n        int rob(TreeNode* root) {\n            vector<int> res = robSub(root);\n            return max(res[0], res[1]);\n        }\n\n        vector<int> robSub(TreeNode* root) {\n            if (root == NULL) {\n                return vector<int>(2,0);\n            }\n\n            vector<int> left = robSub(root->left);\n            vector<int> right = robSub(root->right);\n\n            vector<int> res(2,0);\n            res[0] = max(left[0], left[1]) + max(right[0], right[1]);\n            res[1] = root->val + left[0] + right[0];\n\n            return res;\n        }\n};\n```\n\nAnd it's get AC.\n","source":"_posts/HouseRobberIII.md","raw":"---\ntitle: House Robber III\ndate: 2017-01-21 20:45:21\ntags:\n    - Depth-first Search\n    - Tree\n---\n\n> The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the \"root.\" Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that \"all houses in this place forms a binary tree\". It will automatically contact the police if two directly-linked houses were broken into on the same night.\n>\n> Determine the maximum amount of money the thief can rob tonight without alerting the police.\n>\n> Example 1:\n>\n>      3\n>      / \\\n>     2   3\n>      \\   \\ \n>       3   1\n>\n> Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n>\n> Example 2:\n>\n>        3\n>        / \\\n>       4   5\n>      / \\   \\ \n>     1   3   1\n>\n> Maximum amount of money the thief can rob = 4 + 5 = 9.\n\n<!--more-->\n\nThis is Leetcode 337, I think this is a kind of DP problem or recursive solution problem. I get the recursive relationship.\n\nTo some Node, I can tell it's max value when it's robbed or not robbed:\n\n```\nif (isRobCurrent) {\n    return current->val + _rob(current->left, false) + _rob(current->right, false);\n} else {\n    return max(\n            max(_rob(current->left, false) + _rob(current->right, false),\n                _rob(current->left, false) + _rob(current->right, true)),\n            max(_rob(current->left, true) + _rob(current->right, false),\n                _rob(current->left, true) + _rob(current->right, true))\n            );\n}\n```\n\nObviously, it gets a TLE. So, I think about using a hashmap to store the value of the node's value. Because I find see some node has been counted for more than one time.\n\nSo, here is the better solution:\n\n```\nclass Solution {\n    public:\n        int rob(TreeNode* root) {\n            vector<int> res = robSub(root);\n            return max(res[0], res[1]);\n        }\n\n        vector<int> robSub(TreeNode* root) {\n            if (root == NULL) {\n                return vector<int>(2,0);\n            }\n\n            vector<int> left = robSub(root->left);\n            vector<int> right = robSub(root->right);\n\n            vector<int> res(2,0);\n            res[0] = max(left[0], left[1]) + max(right[0], right[1]);\n            res[1] = root->val + left[0] + right[0];\n\n            return res;\n        }\n};\n```\n\nAnd it's get AC.\n","slug":"HouseRobberIII","published":1,"updated":"2017-01-21T14:30:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5qc000fpff4mz3wx6i5","content":"<blockquote>\n<p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>\n<p>Determine the maximum amount of money the thief can rob tonight without alerting the police.</p>\n<p>Example 1:</p>\n<pre><code> 3\n / \\\n2   3\n \\   \\ \n  3   1\n</code></pre><p>Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.</p>\n<p>Example 2:</p>\n<pre><code>   3\n   / \\\n  4   5\n / \\   \\ \n1   3   1\n</code></pre><p>Maximum amount of money the thief can rob = 4 + 5 = 9.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 337, I think this is a kind of DP problem or recursive solution problem. I get the recursive relationship.</p>\n<p>To some Node, I can tell it’s max value when it’s robbed or not robbed:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (isRobCurrent) &#123;</div><div class=\"line\">    return current-&gt;val + _rob(current-&gt;left, false) + _rob(current-&gt;right, false);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    return max(</div><div class=\"line\">            max(_rob(current-&gt;left, false) + _rob(current-&gt;right, false),</div><div class=\"line\">                _rob(current-&gt;left, false) + _rob(current-&gt;right, true)),</div><div class=\"line\">            max(_rob(current-&gt;left, true) + _rob(current-&gt;right, false),</div><div class=\"line\">                _rob(current-&gt;left, true) + _rob(current-&gt;right, true))</div><div class=\"line\">            );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Obviously, it gets a TLE. So, I think about using a hashmap to store the value of the node’s value. Because I find see some node has been counted for more than one time.</p>\n<p>So, here is the better solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int rob(TreeNode* root) &#123;</div><div class=\"line\">            vector&lt;int&gt; res = robSub(root);</div><div class=\"line\">            return max(res[0], res[1]);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        vector&lt;int&gt; robSub(TreeNode* root) &#123;</div><div class=\"line\">            if (root == NULL) &#123;</div><div class=\"line\">                return vector&lt;int&gt;(2,0);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;int&gt; left = robSub(root-&gt;left);</div><div class=\"line\">            vector&lt;int&gt; right = robSub(root-&gt;right);</div><div class=\"line\"></div><div class=\"line\">            vector&lt;int&gt; res(2,0);</div><div class=\"line\">            res[0] = max(left[0], left[1]) + max(right[0], right[1]);</div><div class=\"line\">            res[1] = root-&gt;val + left[0] + right[0];</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it’s get AC.</p>\n","excerpt":"<blockquote>\n<p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>\n<p>Determine the maximum amount of money the thief can rob tonight without alerting the police.</p>\n<p>Example 1:</p>\n<pre><code> 3\n / \\\n2   3\n \\   \\ \n  3   1\n</code></pre><p>Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.</p>\n<p>Example 2:</p>\n<pre><code>   3\n   / \\\n  4   5\n / \\   \\ \n1   3   1\n</code></pre><p>Maximum amount of money the thief can rob = 4 + 5 = 9.</p>\n</blockquote>","more":"<p>This is Leetcode 337, I think this is a kind of DP problem or recursive solution problem. I get the recursive relationship.</p>\n<p>To some Node, I can tell it’s max value when it’s robbed or not robbed:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (isRobCurrent) &#123;</div><div class=\"line\">    return current-&gt;val + _rob(current-&gt;left, false) + _rob(current-&gt;right, false);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    return max(</div><div class=\"line\">            max(_rob(current-&gt;left, false) + _rob(current-&gt;right, false),</div><div class=\"line\">                _rob(current-&gt;left, false) + _rob(current-&gt;right, true)),</div><div class=\"line\">            max(_rob(current-&gt;left, true) + _rob(current-&gt;right, false),</div><div class=\"line\">                _rob(current-&gt;left, true) + _rob(current-&gt;right, true))</div><div class=\"line\">            );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Obviously, it gets a TLE. So, I think about using a hashmap to store the value of the node’s value. Because I find see some node has been counted for more than one time.</p>\n<p>So, here is the better solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int rob(TreeNode* root) &#123;</div><div class=\"line\">            vector&lt;int&gt; res = robSub(root);</div><div class=\"line\">            return max(res[0], res[1]);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        vector&lt;int&gt; robSub(TreeNode* root) &#123;</div><div class=\"line\">            if (root == NULL) &#123;</div><div class=\"line\">                return vector&lt;int&gt;(2,0);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;int&gt; left = robSub(root-&gt;left);</div><div class=\"line\">            vector&lt;int&gt; right = robSub(root-&gt;right);</div><div class=\"line\"></div><div class=\"line\">            vector&lt;int&gt; res(2,0);</div><div class=\"line\">            res[0] = max(left[0], left[1]) + max(right[0], right[1]);</div><div class=\"line\">            res[1] = root-&gt;val + left[0] + right[0];</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it’s get AC.</p>"},{"title":"Heaters","date":"2017-01-04T05:46:25.000Z","_content":"\n> Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.\n>\n> So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.\n>\n> Note:\n>\n> + Numbers of houses and heaters you are given are non-negative and will not exceed 25000.\n> + Positions of houses and heaters you are given are non-negative and will not exceed 10^9.\n> + As long as a house is in the heaters' warm radius range, it can be warmed.\n> + All the heaters follow your radius standard and the warm radius will the same.\n>\n> Example 1:\n>\n> Input: [1,2,3],[2]\n> Output: 1\n> Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.\n>\n> Example 2:\n>\n> Input: [1,2,3,4],[1,4]\n> Output: 1\n> Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.\n\n<!-- more -->\n\nThis is Leetcode 475. As it's descripted, we can quickly find a solution. Picture this:\n\n\n```\n          h1   h2        h3\n           |    |         |\n......................................\n```\n\nIf we find the min value of the radius between every two heaters, and find the max one, which will be the result.\n\nAnd it's time complex is O(n*m), n is the num of the houses and m is the num of heaters.\n\n```\nusing namespace std;\n\nclass Solution {\npublic:\n    int idx;\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\n        sort(houses.begin(), houses.end());\n        sort(heaters.begin(), heaters.end());\n\n        int res = INT_MIN;\n        idx = 0;\n        for (int i = 0; i < (int)heaters.size(); i++) {\n            if (i == 0) {\n                res = max(res, findMinRadius(houses, -1, heaters[i]));\n            } else if (i == (int)heaters.size()) {\n                res = max(res, findMinRadius(houses, heaters[i - 1], -1));\n            } else {\n                res = max(res, findMinRadius(houses, heaters[i - 1], heaters[i]));\n            }\n            std::cout << res << std::endl;\n        }\n        return res;\n    }\n\n    int findMinRadius(vector<int> houses, int heater1, int heater2) {\n        if (heater1 == -1) { // means the first one\n            while (houses[idx] <= heater2) { idx++; }\n            return heater2 - houses[0];\n        } else if (heater2 == -1) { // means the last one\n            while (idx < (int)houses.size()) { idx++; }\n            return houses[idx - 1] - heater1;\n        } else {\n            int minRadius = INT_MAX;\n            for (int i = idx; houses[i] < heater2; i++) {\n                // minRadius = min(max(houses[i] - heater1, heater2 - houses[i]), minRadius);\n                // if there are (2n-1) houses, we need to use the mid one\n                // if there are (2n) houses, we should use the the mid two\n                // here is hard to decide which to use as the standard\n            }\n            return minRadius;\n        }\n    }\n};\n```\n\nHowever, there is a better way to figure this problem out. The idea is to leverage decent binarySearch function.\n\n+ For each house, find its position between those heaters (thus we need the heaters array to be sorted).\n+ Calculate the distances between this house and left heater and right heater, get a MIN value of those two values. Corner cases are there is no left or right heater.\n+ Get MAX value among distances in step 2. It's the answer.\n\nSo, here comes the solution:\n\n```\nclass Solution {\n    public:\n        int findRadius(vector<int>& houses, vector<int>& heaters) {\n            int house_size = houses.size();\n            if (house_size == 0) return 0;\n            sort(heaters.begin(), heaters.end());\n\n            int res = 0;\n            for (auto& c : houses) {\n\n                int idx = Bsearch(heaters, c);\n\n                if (idx == 0) {\n                    res = max(res, heaters[idx] - c);\n                } else if (idx >= (int)heaters.size()) {\n                    res = max(res, c - heaters.back());\n                } else {\n                    res = max(res, min(heaters[idx] - c, c - heaters[idx - 1]));\n                }\n            }\n            return res;\n        }\n\n        int Bsearch(vector<int>& nums, int val) {\n\n            int l = 0, r = nums.size() - 1;\n            while (l <= r) {\n                int mid = l + ((r - l) >> 1);\n                if (nums[mid] == val)\n                    return mid;\n                else if (nums[mid] < val)\n                    l = mid + 1;\n                else\n                    r = mid - 1;\n            }\n            return l;\n        }\n};\n```\n\nAnd it's AC.\n","source":"_posts/Heaters.md","raw":"---\ntitle: Heaters\ndate: 2017-01-04 13:46:25\ntags:\n    - Binary Search\n---\n\n> Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.\n>\n> So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.\n>\n> Note:\n>\n> + Numbers of houses and heaters you are given are non-negative and will not exceed 25000.\n> + Positions of houses and heaters you are given are non-negative and will not exceed 10^9.\n> + As long as a house is in the heaters' warm radius range, it can be warmed.\n> + All the heaters follow your radius standard and the warm radius will the same.\n>\n> Example 1:\n>\n> Input: [1,2,3],[2]\n> Output: 1\n> Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.\n>\n> Example 2:\n>\n> Input: [1,2,3,4],[1,4]\n> Output: 1\n> Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.\n\n<!-- more -->\n\nThis is Leetcode 475. As it's descripted, we can quickly find a solution. Picture this:\n\n\n```\n          h1   h2        h3\n           |    |         |\n......................................\n```\n\nIf we find the min value of the radius between every two heaters, and find the max one, which will be the result.\n\nAnd it's time complex is O(n*m), n is the num of the houses and m is the num of heaters.\n\n```\nusing namespace std;\n\nclass Solution {\npublic:\n    int idx;\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\n        sort(houses.begin(), houses.end());\n        sort(heaters.begin(), heaters.end());\n\n        int res = INT_MIN;\n        idx = 0;\n        for (int i = 0; i < (int)heaters.size(); i++) {\n            if (i == 0) {\n                res = max(res, findMinRadius(houses, -1, heaters[i]));\n            } else if (i == (int)heaters.size()) {\n                res = max(res, findMinRadius(houses, heaters[i - 1], -1));\n            } else {\n                res = max(res, findMinRadius(houses, heaters[i - 1], heaters[i]));\n            }\n            std::cout << res << std::endl;\n        }\n        return res;\n    }\n\n    int findMinRadius(vector<int> houses, int heater1, int heater2) {\n        if (heater1 == -1) { // means the first one\n            while (houses[idx] <= heater2) { idx++; }\n            return heater2 - houses[0];\n        } else if (heater2 == -1) { // means the last one\n            while (idx < (int)houses.size()) { idx++; }\n            return houses[idx - 1] - heater1;\n        } else {\n            int minRadius = INT_MAX;\n            for (int i = idx; houses[i] < heater2; i++) {\n                // minRadius = min(max(houses[i] - heater1, heater2 - houses[i]), minRadius);\n                // if there are (2n-1) houses, we need to use the mid one\n                // if there are (2n) houses, we should use the the mid two\n                // here is hard to decide which to use as the standard\n            }\n            return minRadius;\n        }\n    }\n};\n```\n\nHowever, there is a better way to figure this problem out. The idea is to leverage decent binarySearch function.\n\n+ For each house, find its position between those heaters (thus we need the heaters array to be sorted).\n+ Calculate the distances between this house and left heater and right heater, get a MIN value of those two values. Corner cases are there is no left or right heater.\n+ Get MAX value among distances in step 2. It's the answer.\n\nSo, here comes the solution:\n\n```\nclass Solution {\n    public:\n        int findRadius(vector<int>& houses, vector<int>& heaters) {\n            int house_size = houses.size();\n            if (house_size == 0) return 0;\n            sort(heaters.begin(), heaters.end());\n\n            int res = 0;\n            for (auto& c : houses) {\n\n                int idx = Bsearch(heaters, c);\n\n                if (idx == 0) {\n                    res = max(res, heaters[idx] - c);\n                } else if (idx >= (int)heaters.size()) {\n                    res = max(res, c - heaters.back());\n                } else {\n                    res = max(res, min(heaters[idx] - c, c - heaters[idx - 1]));\n                }\n            }\n            return res;\n        }\n\n        int Bsearch(vector<int>& nums, int val) {\n\n            int l = 0, r = nums.size() - 1;\n            while (l <= r) {\n                int mid = l + ((r - l) >> 1);\n                if (nums[mid] == val)\n                    return mid;\n                else if (nums[mid] < val)\n                    l = mid + 1;\n                else\n                    r = mid - 1;\n            }\n            return l;\n        }\n};\n```\n\nAnd it's AC.\n","slug":"Heaters","published":1,"updated":"2017-01-04T05:27:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5qe000hpff4p3p5ts2w","content":"<blockquote>\n<p>Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.</p>\n<p>So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.</p>\n<p>Note:</p>\n<ul>\n<li>Numbers of houses and heaters you are given are non-negative and will not exceed 25000.</li>\n<li>Positions of houses and heaters you are given are non-negative and will not exceed 10^9.</li>\n<li>As long as a house is in the heaters’ warm radius range, it can be warmed.</li>\n<li>All the heaters follow your radius standard and the warm radius will the same.</li>\n</ul>\n<p>Example 1:</p>\n<p>Input: [1,2,3],[2]<br>Output: 1<br>Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.</p>\n<p>Example 2:</p>\n<p>Input: [1,2,3,4],[1,4]<br>Output: 1<br>Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 475. As it’s descripted, we can quickly find a solution. Picture this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">          h1   h2        h3</div><div class=\"line\">           |    |         |</div><div class=\"line\">......................................</div></pre></td></tr></table></figure>\n<p>If we find the min value of the radius between every two heaters, and find the max one, which will be the result.</p>\n<p>And it’s time complex is O(n*m), n is the num of the houses and m is the num of heaters.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    int idx;</div><div class=\"line\">    int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;</div><div class=\"line\">        sort(houses.begin(), houses.end());</div><div class=\"line\">        sort(heaters.begin(), heaters.end());</div><div class=\"line\"></div><div class=\"line\">        int res = INT_MIN;</div><div class=\"line\">        idx = 0;</div><div class=\"line\">        for (int i = 0; i &lt; (int)heaters.size(); i++) &#123;</div><div class=\"line\">            if (i == 0) &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, -1, heaters[i]));</div><div class=\"line\">            &#125; else if (i == (int)heaters.size()) &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, heaters[i - 1], -1));</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, heaters[i - 1], heaters[i]));</div><div class=\"line\">            &#125;</div><div class=\"line\">            std::cout &lt;&lt; res &lt;&lt; std::endl;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return res;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int findMinRadius(vector&lt;int&gt; houses, int heater1, int heater2) &#123;</div><div class=\"line\">        if (heater1 == -1) &#123; // means the first one</div><div class=\"line\">            while (houses[idx] &lt;= heater2) &#123; idx++; &#125;</div><div class=\"line\">            return heater2 - houses[0];</div><div class=\"line\">        &#125; else if (heater2 == -1) &#123; // means the last one</div><div class=\"line\">            while (idx &lt; (int)houses.size()) &#123; idx++; &#125;</div><div class=\"line\">            return houses[idx - 1] - heater1;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            int minRadius = INT_MAX;</div><div class=\"line\">            for (int i = idx; houses[i] &lt; heater2; i++) &#123;</div><div class=\"line\">                // minRadius = min(max(houses[i] - heater1, heater2 - houses[i]), minRadius);</div><div class=\"line\">                // if there are (2n-1) houses, we need to use the mid one</div><div class=\"line\">                // if there are (2n) houses, we should use the the mid two</div><div class=\"line\">                // here is hard to decide which to use as the standard</div><div class=\"line\">            &#125;</div><div class=\"line\">            return minRadius;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>However, there is a better way to figure this problem out. The idea is to leverage decent binarySearch function.</p>\n<ul>\n<li>For each house, find its position between those heaters (thus we need the heaters array to be sorted).</li>\n<li>Calculate the distances between this house and left heater and right heater, get a MIN value of those two values. Corner cases are there is no left or right heater.</li>\n<li>Get MAX value among distances in step 2. It’s the answer.</li>\n</ul>\n<p>So, here comes the solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;</div><div class=\"line\">            int house_size = houses.size();</div><div class=\"line\">            if (house_size == 0) return 0;</div><div class=\"line\">            sort(heaters.begin(), heaters.end());</div><div class=\"line\"></div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (auto&amp; c : houses) &#123;</div><div class=\"line\"></div><div class=\"line\">                int idx = Bsearch(heaters, c);</div><div class=\"line\"></div><div class=\"line\">                if (idx == 0) &#123;</div><div class=\"line\">                    res = max(res, heaters[idx] - c);</div><div class=\"line\">                &#125; else if (idx &gt;= (int)heaters.size()) &#123;</div><div class=\"line\">                    res = max(res, c - heaters.back());</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    res = max(res, min(heaters[idx] - c, c - heaters[idx - 1]));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int Bsearch(vector&lt;int&gt;&amp; nums, int val) &#123;</div><div class=\"line\"></div><div class=\"line\">            int l = 0, r = nums.size() - 1;</div><div class=\"line\">            while (l &lt;= r) &#123;</div><div class=\"line\">                int mid = l + ((r - l) &gt;&gt; 1);</div><div class=\"line\">                if (nums[mid] == val)</div><div class=\"line\">                    return mid;</div><div class=\"line\">                else if (nums[mid] &lt; val)</div><div class=\"line\">                    l = mid + 1;</div><div class=\"line\">                else</div><div class=\"line\">                    r = mid - 1;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return l;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it’s AC.</p>\n","excerpt":"<blockquote>\n<p>Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.</p>\n<p>So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.</p>\n<p>Note:</p>\n<ul>\n<li>Numbers of houses and heaters you are given are non-negative and will not exceed 25000.</li>\n<li>Positions of houses and heaters you are given are non-negative and will not exceed 10^9.</li>\n<li>As long as a house is in the heaters’ warm radius range, it can be warmed.</li>\n<li>All the heaters follow your radius standard and the warm radius will the same.</li>\n</ul>\n<p>Example 1:</p>\n<p>Input: [1,2,3],[2]<br>Output: 1<br>Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.</p>\n<p>Example 2:</p>\n<p>Input: [1,2,3,4],[1,4]<br>Output: 1<br>Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.</p>\n</blockquote>","more":"<p>This is Leetcode 475. As it’s descripted, we can quickly find a solution. Picture this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">          h1   h2        h3</div><div class=\"line\">           |    |         |</div><div class=\"line\">......................................</div></pre></td></tr></table></figure>\n<p>If we find the min value of the radius between every two heaters, and find the max one, which will be the result.</p>\n<p>And it’s time complex is O(n*m), n is the num of the houses and m is the num of heaters.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    int idx;</div><div class=\"line\">    int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;</div><div class=\"line\">        sort(houses.begin(), houses.end());</div><div class=\"line\">        sort(heaters.begin(), heaters.end());</div><div class=\"line\"></div><div class=\"line\">        int res = INT_MIN;</div><div class=\"line\">        idx = 0;</div><div class=\"line\">        for (int i = 0; i &lt; (int)heaters.size(); i++) &#123;</div><div class=\"line\">            if (i == 0) &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, -1, heaters[i]));</div><div class=\"line\">            &#125; else if (i == (int)heaters.size()) &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, heaters[i - 1], -1));</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, heaters[i - 1], heaters[i]));</div><div class=\"line\">            &#125;</div><div class=\"line\">            std::cout &lt;&lt; res &lt;&lt; std::endl;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return res;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int findMinRadius(vector&lt;int&gt; houses, int heater1, int heater2) &#123;</div><div class=\"line\">        if (heater1 == -1) &#123; // means the first one</div><div class=\"line\">            while (houses[idx] &lt;= heater2) &#123; idx++; &#125;</div><div class=\"line\">            return heater2 - houses[0];</div><div class=\"line\">        &#125; else if (heater2 == -1) &#123; // means the last one</div><div class=\"line\">            while (idx &lt; (int)houses.size()) &#123; idx++; &#125;</div><div class=\"line\">            return houses[idx - 1] - heater1;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            int minRadius = INT_MAX;</div><div class=\"line\">            for (int i = idx; houses[i] &lt; heater2; i++) &#123;</div><div class=\"line\">                // minRadius = min(max(houses[i] - heater1, heater2 - houses[i]), minRadius);</div><div class=\"line\">                // if there are (2n-1) houses, we need to use the mid one</div><div class=\"line\">                // if there are (2n) houses, we should use the the mid two</div><div class=\"line\">                // here is hard to decide which to use as the standard</div><div class=\"line\">            &#125;</div><div class=\"line\">            return minRadius;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>However, there is a better way to figure this problem out. The idea is to leverage decent binarySearch function.</p>\n<ul>\n<li>For each house, find its position between those heaters (thus we need the heaters array to be sorted).</li>\n<li>Calculate the distances between this house and left heater and right heater, get a MIN value of those two values. Corner cases are there is no left or right heater.</li>\n<li>Get MAX value among distances in step 2. It’s the answer.</li>\n</ul>\n<p>So, here comes the solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;</div><div class=\"line\">            int house_size = houses.size();</div><div class=\"line\">            if (house_size == 0) return 0;</div><div class=\"line\">            sort(heaters.begin(), heaters.end());</div><div class=\"line\"></div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (auto&amp; c : houses) &#123;</div><div class=\"line\"></div><div class=\"line\">                int idx = Bsearch(heaters, c);</div><div class=\"line\"></div><div class=\"line\">                if (idx == 0) &#123;</div><div class=\"line\">                    res = max(res, heaters[idx] - c);</div><div class=\"line\">                &#125; else if (idx &gt;= (int)heaters.size()) &#123;</div><div class=\"line\">                    res = max(res, c - heaters.back());</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    res = max(res, min(heaters[idx] - c, c - heaters[idx - 1]));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int Bsearch(vector&lt;int&gt;&amp; nums, int val) &#123;</div><div class=\"line\"></div><div class=\"line\">            int l = 0, r = nums.size() - 1;</div><div class=\"line\">            while (l &lt;= r) &#123;</div><div class=\"line\">                int mid = l + ((r - l) &gt;&gt; 1);</div><div class=\"line\">                if (nums[mid] == val)</div><div class=\"line\">                    return mid;</div><div class=\"line\">                else if (nums[mid] &lt; val)</div><div class=\"line\">                    l = mid + 1;</div><div class=\"line\">                else</div><div class=\"line\">                    r = mid - 1;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return l;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it’s AC.</p>"},{"title":"Increasing Subsequences","date":"2017-01-29T15:16:14.000Z","_content":"\n\n> Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .\n>\n> Example:\n>\n> + Input: [4, 6, 7, 7]\n> + Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]\n>\n> Note:\n>\n> + The length of the given array will not exceed 15.\n> + The range of integer in the given array is [-100,100].\n> + The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.\n\n<!--more-->\n\nThis is Leetcode 491. It's a problem with much fun. You can find a solution by using a stack and a back trace.\n\nNot a clear solution, but I try to make it easy to think and easy to understand.\n\nI try to combine all the possible combination and check whether it is good to move further.\n\n```\nclass Solution {\n    public:\n        set<vector<int> > res;\n        vector<vector<int> > findSubsequences(vector<int> &nums) {\n            vector<int> current;\n            vector<vector<int> > ret;\n\n            res.clear();\n\n            for (int i = 0; i < (int)nums.size(); i++) {\n                _doIt(nums, i, current);\n            }\n\n            for (vector<int> n : res) {\n                ret.push_back(n);\n            }\n            return ret;\n        }\n\n        void _doIt(vector<int> nums, int idx, vector<int> current) {\n            for (int i = idx; i < (int)nums.size(); i++) {\n                if (current.size() > 0 && nums[i] >= current[current.size() - 1]) {\n                    current.push_back(nums[i]);\n                    if (current.size() > 1) {\n                        res.insert(vector<int>(current));\n                    }\n                    _doIt(nums, i + 1, current);\n                    current.pop_back();\n                }\n                if (current.size() == 0){\n                    current.push_back(nums[i]);\n                    _doIt(nums, i + 1, current);\n                    current.pop_back();\n                }\n            }\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/IncreasingSubsequences.md","raw":"---\ntitle: Increasing Subsequences\ndate: 2017-01-29 23:16:14\ntags:\n    - Depth-first Search\n---\n\n\n> Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .\n>\n> Example:\n>\n> + Input: [4, 6, 7, 7]\n> + Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]\n>\n> Note:\n>\n> + The length of the given array will not exceed 15.\n> + The range of integer in the given array is [-100,100].\n> + The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.\n\n<!--more-->\n\nThis is Leetcode 491. It's a problem with much fun. You can find a solution by using a stack and a back trace.\n\nNot a clear solution, but I try to make it easy to think and easy to understand.\n\nI try to combine all the possible combination and check whether it is good to move further.\n\n```\nclass Solution {\n    public:\n        set<vector<int> > res;\n        vector<vector<int> > findSubsequences(vector<int> &nums) {\n            vector<int> current;\n            vector<vector<int> > ret;\n\n            res.clear();\n\n            for (int i = 0; i < (int)nums.size(); i++) {\n                _doIt(nums, i, current);\n            }\n\n            for (vector<int> n : res) {\n                ret.push_back(n);\n            }\n            return ret;\n        }\n\n        void _doIt(vector<int> nums, int idx, vector<int> current) {\n            for (int i = idx; i < (int)nums.size(); i++) {\n                if (current.size() > 0 && nums[i] >= current[current.size() - 1]) {\n                    current.push_back(nums[i]);\n                    if (current.size() > 1) {\n                        res.insert(vector<int>(current));\n                    }\n                    _doIt(nums, i + 1, current);\n                    current.pop_back();\n                }\n                if (current.size() == 0){\n                    current.push_back(nums[i]);\n                    _doIt(nums, i + 1, current);\n                    current.pop_back();\n                }\n            }\n        }\n};\n```\n\nIt gets AC.\n","slug":"IncreasingSubsequences","published":1,"updated":"2017-01-29T15:39:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5qg000jpff40wa4xavv","content":"<blockquote>\n<p>Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .</p>\n<p>Example:</p>\n<ul>\n<li>Input: [4, 6, 7, 7]</li>\n<li>Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>The length of the given array will not exceed 15.</li>\n<li>The range of integer in the given array is [-100,100].</li>\n<li>The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 491. It’s a problem with much fun. You can find a solution by using a stack and a back trace.</p>\n<p>Not a clear solution, but I try to make it easy to think and easy to understand.</p>\n<p>I try to combine all the possible combination and check whether it is good to move further.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        set&lt;vector&lt;int&gt; &gt; res;</div><div class=\"line\">        vector&lt;vector&lt;int&gt; &gt; findSubsequences(vector&lt;int&gt; &amp;nums) &#123;</div><div class=\"line\">            vector&lt;int&gt; current;</div><div class=\"line\">            vector&lt;vector&lt;int&gt; &gt; ret;</div><div class=\"line\"></div><div class=\"line\">            res.clear();</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                _doIt(nums, i, current);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (vector&lt;int&gt; n : res) &#123;</div><div class=\"line\">                ret.push_back(n);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return ret;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _doIt(vector&lt;int&gt; nums, int idx, vector&lt;int&gt; current) &#123;</div><div class=\"line\">            for (int i = idx; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (current.size() &gt; 0 &amp;&amp; nums[i] &gt;= current[current.size() - 1]) &#123;</div><div class=\"line\">                    current.push_back(nums[i]);</div><div class=\"line\">                    if (current.size() &gt; 1) &#123;</div><div class=\"line\">                        res.insert(vector&lt;int&gt;(current));</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    _doIt(nums, i + 1, current);</div><div class=\"line\">                    current.pop_back();</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (current.size() == 0)&#123;</div><div class=\"line\">                    current.push_back(nums[i]);</div><div class=\"line\">                    _doIt(nums, i + 1, current);</div><div class=\"line\">                    current.pop_back();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .</p>\n<p>Example:</p>\n<ul>\n<li>Input: [4, 6, 7, 7]</li>\n<li>Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>The length of the given array will not exceed 15.</li>\n<li>The range of integer in the given array is [-100,100].</li>\n<li>The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 491. It’s a problem with much fun. You can find a solution by using a stack and a back trace.</p>\n<p>Not a clear solution, but I try to make it easy to think and easy to understand.</p>\n<p>I try to combine all the possible combination and check whether it is good to move further.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        set&lt;vector&lt;int&gt; &gt; res;</div><div class=\"line\">        vector&lt;vector&lt;int&gt; &gt; findSubsequences(vector&lt;int&gt; &amp;nums) &#123;</div><div class=\"line\">            vector&lt;int&gt; current;</div><div class=\"line\">            vector&lt;vector&lt;int&gt; &gt; ret;</div><div class=\"line\"></div><div class=\"line\">            res.clear();</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                _doIt(nums, i, current);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (vector&lt;int&gt; n : res) &#123;</div><div class=\"line\">                ret.push_back(n);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return ret;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _doIt(vector&lt;int&gt; nums, int idx, vector&lt;int&gt; current) &#123;</div><div class=\"line\">            for (int i = idx; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (current.size() &gt; 0 &amp;&amp; nums[i] &gt;= current[current.size() - 1]) &#123;</div><div class=\"line\">                    current.push_back(nums[i]);</div><div class=\"line\">                    if (current.size() &gt; 1) &#123;</div><div class=\"line\">                        res.insert(vector&lt;int&gt;(current));</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    _doIt(nums, i + 1, current);</div><div class=\"line\">                    current.pop_back();</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (current.size() == 0)&#123;</div><div class=\"line\">                    current.push_back(nums[i]);</div><div class=\"line\">                    _doIt(nums, i + 1, current);</div><div class=\"line\">                    current.pop_back();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Intersection of Two Arrays II","date":"2017-01-08T14:36:11.000Z","_content":"\n\n> Given two arrays, write a function to compute their intersection.\n>\n> Example:\n> Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].\n>\n> Note:\n>\n>   + Each element in the result should appear as many times as it shows in both arrays.\n>   + The result can be in any order.\n>\n> Follow up:\n>\n>   + What if the given array is already sorted? How would you optimize your algorithm?\n>   + What if nums1's size is small compared to nums2's size? Which algorithm is better?\n>   + What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?\n\n<!--more-->\n\nThis is Leetcode 350. It's an easy problem, we can quickly write a solution based on hash map:\n\n```\nclass Solution {\n    public:\n        vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n            map<int, int> nums;\n            vector<int> res;\n\n\n            for (int i = 0; i < (int)nums1.size(); i++) {\n                if (nums.find(nums1[i]) == nums.end()) {\n                    nums.insert(pair<int, int>(nums1[i], 1));\n                } else {\n                    nums.find(nums1[i])->second++;\n                }\n            }\n\n            for (int i = 0; i < (int)nums2.size(); i++) {\n                if (nums.find(nums2[i]) != nums.end() && nums.find(nums2[i])->second > 0) {\n                    res.push_back(nums2[i]);\n                    nums.find(nums2[i])->second--;\n                }\n            }\n\n            return res;\n        }\n};\n```\n\nIts time complex is O(n), and its space complex is O(n), which makes it not a good solution. So, as the follow up, we can assume that the both arrays are sorted. Then we can use the two points method like below:\n\n```\nclass Solution {\n    public:\n        vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n            int idx = 0, idy = 0;\n            vector<int> res;\n\n            sort(nums1.begin(), nums1.end());\n            sort(nums2.begin(), nums2.end());\n\n            while (idx < (int)nums1.size() && idy < (int)nums2.size()) {\n                if (nums1[idx] == nums2[idy]) {\n                    res.push_back(nums1[idx]);\n                    idx++; idy++;\n                } else if (nums1[idx] > nums2[idy]) {\n                    idy++;\n                } else if (nums1[idx] < nums2[idy]) {\n                    idx++;\n                }\n            }\n\n            return res;\n        }\n};\n```\n\nIts time complex is O(n) but its space complex is O(1), which makes it better than the hash map solution.\n\nIf the memeory is limited such that we can't load all elements into the memory at once? This is a common problem. And we can use the hash algorithm to divide all elements in to different group and then we deal with them one by one.\n\n","source":"_posts/IntersectionofTwoArraysII.md","raw":"---\ntitle: Intersection of Two Arrays II\ndate: 2017-01-08 22:36:11\ntags:\n    - Binary Search\n    - Hash Table\n    - Two Pointers\n    - Sort\n---\n\n\n> Given two arrays, write a function to compute their intersection.\n>\n> Example:\n> Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].\n>\n> Note:\n>\n>   + Each element in the result should appear as many times as it shows in both arrays.\n>   + The result can be in any order.\n>\n> Follow up:\n>\n>   + What if the given array is already sorted? How would you optimize your algorithm?\n>   + What if nums1's size is small compared to nums2's size? Which algorithm is better?\n>   + What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?\n\n<!--more-->\n\nThis is Leetcode 350. It's an easy problem, we can quickly write a solution based on hash map:\n\n```\nclass Solution {\n    public:\n        vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n            map<int, int> nums;\n            vector<int> res;\n\n\n            for (int i = 0; i < (int)nums1.size(); i++) {\n                if (nums.find(nums1[i]) == nums.end()) {\n                    nums.insert(pair<int, int>(nums1[i], 1));\n                } else {\n                    nums.find(nums1[i])->second++;\n                }\n            }\n\n            for (int i = 0; i < (int)nums2.size(); i++) {\n                if (nums.find(nums2[i]) != nums.end() && nums.find(nums2[i])->second > 0) {\n                    res.push_back(nums2[i]);\n                    nums.find(nums2[i])->second--;\n                }\n            }\n\n            return res;\n        }\n};\n```\n\nIts time complex is O(n), and its space complex is O(n), which makes it not a good solution. So, as the follow up, we can assume that the both arrays are sorted. Then we can use the two points method like below:\n\n```\nclass Solution {\n    public:\n        vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n            int idx = 0, idy = 0;\n            vector<int> res;\n\n            sort(nums1.begin(), nums1.end());\n            sort(nums2.begin(), nums2.end());\n\n            while (idx < (int)nums1.size() && idy < (int)nums2.size()) {\n                if (nums1[idx] == nums2[idy]) {\n                    res.push_back(nums1[idx]);\n                    idx++; idy++;\n                } else if (nums1[idx] > nums2[idy]) {\n                    idy++;\n                } else if (nums1[idx] < nums2[idy]) {\n                    idx++;\n                }\n            }\n\n            return res;\n        }\n};\n```\n\nIts time complex is O(n) but its space complex is O(1), which makes it better than the hash map solution.\n\nIf the memeory is limited such that we can't load all elements into the memory at once? This is a common problem. And we can use the hash algorithm to divide all elements in to different group and then we deal with them one by one.\n\n","slug":"IntersectionofTwoArraysII","published":1,"updated":"2017-01-08T15:01:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5qh000lpff4wvmt3yzu","content":"<blockquote>\n<p>Given two arrays, write a function to compute their intersection.</p>\n<p>Example:<br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].</p>\n<p>Note:</p>\n<ul>\n<li>Each element in the result should appear as many times as it shows in both arrays.</li>\n<li>The result can be in any order.</li>\n</ul>\n<p>Follow up:</p>\n<ul>\n<li>What if the given array is already sorted? How would you optimize your algorithm?</li>\n<li>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?</li>\n<li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 350. It’s an easy problem, we can quickly write a solution based on hash map:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</div><div class=\"line\">            map&lt;int, int&gt; nums;</div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums1.size(); i++) &#123;</div><div class=\"line\">                if (nums.find(nums1[i]) == nums.end()) &#123;</div><div class=\"line\">                    nums.insert(pair&lt;int, int&gt;(nums1[i], 1));</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    nums.find(nums1[i])-&gt;second++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums2.size(); i++) &#123;</div><div class=\"line\">                if (nums.find(nums2[i]) != nums.end() &amp;&amp; nums.find(nums2[i])-&gt;second &gt; 0) &#123;</div><div class=\"line\">                    res.push_back(nums2[i]);</div><div class=\"line\">                    nums.find(nums2[i])-&gt;second--;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Its time complex is O(n), and its space complex is O(n), which makes it not a good solution. So, as the follow up, we can assume that the both arrays are sorted. Then we can use the two points method like below:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</div><div class=\"line\">            int idx = 0, idy = 0;</div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\"></div><div class=\"line\">            sort(nums1.begin(), nums1.end());</div><div class=\"line\">            sort(nums2.begin(), nums2.end());</div><div class=\"line\"></div><div class=\"line\">            while (idx &lt; (int)nums1.size() &amp;&amp; idy &lt; (int)nums2.size()) &#123;</div><div class=\"line\">                if (nums1[idx] == nums2[idy]) &#123;</div><div class=\"line\">                    res.push_back(nums1[idx]);</div><div class=\"line\">                    idx++; idy++;</div><div class=\"line\">                &#125; else if (nums1[idx] &gt; nums2[idy]) &#123;</div><div class=\"line\">                    idy++;</div><div class=\"line\">                &#125; else if (nums1[idx] &lt; nums2[idy]) &#123;</div><div class=\"line\">                    idx++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Its time complex is O(n) but its space complex is O(1), which makes it better than the hash map solution.</p>\n<p>If the memeory is limited such that we can’t load all elements into the memory at once? This is a common problem. And we can use the hash algorithm to divide all elements in to different group and then we deal with them one by one.</p>\n","excerpt":"<blockquote>\n<p>Given two arrays, write a function to compute their intersection.</p>\n<p>Example:<br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].</p>\n<p>Note:</p>\n<ul>\n<li>Each element in the result should appear as many times as it shows in both arrays.</li>\n<li>The result can be in any order.</li>\n</ul>\n<p>Follow up:</p>\n<ul>\n<li>What if the given array is already sorted? How would you optimize your algorithm?</li>\n<li>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?</li>\n<li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 350. It’s an easy problem, we can quickly write a solution based on hash map:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</div><div class=\"line\">            map&lt;int, int&gt; nums;</div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums1.size(); i++) &#123;</div><div class=\"line\">                if (nums.find(nums1[i]) == nums.end()) &#123;</div><div class=\"line\">                    nums.insert(pair&lt;int, int&gt;(nums1[i], 1));</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    nums.find(nums1[i])-&gt;second++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums2.size(); i++) &#123;</div><div class=\"line\">                if (nums.find(nums2[i]) != nums.end() &amp;&amp; nums.find(nums2[i])-&gt;second &gt; 0) &#123;</div><div class=\"line\">                    res.push_back(nums2[i]);</div><div class=\"line\">                    nums.find(nums2[i])-&gt;second--;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Its time complex is O(n), and its space complex is O(n), which makes it not a good solution. So, as the follow up, we can assume that the both arrays are sorted. Then we can use the two points method like below:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</div><div class=\"line\">            int idx = 0, idy = 0;</div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\"></div><div class=\"line\">            sort(nums1.begin(), nums1.end());</div><div class=\"line\">            sort(nums2.begin(), nums2.end());</div><div class=\"line\"></div><div class=\"line\">            while (idx &lt; (int)nums1.size() &amp;&amp; idy &lt; (int)nums2.size()) &#123;</div><div class=\"line\">                if (nums1[idx] == nums2[idy]) &#123;</div><div class=\"line\">                    res.push_back(nums1[idx]);</div><div class=\"line\">                    idx++; idy++;</div><div class=\"line\">                &#125; else if (nums1[idx] &gt; nums2[idy]) &#123;</div><div class=\"line\">                    idy++;</div><div class=\"line\">                &#125; else if (nums1[idx] &lt; nums2[idy]) &#123;</div><div class=\"line\">                    idx++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Its time complex is O(n) but its space complex is O(1), which makes it better than the hash map solution.</p>\n<p>If the memeory is limited such that we can’t load all elements into the memory at once? This is a common problem. And we can use the hash algorithm to divide all elements in to different group and then we deal with them one by one.</p>"},{"title":"Integer Replacement","date":"2017-01-22T15:04:22.000Z","_content":"\n> Given a positive integer n and you can do operations as follow:\n>\n> + If n is even, replace n with n/2.\n> + If n is odd, you can replace n with either n + 1 or n - 1.\n>\n> What is the minimum number of replacements needed for n to become 1?\n>\n> Example 1:\n> + Input: 8\n> + Output: 3\n> + Explanation: 8 -> 4 -> 2 -> 1\n>\n> Example 2:\n> + Input: 7\n> + Output: 4\n> + Explanation: 7 -> 8 -> 4 -> 2 -> 1 or 7 -> 6 -> 3 -> 2 -> 1\n\n<!-- more-->\n\nThis is Leetcode 397, and we can quickly find a solution in recuisive way:\n\n```\nclass Solution {\n    public:\n        int integerReplacement(int num) {\n            return _doIt(num);\n        }\n\n        int _doIt(int num) {\n            if (num == 1) {\n                return 0;\n            } else if ((num & 1) == 0) { // even\n                return 1 + _doIt(num >> 1);\n            } else {\n                return 1 + min(_doIt(num + 1), _doIt(num - 1));\n            }\n        }\n};\n```\n\nWithout any doubt, we get a RTE.\n\nBecause, a little problem cause, when the given num is INT_MAX, the (num + 1) will get error.\n\nSo, a easy way to solve or take over the problem is using the data type long:\n\n```\nclass Solution {\n    public:\n        int integerReplacement(int num) {\n            return _doIt((long)num);\n        }\n\n        int _doIt(long num) {\n            if (num == 1) {\n                return 0;\n            } else if ((num & 1) == 0) { // even\n                return 1 + _doIt(num >> 1);\n            } else {\n                return 1 + min(_doIt(num + 1), _doIt(num - 1));\n            }\n        }\n};\n```\n\nNot a nice solution, but it gets AC.\n","source":"_posts/IntegerReplacement.md","raw":"---\ntitle: Integer Replacement\ndate: 2017-01-22 23:04:22\ntags:\n    - Math\n    - Bitmap\n---\n\n> Given a positive integer n and you can do operations as follow:\n>\n> + If n is even, replace n with n/2.\n> + If n is odd, you can replace n with either n + 1 or n - 1.\n>\n> What is the minimum number of replacements needed for n to become 1?\n>\n> Example 1:\n> + Input: 8\n> + Output: 3\n> + Explanation: 8 -> 4 -> 2 -> 1\n>\n> Example 2:\n> + Input: 7\n> + Output: 4\n> + Explanation: 7 -> 8 -> 4 -> 2 -> 1 or 7 -> 6 -> 3 -> 2 -> 1\n\n<!-- more-->\n\nThis is Leetcode 397, and we can quickly find a solution in recuisive way:\n\n```\nclass Solution {\n    public:\n        int integerReplacement(int num) {\n            return _doIt(num);\n        }\n\n        int _doIt(int num) {\n            if (num == 1) {\n                return 0;\n            } else if ((num & 1) == 0) { // even\n                return 1 + _doIt(num >> 1);\n            } else {\n                return 1 + min(_doIt(num + 1), _doIt(num - 1));\n            }\n        }\n};\n```\n\nWithout any doubt, we get a RTE.\n\nBecause, a little problem cause, when the given num is INT_MAX, the (num + 1) will get error.\n\nSo, a easy way to solve or take over the problem is using the data type long:\n\n```\nclass Solution {\n    public:\n        int integerReplacement(int num) {\n            return _doIt((long)num);\n        }\n\n        int _doIt(long num) {\n            if (num == 1) {\n                return 0;\n            } else if ((num & 1) == 0) { // even\n                return 1 + _doIt(num >> 1);\n            } else {\n                return 1 + min(_doIt(num + 1), _doIt(num - 1));\n            }\n        }\n};\n```\n\nNot a nice solution, but it gets AC.\n","slug":"IntegerReplacement","published":1,"updated":"2017-01-24T15:41:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5qi000npff42kggtbdf","content":"<blockquote>\n<p>Given a positive integer n and you can do operations as follow:</p>\n<ul>\n<li>If n is even, replace n with n/2.</li>\n<li>If n is odd, you can replace n with either n + 1 or n - 1.</li>\n</ul>\n<p>What is the minimum number of replacements needed for n to become 1?</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: 8</li>\n<li>Output: 3</li>\n<li>Explanation: 8 -&gt; 4 -&gt; 2 -&gt; 1</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: 7</li>\n<li>Output: 4</li>\n<li>Explanation: 7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1 or 7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 397, and we can quickly find a solution in recuisive way:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int integerReplacement(int num) &#123;</div><div class=\"line\">            return _doIt(num);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int _doIt(int num) &#123;</div><div class=\"line\">            if (num == 1) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125; else if ((num &amp; 1) == 0) &#123; // even</div><div class=\"line\">                return 1 + _doIt(num &gt;&gt; 1);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return 1 + min(_doIt(num + 1), _doIt(num - 1));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Without any doubt, we get a RTE.</p>\n<p>Because, a little problem cause, when the given num is INT_MAX, the (num + 1) will get error.</p>\n<p>So, a easy way to solve or take over the problem is using the data type long:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int integerReplacement(int num) &#123;</div><div class=\"line\">            return _doIt((long)num);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int _doIt(long num) &#123;</div><div class=\"line\">            if (num == 1) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125; else if ((num &amp; 1) == 0) &#123; // even</div><div class=\"line\">                return 1 + _doIt(num &gt;&gt; 1);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return 1 + min(_doIt(num + 1), _doIt(num - 1));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Not a nice solution, but it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a positive integer n and you can do operations as follow:</p>\n<ul>\n<li>If n is even, replace n with n/2.</li>\n<li>If n is odd, you can replace n with either n + 1 or n - 1.</li>\n</ul>\n<p>What is the minimum number of replacements needed for n to become 1?</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: 8</li>\n<li>Output: 3</li>\n<li>Explanation: 8 -&gt; 4 -&gt; 2 -&gt; 1</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: 7</li>\n<li>Output: 4</li>\n<li>Explanation: 7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1 or 7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 397, and we can quickly find a solution in recuisive way:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int integerReplacement(int num) &#123;</div><div class=\"line\">            return _doIt(num);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int _doIt(int num) &#123;</div><div class=\"line\">            if (num == 1) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125; else if ((num &amp; 1) == 0) &#123; // even</div><div class=\"line\">                return 1 + _doIt(num &gt;&gt; 1);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return 1 + min(_doIt(num + 1), _doIt(num - 1));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Without any doubt, we get a RTE.</p>\n<p>Because, a little problem cause, when the given num is INT_MAX, the (num + 1) will get error.</p>\n<p>So, a easy way to solve or take over the problem is using the data type long:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int integerReplacement(int num) &#123;</div><div class=\"line\">            return _doIt((long)num);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int _doIt(long num) &#123;</div><div class=\"line\">            if (num == 1) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125; else if ((num &amp; 1) == 0) &#123; // even</div><div class=\"line\">                return 1 + _doIt(num &gt;&gt; 1);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return 1 + min(_doIt(num + 1), _doIt(num - 1));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Not a nice solution, but it gets AC.</p>"},{"title":"Largest Divisible Subset","date":"2017-01-13T03:04:11.000Z","_content":"\n> Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.\n>\n> If there are multiple solutions, return any subset is fine.\n>\n> Example 1:\n> nums: [1,2,3]\n> Result: [1,2] (of course, [1,3] will also be ok)\n>\n> Example 2:\n> nums: [1,2,4,8]\n> Result: [1,2,4,8]\n\n<!--more-->\n\nThis is Leetcode 368, and it's a usual DP problem.\n\nWe use a numMap to store the pairs for each number. For example: {4:[1,2], 8:[1,2,4]}.\n\nThen we can find the solution:\n\n```\nclass Solution {\n    public:\n        vector<int> largestDivisibleSubset(vector<int>& nums) {\n            vector<int> v;\n            if (nums.size() < 1) {\n                return v;\n            }\n            sort(nums.begin(), nums.end());\n            map<int, vector<int> > numMap;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                vector<int> vtmp;\n                vtmp.push_back(nums[i]);\n                numMap.insert(pair<int, vector<int> >(nums[i], vtmp));\n            }\n            for (int i = 0; i < (int)nums.size(); i++) {\n                for (int j = i + 1; j < (int)nums.size(); j++) {\n                    if (nums[j] % nums[i] == 0) {\n                        if (numMap.find(nums[j])->second.size() < numMap.find(nums[i])->second.size() + 1) {\n                            vector<int> vtmp;\n                            vtmp.assign(numMap.find(nums[i])->second.begin(), numMap.find(nums[i])->second.end());\n                            vtmp.push_back(nums[j]);\n                            numMap.find(nums[j])->second = vtmp;\n                        }\n                    }\n                }\n            }\n\n            int idx = 0, max = 0;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                if (max < (int)numMap.find(nums[i])->second.size()) {\n                    idx = nums[i];\n                    max = numMap.find(nums[i])->second.size();\n                }\n            }\n            return  numMap.find(idx)->second;\n        }\n};\n```\n\nAnd it gets AC.\n","source":"_posts/LargestDivisibleSubset.md","raw":"---\ntitle: Largest Divisible Subset\ndate: 2017-01-13 11:04:11\ntags:\n    - Math\n    - Dynamic Programming\n---\n\n> Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.\n>\n> If there are multiple solutions, return any subset is fine.\n>\n> Example 1:\n> nums: [1,2,3]\n> Result: [1,2] (of course, [1,3] will also be ok)\n>\n> Example 2:\n> nums: [1,2,4,8]\n> Result: [1,2,4,8]\n\n<!--more-->\n\nThis is Leetcode 368, and it's a usual DP problem.\n\nWe use a numMap to store the pairs for each number. For example: {4:[1,2], 8:[1,2,4]}.\n\nThen we can find the solution:\n\n```\nclass Solution {\n    public:\n        vector<int> largestDivisibleSubset(vector<int>& nums) {\n            vector<int> v;\n            if (nums.size() < 1) {\n                return v;\n            }\n            sort(nums.begin(), nums.end());\n            map<int, vector<int> > numMap;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                vector<int> vtmp;\n                vtmp.push_back(nums[i]);\n                numMap.insert(pair<int, vector<int> >(nums[i], vtmp));\n            }\n            for (int i = 0; i < (int)nums.size(); i++) {\n                for (int j = i + 1; j < (int)nums.size(); j++) {\n                    if (nums[j] % nums[i] == 0) {\n                        if (numMap.find(nums[j])->second.size() < numMap.find(nums[i])->second.size() + 1) {\n                            vector<int> vtmp;\n                            vtmp.assign(numMap.find(nums[i])->second.begin(), numMap.find(nums[i])->second.end());\n                            vtmp.push_back(nums[j]);\n                            numMap.find(nums[j])->second = vtmp;\n                        }\n                    }\n                }\n            }\n\n            int idx = 0, max = 0;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                if (max < (int)numMap.find(nums[i])->second.size()) {\n                    idx = nums[i];\n                    max = numMap.find(nums[i])->second.size();\n                }\n            }\n            return  numMap.find(idx)->second;\n        }\n};\n```\n\nAnd it gets AC.\n","slug":"LargestDivisibleSubset","published":1,"updated":"2017-01-14T12:11:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5qk000ppff4ee03a9n8","content":"<blockquote>\n<p>Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.</p>\n<p>If there are multiple solutions, return any subset is fine.</p>\n<p>Example 1:<br>nums: [1,2,3]<br>Result: [1,2] (of course, [1,3] will also be ok)</p>\n<p>Example 2:<br>nums: [1,2,4,8]<br>Result: [1,2,4,8]</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 368, and it’s a usual DP problem.</p>\n<p>We use a numMap to store the pairs for each number. For example: {4:[1,2], 8:[1,2,4]}.</p>\n<p>Then we can find the solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            vector&lt;int&gt; v;</div><div class=\"line\">            if (nums.size() &lt; 1) &#123;</div><div class=\"line\">                return v;</div><div class=\"line\">            &#125;</div><div class=\"line\">            sort(nums.begin(), nums.end());</div><div class=\"line\">            map&lt;int, vector&lt;int&gt; &gt; numMap;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                vector&lt;int&gt; vtmp;</div><div class=\"line\">                vtmp.push_back(nums[i]);</div><div class=\"line\">                numMap.insert(pair&lt;int, vector&lt;int&gt; &gt;(nums[i], vtmp));</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                for (int j = i + 1; j &lt; (int)nums.size(); j++) &#123;</div><div class=\"line\">                    if (nums[j] % nums[i] == 0) &#123;</div><div class=\"line\">                        if (numMap.find(nums[j])-&gt;second.size() &lt; numMap.find(nums[i])-&gt;second.size() + 1) &#123;</div><div class=\"line\">                            vector&lt;int&gt; vtmp;</div><div class=\"line\">                            vtmp.assign(numMap.find(nums[i])-&gt;second.begin(), numMap.find(nums[i])-&gt;second.end());</div><div class=\"line\">                            vtmp.push_back(nums[j]);</div><div class=\"line\">                            numMap.find(nums[j])-&gt;second = vtmp;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int idx = 0, max = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (max &lt; (int)numMap.find(nums[i])-&gt;second.size()) &#123;</div><div class=\"line\">                    idx = nums[i];</div><div class=\"line\">                    max = numMap.find(nums[i])-&gt;second.size();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return  numMap.find(idx)-&gt;second;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.</p>\n<p>If there are multiple solutions, return any subset is fine.</p>\n<p>Example 1:<br>nums: [1,2,3]<br>Result: [1,2] (of course, [1,3] will also be ok)</p>\n<p>Example 2:<br>nums: [1,2,4,8]<br>Result: [1,2,4,8]</p>\n</blockquote>","more":"<p>This is Leetcode 368, and it’s a usual DP problem.</p>\n<p>We use a numMap to store the pairs for each number. For example: {4:[1,2], 8:[1,2,4]}.</p>\n<p>Then we can find the solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            vector&lt;int&gt; v;</div><div class=\"line\">            if (nums.size() &lt; 1) &#123;</div><div class=\"line\">                return v;</div><div class=\"line\">            &#125;</div><div class=\"line\">            sort(nums.begin(), nums.end());</div><div class=\"line\">            map&lt;int, vector&lt;int&gt; &gt; numMap;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                vector&lt;int&gt; vtmp;</div><div class=\"line\">                vtmp.push_back(nums[i]);</div><div class=\"line\">                numMap.insert(pair&lt;int, vector&lt;int&gt; &gt;(nums[i], vtmp));</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                for (int j = i + 1; j &lt; (int)nums.size(); j++) &#123;</div><div class=\"line\">                    if (nums[j] % nums[i] == 0) &#123;</div><div class=\"line\">                        if (numMap.find(nums[j])-&gt;second.size() &lt; numMap.find(nums[i])-&gt;second.size() + 1) &#123;</div><div class=\"line\">                            vector&lt;int&gt; vtmp;</div><div class=\"line\">                            vtmp.assign(numMap.find(nums[i])-&gt;second.begin(), numMap.find(nums[i])-&gt;second.end());</div><div class=\"line\">                            vtmp.push_back(nums[j]);</div><div class=\"line\">                            numMap.find(nums[j])-&gt;second = vtmp;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int idx = 0, max = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (max &lt; (int)numMap.find(nums[i])-&gt;second.size()) &#123;</div><div class=\"line\">                    idx = nums[i];</div><div class=\"line\">                    max = numMap.find(nums[i])-&gt;second.size();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return  numMap.find(idx)-&gt;second;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>"},{"title":"Longest Increasing Path in a Matrix","date":"2017-01-09T08:15:57.000Z","_content":"\n> Given an integer matrix, find the length of the longest increasing path.\n>\n> From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).\n>\n> Example 1:\n>\n> nums = [ [9,9,4], [6,6,8], [2,1,1] ]\n>\n> Return 4\n> The longest increasing path is [1, 2, 6, 9].\n>\n> Example 2:\n>\n> nums = [ [3,4,5], [3,2,6], [2,2,1] ]\n>\n> Return 4\n> The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.\n\n<!-- more -->\n\nThis is Leetcode 329, it's a classic DFS problem. And you can use more space to improve its performance.\n\nFor example, you can use two maxDepth array to store the max depth in current position and its direction.\n\nSo, its solution will be as following, (we use the build-in dfs function):\n\n```\nclass Solution {\n    public:\n        int longestIncreasingPath(vector<vector<int>>& matrix) {\n            int rows = matrix.size();\n            if (!rows) return 0;\n            int cols = matrix[0].size();\n\n            vector<vector<int>> dp(rows, vector<int>(cols, 0));\n            std::function<int(int, int)> dfs = [&] (int x, int y) {\n                if (dp[x][y]) return dp[x][y];\n                vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\n                for (auto &dir : dirs) {\n                    int xx = x + dir[0], yy = y + dir[1];\n                    if (xx < 0 || xx >= rows || yy < 0 || yy >= cols) continue;\n                    if (matrix[xx][yy] <= matrix[x][y]) continue;\n                    dp[x][y] = std::max(dp[x][y], dfs(xx, yy));\n                }\n                return ++dp[x][y];\n            };\n\n            int ret = 0;\n            for (int i = 0; i < rows; ++i) {\n                for (int j = 0; j < cols; ++j) {\n                    ret = std::max(ret, dfs(i, j));\n                }\n            }\n\n            return ret;\n        }\n};\n```\n","source":"_posts/LongestIncreasingPathinaMatrix.md","raw":"---\ntitle: Longest Increasing Path in a Matrix\ndate: 2017-01-09 16:15:57\ntags:\n    - Depth-first Search\n    - Memoization\n    - Topological sort\n---\n\n> Given an integer matrix, find the length of the longest increasing path.\n>\n> From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).\n>\n> Example 1:\n>\n> nums = [ [9,9,4], [6,6,8], [2,1,1] ]\n>\n> Return 4\n> The longest increasing path is [1, 2, 6, 9].\n>\n> Example 2:\n>\n> nums = [ [3,4,5], [3,2,6], [2,2,1] ]\n>\n> Return 4\n> The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.\n\n<!-- more -->\n\nThis is Leetcode 329, it's a classic DFS problem. And you can use more space to improve its performance.\n\nFor example, you can use two maxDepth array to store the max depth in current position and its direction.\n\nSo, its solution will be as following, (we use the build-in dfs function):\n\n```\nclass Solution {\n    public:\n        int longestIncreasingPath(vector<vector<int>>& matrix) {\n            int rows = matrix.size();\n            if (!rows) return 0;\n            int cols = matrix[0].size();\n\n            vector<vector<int>> dp(rows, vector<int>(cols, 0));\n            std::function<int(int, int)> dfs = [&] (int x, int y) {\n                if (dp[x][y]) return dp[x][y];\n                vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\n                for (auto &dir : dirs) {\n                    int xx = x + dir[0], yy = y + dir[1];\n                    if (xx < 0 || xx >= rows || yy < 0 || yy >= cols) continue;\n                    if (matrix[xx][yy] <= matrix[x][y]) continue;\n                    dp[x][y] = std::max(dp[x][y], dfs(xx, yy));\n                }\n                return ++dp[x][y];\n            };\n\n            int ret = 0;\n            for (int i = 0; i < rows; ++i) {\n                for (int j = 0; j < cols; ++j) {\n                    ret = std::max(ret, dfs(i, j));\n                }\n            }\n\n            return ret;\n        }\n};\n```\n","slug":"LongestIncreasingPathinaMatrix","published":1,"updated":"2017-01-09T08:24:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5qn000rpff4g49nf6qy","content":"<blockquote>\n<p>Given an integer matrix, find the length of the longest increasing path.</p>\n<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>\n<p>Example 1:</p>\n<p>nums = [ [9,9,4], [6,6,8], [2,1,1] ]</p>\n<p>Return 4<br>The longest increasing path is [1, 2, 6, 9].</p>\n<p>Example 2:</p>\n<p>nums = [ [3,4,5], [3,2,6], [2,2,1] ]</p>\n<p>Return 4<br>The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 329, it’s a classic DFS problem. And you can use more space to improve its performance.</p>\n<p>For example, you can use two maxDepth array to store the max depth in current position and its direction.</p>\n<p>So, its solution will be as following, (we use the build-in dfs function):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</div><div class=\"line\">            int rows = matrix.size();</div><div class=\"line\">            if (!rows) return 0;</div><div class=\"line\">            int cols = matrix[0].size();</div><div class=\"line\"></div><div class=\"line\">            vector&lt;vector&lt;int&gt;&gt; dp(rows, vector&lt;int&gt;(cols, 0));</div><div class=\"line\">            std::function&lt;int(int, int)&gt; dfs = [&amp;] (int x, int y) &#123;</div><div class=\"line\">                if (dp[x][y]) return dp[x][y];</div><div class=\"line\">                vector&lt;vector&lt;int&gt;&gt; dirs = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;</div><div class=\"line\">                for (auto &amp;dir : dirs) &#123;</div><div class=\"line\">                    int xx = x + dir[0], yy = y + dir[1];</div><div class=\"line\">                    if (xx &lt; 0 || xx &gt;= rows || yy &lt; 0 || yy &gt;= cols) continue;</div><div class=\"line\">                    if (matrix[xx][yy] &lt;= matrix[x][y]) continue;</div><div class=\"line\">                    dp[x][y] = std::max(dp[x][y], dfs(xx, yy));</div><div class=\"line\">                &#125;</div><div class=\"line\">                return ++dp[x][y];</div><div class=\"line\">            &#125;;</div><div class=\"line\"></div><div class=\"line\">            int ret = 0;</div><div class=\"line\">            for (int i = 0; i &lt; rows; ++i) &#123;</div><div class=\"line\">                for (int j = 0; j &lt; cols; ++j) &#123;</div><div class=\"line\">                    ret = std::max(ret, dfs(i, j));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return ret;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n","excerpt":"<blockquote>\n<p>Given an integer matrix, find the length of the longest increasing path.</p>\n<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>\n<p>Example 1:</p>\n<p>nums = [ [9,9,4], [6,6,8], [2,1,1] ]</p>\n<p>Return 4<br>The longest increasing path is [1, 2, 6, 9].</p>\n<p>Example 2:</p>\n<p>nums = [ [3,4,5], [3,2,6], [2,2,1] ]</p>\n<p>Return 4<br>The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</p>\n</blockquote>","more":"<p>This is Leetcode 329, it’s a classic DFS problem. And you can use more space to improve its performance.</p>\n<p>For example, you can use two maxDepth array to store the max depth in current position and its direction.</p>\n<p>So, its solution will be as following, (we use the build-in dfs function):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</div><div class=\"line\">            int rows = matrix.size();</div><div class=\"line\">            if (!rows) return 0;</div><div class=\"line\">            int cols = matrix[0].size();</div><div class=\"line\"></div><div class=\"line\">            vector&lt;vector&lt;int&gt;&gt; dp(rows, vector&lt;int&gt;(cols, 0));</div><div class=\"line\">            std::function&lt;int(int, int)&gt; dfs = [&amp;] (int x, int y) &#123;</div><div class=\"line\">                if (dp[x][y]) return dp[x][y];</div><div class=\"line\">                vector&lt;vector&lt;int&gt;&gt; dirs = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;</div><div class=\"line\">                for (auto &amp;dir : dirs) &#123;</div><div class=\"line\">                    int xx = x + dir[0], yy = y + dir[1];</div><div class=\"line\">                    if (xx &lt; 0 || xx &gt;= rows || yy &lt; 0 || yy &gt;= cols) continue;</div><div class=\"line\">                    if (matrix[xx][yy] &lt;= matrix[x][y]) continue;</div><div class=\"line\">                    dp[x][y] = std::max(dp[x][y], dfs(xx, yy));</div><div class=\"line\">                &#125;</div><div class=\"line\">                return ++dp[x][y];</div><div class=\"line\">            &#125;;</div><div class=\"line\"></div><div class=\"line\">            int ret = 0;</div><div class=\"line\">            for (int i = 0; i &lt; rows; ++i) &#123;</div><div class=\"line\">                for (int j = 0; j &lt; cols; ++j) &#123;</div><div class=\"line\">                    ret = std::max(ret, dfs(i, j));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return ret;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>"},{"title":"License Key Formatting","date":"2017-01-17T15:18:47.000Z","_content":"> Now you are given a string S, which represents a software license key which we would like to format. The string S is composed of alphanumerical characters and dashes. The dashes split the alphanumerical characters within the string into groups. (i.e. if there are M dashes, the string is split into M+1 groups). The dashes in the given string are possibly misplaced.\n>\n> We want each group of characters to be of length K (except for possibly the first group, which could be shorter, but still must contain at least one character). To satisfy this requirement, we will reinsert dashes. Additionally, all the lower case letters in the string must be converted to upper case.\n>\n> So, you are given a non-empty string S, representing a license key to format, and an integer K. And you need to return the license key formatted according to the description above.\n>\n>\n> Example 1:\n>   + Input: S = \"2-4A0r7-4k\", K = 4\n>   + Output: \"24A0-R74K\"\n>   + Explanation: The string S has been split into two parts, each part has 4 characters.\n>\n> Example 2:\n>   + Input: S = \"2-4A0r7-4k\", K = 3\n>   + Output: \"24-A0R-74K\"\n>   + Explanation: The string S has been split into three parts, each part has 3 characters except the first part as it could be shorter as said above.\n>\n> Note:\n> + The length of string S will not exceed 12,000, and K is a positive integer.\n> + String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).\n> + String S is non-empty.\n\n<!--more-->\n\nThis is Leetcode 482, and I think it is just a simulation problem. So there is none technical skills just use force and quick type skills.\n\n```\nclass Solution {\n    public:\n        string licenseKeyFormatting(string S, int K) {\n            vector<char> strs;\n            for (int i = 0; i < (int)S.length(); i++) {\n                if (S[i] == '-') {\n                    continue;\n                } else if ('a' <= S[i] && S[i] <= 'z') {\n                    strs.push_back((char)(S[i] - 'a' + 'A'));\n                } else {\n                    strs.push_back(S[i]);\n                }\n            }\n            int firstIdx = strs.size() % K;\n            string res = \"\";\n            for (int i = 0; i < firstIdx; i++) {\n                res = res + strs[i];\n            }\n            for (int i = firstIdx; i < (int)strs.size(); i++) {\n                if (i != 0 && (i - firstIdx) % K == 0) {\n                    res = res + '-';\n                }\n                res = res + strs[i];\n            }\n            return res;\n        }\n};\n```\n\nThis code I just type and submit and get AC in the first time. Such an easy problem.\n\n","source":"_posts/LicenseKeyFormatting.md","raw":"---\ntitle: License Key Formatting\ndate: 2017-01-17 23:18:47\ntags:\n    - String\n---\n> Now you are given a string S, which represents a software license key which we would like to format. The string S is composed of alphanumerical characters and dashes. The dashes split the alphanumerical characters within the string into groups. (i.e. if there are M dashes, the string is split into M+1 groups). The dashes in the given string are possibly misplaced.\n>\n> We want each group of characters to be of length K (except for possibly the first group, which could be shorter, but still must contain at least one character). To satisfy this requirement, we will reinsert dashes. Additionally, all the lower case letters in the string must be converted to upper case.\n>\n> So, you are given a non-empty string S, representing a license key to format, and an integer K. And you need to return the license key formatted according to the description above.\n>\n>\n> Example 1:\n>   + Input: S = \"2-4A0r7-4k\", K = 4\n>   + Output: \"24A0-R74K\"\n>   + Explanation: The string S has been split into two parts, each part has 4 characters.\n>\n> Example 2:\n>   + Input: S = \"2-4A0r7-4k\", K = 3\n>   + Output: \"24-A0R-74K\"\n>   + Explanation: The string S has been split into three parts, each part has 3 characters except the first part as it could be shorter as said above.\n>\n> Note:\n> + The length of string S will not exceed 12,000, and K is a positive integer.\n> + String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).\n> + String S is non-empty.\n\n<!--more-->\n\nThis is Leetcode 482, and I think it is just a simulation problem. So there is none technical skills just use force and quick type skills.\n\n```\nclass Solution {\n    public:\n        string licenseKeyFormatting(string S, int K) {\n            vector<char> strs;\n            for (int i = 0; i < (int)S.length(); i++) {\n                if (S[i] == '-') {\n                    continue;\n                } else if ('a' <= S[i] && S[i] <= 'z') {\n                    strs.push_back((char)(S[i] - 'a' + 'A'));\n                } else {\n                    strs.push_back(S[i]);\n                }\n            }\n            int firstIdx = strs.size() % K;\n            string res = \"\";\n            for (int i = 0; i < firstIdx; i++) {\n                res = res + strs[i];\n            }\n            for (int i = firstIdx; i < (int)strs.size(); i++) {\n                if (i != 0 && (i - firstIdx) % K == 0) {\n                    res = res + '-';\n                }\n                res = res + strs[i];\n            }\n            return res;\n        }\n};\n```\n\nThis code I just type and submit and get AC in the first time. Such an easy problem.\n\n","slug":"LicenseKeyFormatting","published":1,"updated":"2017-01-17T15:33:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5qp000tpff4i0bssx3j","content":"<blockquote>\n<p>Now you are given a string S, which represents a software license key which we would like to format. The string S is composed of alphanumerical characters and dashes. The dashes split the alphanumerical characters within the string into groups. (i.e. if there are M dashes, the string is split into M+1 groups). The dashes in the given string are possibly misplaced.</p>\n<p>We want each group of characters to be of length K (except for possibly the first group, which could be shorter, but still must contain at least one character). To satisfy this requirement, we will reinsert dashes. Additionally, all the lower case letters in the string must be converted to upper case.</p>\n<p>So, you are given a non-empty string S, representing a license key to format, and an integer K. And you need to return the license key formatted according to the description above.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: S = “2-4A0r7-4k”, K = 4</li>\n<li>Output: “24A0-R74K”</li>\n<li>Explanation: The string S has been split into two parts, each part has 4 characters.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: S = “2-4A0r7-4k”, K = 3</li>\n<li>Output: “24-A0R-74K”</li>\n<li>Explanation: The string S has been split into three parts, each part has 3 characters except the first part as it could be shorter as said above.</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>The length of string S will not exceed 12,000, and K is a positive integer.</li>\n<li>String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).</li>\n<li>String S is non-empty.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 482, and I think it is just a simulation problem. So there is none technical skills just use force and quick type skills.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        string licenseKeyFormatting(string S, int K) &#123;</div><div class=\"line\">            vector&lt;char&gt; strs;</div><div class=\"line\">            for (int i = 0; i &lt; (int)S.length(); i++) &#123;</div><div class=\"line\">                if (S[i] == &apos;-&apos;) &#123;</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125; else if (&apos;a&apos; &lt;= S[i] &amp;&amp; S[i] &lt;= &apos;z&apos;) &#123;</div><div class=\"line\">                    strs.push_back((char)(S[i] - &apos;a&apos; + &apos;A&apos;));</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    strs.push_back(S[i]);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int firstIdx = strs.size() % K;</div><div class=\"line\">            string res = &quot;&quot;;</div><div class=\"line\">            for (int i = 0; i &lt; firstIdx; i++) &#123;</div><div class=\"line\">                res = res + strs[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = firstIdx; i &lt; (int)strs.size(); i++) &#123;</div><div class=\"line\">                if (i != 0 &amp;&amp; (i - firstIdx) % K == 0) &#123;</div><div class=\"line\">                    res = res + &apos;-&apos;;</div><div class=\"line\">                &#125;</div><div class=\"line\">                res = res + strs[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>This code I just type and submit and get AC in the first time. Such an easy problem.</p>\n","excerpt":"<blockquote>\n<p>Now you are given a string S, which represents a software license key which we would like to format. The string S is composed of alphanumerical characters and dashes. The dashes split the alphanumerical characters within the string into groups. (i.e. if there are M dashes, the string is split into M+1 groups). The dashes in the given string are possibly misplaced.</p>\n<p>We want each group of characters to be of length K (except for possibly the first group, which could be shorter, but still must contain at least one character). To satisfy this requirement, we will reinsert dashes. Additionally, all the lower case letters in the string must be converted to upper case.</p>\n<p>So, you are given a non-empty string S, representing a license key to format, and an integer K. And you need to return the license key formatted according to the description above.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: S = “2-4A0r7-4k”, K = 4</li>\n<li>Output: “24A0-R74K”</li>\n<li>Explanation: The string S has been split into two parts, each part has 4 characters.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: S = “2-4A0r7-4k”, K = 3</li>\n<li>Output: “24-A0R-74K”</li>\n<li>Explanation: The string S has been split into three parts, each part has 3 characters except the first part as it could be shorter as said above.</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>The length of string S will not exceed 12,000, and K is a positive integer.</li>\n<li>String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).</li>\n<li>String S is non-empty.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 482, and I think it is just a simulation problem. So there is none technical skills just use force and quick type skills.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        string licenseKeyFormatting(string S, int K) &#123;</div><div class=\"line\">            vector&lt;char&gt; strs;</div><div class=\"line\">            for (int i = 0; i &lt; (int)S.length(); i++) &#123;</div><div class=\"line\">                if (S[i] == &apos;-&apos;) &#123;</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125; else if (&apos;a&apos; &lt;= S[i] &amp;&amp; S[i] &lt;= &apos;z&apos;) &#123;</div><div class=\"line\">                    strs.push_back((char)(S[i] - &apos;a&apos; + &apos;A&apos;));</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    strs.push_back(S[i]);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int firstIdx = strs.size() % K;</div><div class=\"line\">            string res = &quot;&quot;;</div><div class=\"line\">            for (int i = 0; i &lt; firstIdx; i++) &#123;</div><div class=\"line\">                res = res + strs[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = firstIdx; i &lt; (int)strs.size(); i++) &#123;</div><div class=\"line\">                if (i != 0 &amp;&amp; (i - firstIdx) % K == 0) &#123;</div><div class=\"line\">                    res = res + &apos;-&apos;;</div><div class=\"line\">                &#125;</div><div class=\"line\">                res = res + strs[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>This code I just type and submit and get AC in the first time. Such an easy problem.</p>"},{"title":"Matchsticks to Square","date":"2017-02-04T05:50:52.000Z","_content":"\n> Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.\n>\n> Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.\n>\n> Example 1:\n>\n> + Input: [1,1,2,2,2]\n> + Output: true\n> + Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.\n>\n> Example 2:\n>\n> + Input: [3,3,3,3,4]\n> + Output: false\n> + Explanation: You cannot find a way to form a square with all the matchsticks.\n>\n> Note:\n> + The length sum of the given matchsticks is in the range of 0 to 10^9.\n> + The length of the given matchstick array will not exceed 15.\n\n<!--more-->\n\nThis is Leetcode 473. It is an interesting problem. You can quickly find the condition which never make a square. When the total length can't be divided by 4. If it can be divided by 4, you also make sure the sticks can be reformed to that length.\n\nSo, the problem becomes to find that if the array can be reformed by four (total length)/4.\n\nMaybe we can use the two pointer function here to find the suitable solution, use a visited array to mark every stick we used, it may use O(NlogN + 4N) time. As following:\n\n```\nbool _calcLength(vector<int>& nums, int target, int currentNum) {\n    if (currentNum == 3) {\n        return true;\n    } else {\n        int startIdx = 0, endIdx = 0, currentSum = 0;\n        while (visited[startIdx] == 1) {\n            startIdx++;\n        }\n\n        endIdx = startIdx, currentSum = nums[startIdx];\n        visited[startIdx] = 1;\n        while (endIdx < (int)nums.size() && startIdx <= endIdx) {\n            if (visited[endIdx] == 1) {\n                endIdx++;\n                continue;\n            }\n            if (visited[startIdx] == 1) {\n                startIdx++;\n                continue;\n            }\n\n            if (currentSum > target) {\n                currentSum = currentSum - nums[startIdx];\n                visited[startIdx] = 0;\n                startIdx++;\n            } else if (currentSum == target) {\n                return _calcLength(nums, target, currentNum + 1);\n            } else {\n                currentSum = currentSum + nums[endIdx];\n                visited[endIdx] = 1;\n                endIdx++;\n            }\n        }\n        return false;\n    }\n}\n```\n\nBut I failed, because when the case is [3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5], I have to find the 12, so I find [3, 3, 3, 3], and it will make the next failed.\n\nSo, it must be some other solution. Then I find a blur force solution.\n\n```\nclass Solution {\n    public:\n        bool makesquare(vector<int>& nums) {\n            if (nums.size() < 4) {\n                return false;\n            }\n\n            long long totalLength = 0;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                totalLength = totalLength + nums[i];\n            }\n\n            int sums[4];\n            memset(sums, 0, sizeof(sums));\n\n            if (totalLength % 4 != 0) {\n                return false;\n            } else {\n                return _calcLength(nums, sums, 0, totalLength/4);\n            }\n        }\n\n        bool _calcLength(vector<int>& nums, int sums[], int idx, int target) {\n            if (idx == (int)nums.size()) {\n                if (sums[0] == target && sums[1] == target && sums[2] == target) {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n\n            for (int i = 0; i < 4; i++) {\n                if (sums[i] + nums[idx] > target) {\n                    continue;\n                }\n                sums[i] = sums[i] + nums[idx];\n                if (_calcLength(nums, sums, idx + 1, target)) {\n                    return true;\n                }\n                sums[i] = sums[i] - nums[idx];\n            }\n            return false;\n        }\n};\n```\n\nIt simply gets AC.\n","source":"_posts/MatchstickstoSquare.md","raw":"---\ntitle: Matchsticks to Square\ndate: 2017-02-04 13:50:52\ntags:\n    - Depth-first Search\n---\n\n> Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.\n>\n> Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.\n>\n> Example 1:\n>\n> + Input: [1,1,2,2,2]\n> + Output: true\n> + Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.\n>\n> Example 2:\n>\n> + Input: [3,3,3,3,4]\n> + Output: false\n> + Explanation: You cannot find a way to form a square with all the matchsticks.\n>\n> Note:\n> + The length sum of the given matchsticks is in the range of 0 to 10^9.\n> + The length of the given matchstick array will not exceed 15.\n\n<!--more-->\n\nThis is Leetcode 473. It is an interesting problem. You can quickly find the condition which never make a square. When the total length can't be divided by 4. If it can be divided by 4, you also make sure the sticks can be reformed to that length.\n\nSo, the problem becomes to find that if the array can be reformed by four (total length)/4.\n\nMaybe we can use the two pointer function here to find the suitable solution, use a visited array to mark every stick we used, it may use O(NlogN + 4N) time. As following:\n\n```\nbool _calcLength(vector<int>& nums, int target, int currentNum) {\n    if (currentNum == 3) {\n        return true;\n    } else {\n        int startIdx = 0, endIdx = 0, currentSum = 0;\n        while (visited[startIdx] == 1) {\n            startIdx++;\n        }\n\n        endIdx = startIdx, currentSum = nums[startIdx];\n        visited[startIdx] = 1;\n        while (endIdx < (int)nums.size() && startIdx <= endIdx) {\n            if (visited[endIdx] == 1) {\n                endIdx++;\n                continue;\n            }\n            if (visited[startIdx] == 1) {\n                startIdx++;\n                continue;\n            }\n\n            if (currentSum > target) {\n                currentSum = currentSum - nums[startIdx];\n                visited[startIdx] = 0;\n                startIdx++;\n            } else if (currentSum == target) {\n                return _calcLength(nums, target, currentNum + 1);\n            } else {\n                currentSum = currentSum + nums[endIdx];\n                visited[endIdx] = 1;\n                endIdx++;\n            }\n        }\n        return false;\n    }\n}\n```\n\nBut I failed, because when the case is [3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5], I have to find the 12, so I find [3, 3, 3, 3], and it will make the next failed.\n\nSo, it must be some other solution. Then I find a blur force solution.\n\n```\nclass Solution {\n    public:\n        bool makesquare(vector<int>& nums) {\n            if (nums.size() < 4) {\n                return false;\n            }\n\n            long long totalLength = 0;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                totalLength = totalLength + nums[i];\n            }\n\n            int sums[4];\n            memset(sums, 0, sizeof(sums));\n\n            if (totalLength % 4 != 0) {\n                return false;\n            } else {\n                return _calcLength(nums, sums, 0, totalLength/4);\n            }\n        }\n\n        bool _calcLength(vector<int>& nums, int sums[], int idx, int target) {\n            if (idx == (int)nums.size()) {\n                if (sums[0] == target && sums[1] == target && sums[2] == target) {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n\n            for (int i = 0; i < 4; i++) {\n                if (sums[i] + nums[idx] > target) {\n                    continue;\n                }\n                sums[i] = sums[i] + nums[idx];\n                if (_calcLength(nums, sums, idx + 1, target)) {\n                    return true;\n                }\n                sums[i] = sums[i] - nums[idx];\n            }\n            return false;\n        }\n};\n```\n\nIt simply gets AC.\n","slug":"MatchstickstoSquare","published":1,"updated":"2017-02-04T07:49:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5qr000vpff4m243rdis","content":"<blockquote>\n<p>Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.</p>\n<p>Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: [1,1,2,2,2]</li>\n<li>Output: true</li>\n<li>Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: [3,3,3,3,4]</li>\n<li>Output: false</li>\n<li>Explanation: You cannot find a way to form a square with all the matchsticks.</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>The length sum of the given matchsticks is in the range of 0 to 10^9.</li>\n<li>The length of the given matchstick array will not exceed 15.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 473. It is an interesting problem. You can quickly find the condition which never make a square. When the total length can’t be divided by 4. If it can be divided by 4, you also make sure the sticks can be reformed to that length.</p>\n<p>So, the problem becomes to find that if the array can be reformed by four (total length)/4.</p>\n<p>Maybe we can use the two pointer function here to find the suitable solution, use a visited array to mark every stick we used, it may use O(NlogN + 4N) time. As following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool _calcLength(vector&lt;int&gt;&amp; nums, int target, int currentNum) &#123;</div><div class=\"line\">    if (currentNum == 3) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        int startIdx = 0, endIdx = 0, currentSum = 0;</div><div class=\"line\">        while (visited[startIdx] == 1) &#123;</div><div class=\"line\">            startIdx++;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        endIdx = startIdx, currentSum = nums[startIdx];</div><div class=\"line\">        visited[startIdx] = 1;</div><div class=\"line\">        while (endIdx &lt; (int)nums.size() &amp;&amp; startIdx &lt;= endIdx) &#123;</div><div class=\"line\">            if (visited[endIdx] == 1) &#123;</div><div class=\"line\">                endIdx++;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (visited[startIdx] == 1) &#123;</div><div class=\"line\">                startIdx++;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (currentSum &gt; target) &#123;</div><div class=\"line\">                currentSum = currentSum - nums[startIdx];</div><div class=\"line\">                visited[startIdx] = 0;</div><div class=\"line\">                startIdx++;</div><div class=\"line\">            &#125; else if (currentSum == target) &#123;</div><div class=\"line\">                return _calcLength(nums, target, currentNum + 1);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                currentSum = currentSum + nums[endIdx];</div><div class=\"line\">                visited[endIdx] = 1;</div><div class=\"line\">                endIdx++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>But I failed, because when the case is [3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5], I have to find the 12, so I find [3, 3, 3, 3], and it will make the next failed.</p>\n<p>So, it must be some other solution. Then I find a blur force solution.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool makesquare(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() &lt; 4) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            long long totalLength = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                totalLength = totalLength + nums[i];</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int sums[4];</div><div class=\"line\">            memset(sums, 0, sizeof(sums));</div><div class=\"line\"></div><div class=\"line\">            if (totalLength % 4 != 0) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return _calcLength(nums, sums, 0, totalLength/4);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool _calcLength(vector&lt;int&gt;&amp; nums, int sums[], int idx, int target) &#123;</div><div class=\"line\">            if (idx == (int)nums.size()) &#123;</div><div class=\"line\">                if (sums[0] == target &amp;&amp; sums[1] == target &amp;&amp; sums[2] == target) &#123;</div><div class=\"line\">                    return true;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    return false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; 4; i++) &#123;</div><div class=\"line\">                if (sums[i] + nums[idx] &gt; target) &#123;</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\">                sums[i] = sums[i] + nums[idx];</div><div class=\"line\">                if (_calcLength(nums, sums, idx + 1, target)) &#123;</div><div class=\"line\">                    return true;</div><div class=\"line\">                &#125;</div><div class=\"line\">                sums[i] = sums[i] - nums[idx];</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It simply gets AC.</p>\n","excerpt":"<blockquote>\n<p>Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.</p>\n<p>Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: [1,1,2,2,2]</li>\n<li>Output: true</li>\n<li>Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: [3,3,3,3,4]</li>\n<li>Output: false</li>\n<li>Explanation: You cannot find a way to form a square with all the matchsticks.</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>The length sum of the given matchsticks is in the range of 0 to 10^9.</li>\n<li>The length of the given matchstick array will not exceed 15.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 473. It is an interesting problem. You can quickly find the condition which never make a square. When the total length can’t be divided by 4. If it can be divided by 4, you also make sure the sticks can be reformed to that length.</p>\n<p>So, the problem becomes to find that if the array can be reformed by four (total length)/4.</p>\n<p>Maybe we can use the two pointer function here to find the suitable solution, use a visited array to mark every stick we used, it may use O(NlogN + 4N) time. As following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool _calcLength(vector&lt;int&gt;&amp; nums, int target, int currentNum) &#123;</div><div class=\"line\">    if (currentNum == 3) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        int startIdx = 0, endIdx = 0, currentSum = 0;</div><div class=\"line\">        while (visited[startIdx] == 1) &#123;</div><div class=\"line\">            startIdx++;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        endIdx = startIdx, currentSum = nums[startIdx];</div><div class=\"line\">        visited[startIdx] = 1;</div><div class=\"line\">        while (endIdx &lt; (int)nums.size() &amp;&amp; startIdx &lt;= endIdx) &#123;</div><div class=\"line\">            if (visited[endIdx] == 1) &#123;</div><div class=\"line\">                endIdx++;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (visited[startIdx] == 1) &#123;</div><div class=\"line\">                startIdx++;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (currentSum &gt; target) &#123;</div><div class=\"line\">                currentSum = currentSum - nums[startIdx];</div><div class=\"line\">                visited[startIdx] = 0;</div><div class=\"line\">                startIdx++;</div><div class=\"line\">            &#125; else if (currentSum == target) &#123;</div><div class=\"line\">                return _calcLength(nums, target, currentNum + 1);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                currentSum = currentSum + nums[endIdx];</div><div class=\"line\">                visited[endIdx] = 1;</div><div class=\"line\">                endIdx++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>But I failed, because when the case is [3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5], I have to find the 12, so I find [3, 3, 3, 3], and it will make the next failed.</p>\n<p>So, it must be some other solution. Then I find a blur force solution.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool makesquare(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() &lt; 4) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            long long totalLength = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                totalLength = totalLength + nums[i];</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int sums[4];</div><div class=\"line\">            memset(sums, 0, sizeof(sums));</div><div class=\"line\"></div><div class=\"line\">            if (totalLength % 4 != 0) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return _calcLength(nums, sums, 0, totalLength/4);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool _calcLength(vector&lt;int&gt;&amp; nums, int sums[], int idx, int target) &#123;</div><div class=\"line\">            if (idx == (int)nums.size()) &#123;</div><div class=\"line\">                if (sums[0] == target &amp;&amp; sums[1] == target &amp;&amp; sums[2] == target) &#123;</div><div class=\"line\">                    return true;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    return false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; 4; i++) &#123;</div><div class=\"line\">                if (sums[i] + nums[idx] &gt; target) &#123;</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\">                sums[i] = sums[i] + nums[idx];</div><div class=\"line\">                if (_calcLength(nums, sums, idx + 1, target)) &#123;</div><div class=\"line\">                    return true;</div><div class=\"line\">                &#125;</div><div class=\"line\">                sums[i] = sums[i] - nums[idx];</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It simply gets AC.</p>"},{"title":"Max Consecutive Ones II","date":"2017-01-15T06:18:18.000Z","_content":"\n> Given a binary array, find the maximum number of consecutive 1s in this array if you can flip at most one 0.\n>\n> Example 1:\n>\n> Input: [1,0,1,1,0]\n> Output: 4\n> Explanation: Flip the first zero will get the the maximum number of consecutive 1s.\n> > After flipping, the maximum number of consecutive 1s is 4.\n>\n> Note:\n> + The input array will only contain 0 and 1.\n> + The length of input array is a positive integer and will not exceed 10,000\n>\n> Follow up:\n> What if the input numbers come in one by one as an infinite stream? In other words, you can't store all numbers coming from the stream as it's too large to hold in memory. Could you solve it efficiently?\n\n<!--more-->\n\nThis is a problem from Leetcode week contest, AKA No.487. And I think it is a DP problem.\n\nFirst, I find a bad idea, I try to combine the nums like:\n```\n1 0 1 1 0 1 => 1 0 2 0 1\n```\n\nAnd try to deal with the transformed array. But it is still a hard problem. So I think in the DP way. Because its number of situations is limited. So, I can use a two DP array to store the number currently.\n```\nnums: 1 0 1 1 0 1\nDP 1: 1 2 3 4 0 1\nDP 2: 1 0 1 2 3 4\n```\n\nBecause only four situation will happen. 0 -> 1, 1 -> 1, 0 -> 0, 1 -> 0.\n\nSo the solution is following:\n\n```\nclass Solution {\n    public:\n        int findMaxConsecutiveOnes(vector<int>& nums) {\n            if (nums.size() == 0) {\n                return 0;\n            }\n            int res = 0, flag = 0; // flag 0 represents up use the flip\n            vector<int> flags1(nums.size() + 1), flags2(nums.size() + 1);\n            flags1.push_back(0);\n            flags2.push_back(0);\n\n            for (int i = 0; i < (int)nums.size(); i++) {\n                if (nums[i] == 0) {\n                    if (flag == 0) {\n                        flag = 1;\n                        flags1[i+1] = flags1[i] + 1;\n                        flags2[i+1] = 0;\n                    } else {\n                        flag = 0;\n                        flags1[i+1] = 0;\n                        flags2[i+1] = flags2[i] + 1;\n                    }\n                } else {\n                    flags1[i+1] = flags1[i] + 1;\n                    flags2[i+1] = flags2[i] + 1;\n                }\n                res = max(res, max(flags1[i+1], flags2[i+1]));\n            }\n            return res;\n        }\n};\n```\n\nAnd it gets AC.\n","source":"_posts/MaxConsecutiveOnesII.md","raw":"---\ntitle: Max Consecutive Ones II\ndate: 2017-01-15 14:18:18\ntags:\n    - Dynamic Programming\n---\n\n> Given a binary array, find the maximum number of consecutive 1s in this array if you can flip at most one 0.\n>\n> Example 1:\n>\n> Input: [1,0,1,1,0]\n> Output: 4\n> Explanation: Flip the first zero will get the the maximum number of consecutive 1s.\n> > After flipping, the maximum number of consecutive 1s is 4.\n>\n> Note:\n> + The input array will only contain 0 and 1.\n> + The length of input array is a positive integer and will not exceed 10,000\n>\n> Follow up:\n> What if the input numbers come in one by one as an infinite stream? In other words, you can't store all numbers coming from the stream as it's too large to hold in memory. Could you solve it efficiently?\n\n<!--more-->\n\nThis is a problem from Leetcode week contest, AKA No.487. And I think it is a DP problem.\n\nFirst, I find a bad idea, I try to combine the nums like:\n```\n1 0 1 1 0 1 => 1 0 2 0 1\n```\n\nAnd try to deal with the transformed array. But it is still a hard problem. So I think in the DP way. Because its number of situations is limited. So, I can use a two DP array to store the number currently.\n```\nnums: 1 0 1 1 0 1\nDP 1: 1 2 3 4 0 1\nDP 2: 1 0 1 2 3 4\n```\n\nBecause only four situation will happen. 0 -> 1, 1 -> 1, 0 -> 0, 1 -> 0.\n\nSo the solution is following:\n\n```\nclass Solution {\n    public:\n        int findMaxConsecutiveOnes(vector<int>& nums) {\n            if (nums.size() == 0) {\n                return 0;\n            }\n            int res = 0, flag = 0; // flag 0 represents up use the flip\n            vector<int> flags1(nums.size() + 1), flags2(nums.size() + 1);\n            flags1.push_back(0);\n            flags2.push_back(0);\n\n            for (int i = 0; i < (int)nums.size(); i++) {\n                if (nums[i] == 0) {\n                    if (flag == 0) {\n                        flag = 1;\n                        flags1[i+1] = flags1[i] + 1;\n                        flags2[i+1] = 0;\n                    } else {\n                        flag = 0;\n                        flags1[i+1] = 0;\n                        flags2[i+1] = flags2[i] + 1;\n                    }\n                } else {\n                    flags1[i+1] = flags1[i] + 1;\n                    flags2[i+1] = flags2[i] + 1;\n                }\n                res = max(res, max(flags1[i+1], flags2[i+1]));\n            }\n            return res;\n        }\n};\n```\n\nAnd it gets AC.\n","slug":"MaxConsecutiveOnesII","published":1,"updated":"2017-01-15T06:31:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5qs000ypff4uxy5o544","content":"<blockquote>\n<p>Given a binary array, find the maximum number of consecutive 1s in this array if you can flip at most one 0.</p>\n<p>Example 1:</p>\n<p>Input: [1,0,1,1,0]<br>Output: 4<br>Explanation: Flip the first zero will get the the maximum number of consecutive 1s.</p>\n<blockquote>\n<p>After flipping, the maximum number of consecutive 1s is 4.</p>\n</blockquote>\n<p>Note:</p>\n<ul>\n<li>The input array will only contain 0 and 1.</li>\n<li>The length of input array is a positive integer and will not exceed 10,000</li>\n</ul>\n<p>Follow up:<br>What if the input numbers come in one by one as an infinite stream? In other words, you can’t store all numbers coming from the stream as it’s too large to hold in memory. Could you solve it efficiently?</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is a problem from Leetcode week contest, AKA No.487. And I think it is a DP problem.</p>\n<p>First, I find a bad idea, I try to combine the nums like:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">1 0 1 1 0 1 =&gt; 1 0 2 0 1</div></pre></td></tr></table></figure></p>\n<p>And try to deal with the transformed array. But it is still a hard problem. So I think in the DP way. Because its number of situations is limited. So, I can use a two DP array to store the number currently.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">nums: 1 0 1 1 0 1</div><div class=\"line\">DP 1: 1 2 3 4 0 1</div><div class=\"line\">DP 2: 1 0 1 2 3 4</div></pre></td></tr></table></figure></p>\n<p>Because only four situation will happen. 0 -&gt; 1, 1 -&gt; 1, 0 -&gt; 0, 1 -&gt; 0.</p>\n<p>So the solution is following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int res = 0, flag = 0; // flag 0 represents up use the flip</div><div class=\"line\">            vector&lt;int&gt; flags1(nums.size() + 1), flags2(nums.size() + 1);</div><div class=\"line\">            flags1.push_back(0);</div><div class=\"line\">            flags2.push_back(0);</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (nums[i] == 0) &#123;</div><div class=\"line\">                    if (flag == 0) &#123;</div><div class=\"line\">                        flag = 1;</div><div class=\"line\">                        flags1[i+1] = flags1[i] + 1;</div><div class=\"line\">                        flags2[i+1] = 0;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        flag = 0;</div><div class=\"line\">                        flags1[i+1] = 0;</div><div class=\"line\">                        flags2[i+1] = flags2[i] + 1;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    flags1[i+1] = flags1[i] + 1;</div><div class=\"line\">                    flags2[i+1] = flags2[i] + 1;</div><div class=\"line\">                &#125;</div><div class=\"line\">                res = max(res, max(flags1[i+1], flags2[i+1]));</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a binary array, find the maximum number of consecutive 1s in this array if you can flip at most one 0.</p>\n<p>Example 1:</p>\n<p>Input: [1,0,1,1,0]<br>Output: 4<br>Explanation: Flip the first zero will get the the maximum number of consecutive 1s.</p>\n<blockquote>\n<p>After flipping, the maximum number of consecutive 1s is 4.</p>\n</blockquote>\n<p>Note:</p>\n<ul>\n<li>The input array will only contain 0 and 1.</li>\n<li>The length of input array is a positive integer and will not exceed 10,000</li>\n</ul>\n<p>Follow up:<br>What if the input numbers come in one by one as an infinite stream? In other words, you can’t store all numbers coming from the stream as it’s too large to hold in memory. Could you solve it efficiently?</p>\n</blockquote>","more":"<p>This is a problem from Leetcode week contest, AKA No.487. And I think it is a DP problem.</p>\n<p>First, I find a bad idea, I try to combine the nums like:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">1 0 1 1 0 1 =&gt; 1 0 2 0 1</div></pre></td></tr></table></figure></p>\n<p>And try to deal with the transformed array. But it is still a hard problem. So I think in the DP way. Because its number of situations is limited. So, I can use a two DP array to store the number currently.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">nums: 1 0 1 1 0 1</div><div class=\"line\">DP 1: 1 2 3 4 0 1</div><div class=\"line\">DP 2: 1 0 1 2 3 4</div></pre></td></tr></table></figure></p>\n<p>Because only four situation will happen. 0 -&gt; 1, 1 -&gt; 1, 0 -&gt; 0, 1 -&gt; 0.</p>\n<p>So the solution is following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int res = 0, flag = 0; // flag 0 represents up use the flip</div><div class=\"line\">            vector&lt;int&gt; flags1(nums.size() + 1), flags2(nums.size() + 1);</div><div class=\"line\">            flags1.push_back(0);</div><div class=\"line\">            flags2.push_back(0);</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (nums[i] == 0) &#123;</div><div class=\"line\">                    if (flag == 0) &#123;</div><div class=\"line\">                        flag = 1;</div><div class=\"line\">                        flags1[i+1] = flags1[i] + 1;</div><div class=\"line\">                        flags2[i+1] = 0;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        flag = 0;</div><div class=\"line\">                        flags1[i+1] = 0;</div><div class=\"line\">                        flags2[i+1] = flags2[i] + 1;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    flags1[i+1] = flags1[i] + 1;</div><div class=\"line\">                    flags2[i+1] = flags2[i] + 1;</div><div class=\"line\">                &#125;</div><div class=\"line\">                res = max(res, max(flags1[i+1], flags2[i+1]));</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>"},{"title":"Maximum Product of Word Lengths","date":"2017-01-18T14:23:09.000Z","_content":"\n> Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.\n>\n> Example 1:\n>\n> + Given [\"abcw\", \"baz\", \"foo\", \"bar\", \"xtfn\", \"abcdef\"]\n> + Return 16 The two words can be \"abcw\", \"xtfn\".\n>\n> Example 2:\n>\n> + Given [\"a\", \"ab\", \"abc\", \"d\", \"cd\", \"bcd\", \"abcd\"]\n> + Return 4 The two words can be \"ab\", \"cd\".\n>\n> Example 3:\n>\n> + Given [\"a\", \"aa\", \"aaa\", \"aaaa\"]\n> + Return 0 No such pair of words.\n\n<!--more-->\n\nThis is Leetcode 318, and it is just a change from the common simulation problem(add some conditions).\n\nI just use the simplest method to get AC...\n\n```\nclass Solution {\n    public:\n        int maxProduct(vector<string>& words) {\n            if (words.size() == 0) {\n                return 0;\n            }\n            vector<bitset<26> > wordsets;\n            for (unsigned int i = 0; i < words.size(); i++) {\n                wordsets.push_back(bitset<26>());\n                for (unsigned int j = 0; j < words[i].length(); j++) {\n                    wordsets[i][words[i][j] - 'a'] = 1;\n                }\n            }\n\n            int result = 0;\n            for (unsigned int i = 0; i < words.size() - 1; i++) {\n                for (unsigned int j = i + 1; j < words.size(); j++) {\n                    bitset<26> res = wordsets[i] ^ wordsets[j];\n                    if (res.count() == wordsets[i].count() + wordsets[j].count()) {\n                        result = max(int(words[i].length() * words[j].length()), result);\n                    }\n                }\n            }\n            return result;\n        }\n};\n```\n\nThat's so easy...\n","source":"_posts/MaximumProductofWordLengths.md","raw":"---\ntitle: Maximum Product of Word Lengths\ndate: 2017-01-18 22:23:09\ntags:\n    - Bitmap\n---\n\n> Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.\n>\n> Example 1:\n>\n> + Given [\"abcw\", \"baz\", \"foo\", \"bar\", \"xtfn\", \"abcdef\"]\n> + Return 16 The two words can be \"abcw\", \"xtfn\".\n>\n> Example 2:\n>\n> + Given [\"a\", \"ab\", \"abc\", \"d\", \"cd\", \"bcd\", \"abcd\"]\n> + Return 4 The two words can be \"ab\", \"cd\".\n>\n> Example 3:\n>\n> + Given [\"a\", \"aa\", \"aaa\", \"aaaa\"]\n> + Return 0 No such pair of words.\n\n<!--more-->\n\nThis is Leetcode 318, and it is just a change from the common simulation problem(add some conditions).\n\nI just use the simplest method to get AC...\n\n```\nclass Solution {\n    public:\n        int maxProduct(vector<string>& words) {\n            if (words.size() == 0) {\n                return 0;\n            }\n            vector<bitset<26> > wordsets;\n            for (unsigned int i = 0; i < words.size(); i++) {\n                wordsets.push_back(bitset<26>());\n                for (unsigned int j = 0; j < words[i].length(); j++) {\n                    wordsets[i][words[i][j] - 'a'] = 1;\n                }\n            }\n\n            int result = 0;\n            for (unsigned int i = 0; i < words.size() - 1; i++) {\n                for (unsigned int j = i + 1; j < words.size(); j++) {\n                    bitset<26> res = wordsets[i] ^ wordsets[j];\n                    if (res.count() == wordsets[i].count() + wordsets[j].count()) {\n                        result = max(int(words[i].length() * words[j].length()), result);\n                    }\n                }\n            }\n            return result;\n        }\n};\n```\n\nThat's so easy...\n","slug":"MaximumProductofWordLengths","published":1,"updated":"2017-01-27T14:08:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5qt0010pff4duxx9tal","content":"<blockquote>\n<p>Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.</p>\n<p>Example 1:</p>\n<ul>\n<li>Given [“abcw”, “baz”, “foo”, “bar”, “xtfn”, “abcdef”]</li>\n<li>Return 16 The two words can be “abcw”, “xtfn”.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Given [“a”, “ab”, “abc”, “d”, “cd”, “bcd”, “abcd”]</li>\n<li>Return 4 The two words can be “ab”, “cd”.</li>\n</ul>\n<p>Example 3:</p>\n<ul>\n<li>Given [“a”, “aa”, “aaa”, “aaaa”]</li>\n<li>Return 0 No such pair of words.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 318, and it is just a change from the common simulation problem(add some conditions).</p>\n<p>I just use the simplest method to get AC…</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int maxProduct(vector&lt;string&gt;&amp; words) &#123;</div><div class=\"line\">            if (words.size() == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">            vector&lt;bitset&lt;26&gt; &gt; wordsets;</div><div class=\"line\">            for (unsigned int i = 0; i &lt; words.size(); i++) &#123;</div><div class=\"line\">                wordsets.push_back(bitset&lt;26&gt;());</div><div class=\"line\">                for (unsigned int j = 0; j &lt; words[i].length(); j++) &#123;</div><div class=\"line\">                    wordsets[i][words[i][j] - &apos;a&apos;] = 1;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int result = 0;</div><div class=\"line\">            for (unsigned int i = 0; i &lt; words.size() - 1; i++) &#123;</div><div class=\"line\">                for (unsigned int j = i + 1; j &lt; words.size(); j++) &#123;</div><div class=\"line\">                    bitset&lt;26&gt; res = wordsets[i] ^ wordsets[j];</div><div class=\"line\">                    if (res.count() == wordsets[i].count() + wordsets[j].count()) &#123;</div><div class=\"line\">                        result = max(int(words[i].length() * words[j].length()), result);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return result;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>That’s so easy…</p>\n","excerpt":"<blockquote>\n<p>Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.</p>\n<p>Example 1:</p>\n<ul>\n<li>Given [“abcw”, “baz”, “foo”, “bar”, “xtfn”, “abcdef”]</li>\n<li>Return 16 The two words can be “abcw”, “xtfn”.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Given [“a”, “ab”, “abc”, “d”, “cd”, “bcd”, “abcd”]</li>\n<li>Return 4 The two words can be “ab”, “cd”.</li>\n</ul>\n<p>Example 3:</p>\n<ul>\n<li>Given [“a”, “aa”, “aaa”, “aaaa”]</li>\n<li>Return 0 No such pair of words.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 318, and it is just a change from the common simulation problem(add some conditions).</p>\n<p>I just use the simplest method to get AC…</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int maxProduct(vector&lt;string&gt;&amp; words) &#123;</div><div class=\"line\">            if (words.size() == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">            vector&lt;bitset&lt;26&gt; &gt; wordsets;</div><div class=\"line\">            for (unsigned int i = 0; i &lt; words.size(); i++) &#123;</div><div class=\"line\">                wordsets.push_back(bitset&lt;26&gt;());</div><div class=\"line\">                for (unsigned int j = 0; j &lt; words[i].length(); j++) &#123;</div><div class=\"line\">                    wordsets[i][words[i][j] - &apos;a&apos;] = 1;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int result = 0;</div><div class=\"line\">            for (unsigned int i = 0; i &lt; words.size() - 1; i++) &#123;</div><div class=\"line\">                for (unsigned int j = i + 1; j &lt; words.size(); j++) &#123;</div><div class=\"line\">                    bitset&lt;26&gt; res = wordsets[i] ^ wordsets[j];</div><div class=\"line\">                    if (res.count() == wordsets[i].count() + wordsets[j].count()) &#123;</div><div class=\"line\">                        result = max(int(words[i].length() * words[j].length()), result);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return result;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>That’s so easy…</p>"},{"title":"Minimum Moves to Equal Array Elements II","date":"2017-01-26T14:41:39.000Z","_content":"\n> Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.\n>\n> You may assume the array's length is at most 10,000.\n>\n> Example:\n> + Input: [1,2,3]\n>\n> + Output: 2\n>\n> + Explanation: Only two moves are needed (remember each move increments or decrements one element):\n>  > [1,2,3]  =>  [2,2,3]  =>  [2,2,2]\n\n<!--more-->\n\nThis is Leetcode 462, it is a fun problem. You can quick find a solution by using hashmap to store the number and its appearance times and calculate the result one by one.\n\nBut, it's actually a Math problem, you can find the min result always is the mid one.\n\nSo, here comes a solution:\n\n```\nclass Solution {\n    public:\n        int minMoves2(vector<int>& nums) {\n            int res = 0;\n            sort(nums.begin(), nums.end());\n            int standard = nums[nums.size() / 2];\n            for (int i = 0; i < (int)nums.size(); i++) {\n                res = res + abs(nums[i] - standard);\n            }\n            return res;\n        }\n};\n```\n\nAnd it gets AC.\n","source":"_posts/MinimumMovestoEqualArrayElementsII.md","raw":"---\ntitle: Minimum Moves to Equal Array Elements II\ndate: 2017-01-26 22:41:39\ntags:\n    - Math\n---\n\n> Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.\n>\n> You may assume the array's length is at most 10,000.\n>\n> Example:\n> + Input: [1,2,3]\n>\n> + Output: 2\n>\n> + Explanation: Only two moves are needed (remember each move increments or decrements one element):\n>  > [1,2,3]  =>  [2,2,3]  =>  [2,2,2]\n\n<!--more-->\n\nThis is Leetcode 462, it is a fun problem. You can quick find a solution by using hashmap to store the number and its appearance times and calculate the result one by one.\n\nBut, it's actually a Math problem, you can find the min result always is the mid one.\n\nSo, here comes a solution:\n\n```\nclass Solution {\n    public:\n        int minMoves2(vector<int>& nums) {\n            int res = 0;\n            sort(nums.begin(), nums.end());\n            int standard = nums[nums.size() / 2];\n            for (int i = 0; i < (int)nums.size(); i++) {\n                res = res + abs(nums[i] - standard);\n            }\n            return res;\n        }\n};\n```\n\nAnd it gets AC.\n","slug":"MinimumMovestoEqualArrayElementsII","published":1,"updated":"2017-01-26T14:52:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5qw0013pff4wlbodbgd","content":"<blockquote>\n<p>Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.</p>\n<p>You may assume the array’s length is at most 10,000.</p>\n<p>Example:</p>\n<ul>\n<li><p>Input: [1,2,3]</p>\n</li>\n<li><p>Output: 2</p>\n</li>\n<li><p>Explanation: Only two moves are needed (remember each move increments or decrements one element):</p>\n<blockquote>\n<p>[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 462, it is a fun problem. You can quick find a solution by using hashmap to store the number and its appearance times and calculate the result one by one.</p>\n<p>But, it’s actually a Math problem, you can find the min result always is the mid one.</p>\n<p>So, here comes a solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int minMoves2(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            sort(nums.begin(), nums.end());</div><div class=\"line\">            int standard = nums[nums.size() / 2];</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                res = res + abs(nums[i] - standard);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.</p>\n<p>You may assume the array’s length is at most 10,000.</p>\n<p>Example:</p>\n<ul>\n<li><p>Input: [1,2,3]</p>\n</li>\n<li><p>Output: 2</p>\n</li>\n<li><p>Explanation: Only two moves are needed (remember each move increments or decrements one element):</p>\n<blockquote>\n<p>[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 462, it is a fun problem. You can quick find a solution by using hashmap to store the number and its appearance times and calculate the result one by one.</p>\n<p>But, it’s actually a Math problem, you can find the min result always is the mid one.</p>\n<p>So, here comes a solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int minMoves2(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            sort(nums.begin(), nums.end());</div><div class=\"line\">            int standard = nums[nums.size() / 2];</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                res = res + abs(nums[i] - standard);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>"},{"title":"New Start","date":"2017-01-01T05:46:25.000Z","_content":"\nAs I promised before. I will write blogs in two languages. And here, I will use English to write about my oj games in order to improve my interview skills.\n\n<!--more-->\n","source":"_posts/NewStart.md","raw":"---\ntitle: New Start\ndate: 2017-01-01 13:46:25\ntags: \n    - Description\n---\n\nAs I promised before. I will write blogs in two languages. And here, I will use English to write about my oj games in order to improve my interview skills.\n\n<!--more-->\n","slug":"NewStart","published":1,"updated":"2017-01-03T06:47:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5qx0014pff46r3ybbp7","content":"<p>As I promised before. I will write blogs in two languages. And here, I will use English to write about my oj games in order to improve my interview skills.</p>\n<a id=\"more\"></a>\n","excerpt":"<p>As I promised before. I will write blogs in two languages. And here, I will use English to write about my oj games in order to improve my interview skills.</p>","more":""},{"title":"Most Frequent Subtree Sum","date":"2017-02-07T01:23:57.000Z","_content":"\n> Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.\n>\n> Examples 1\n> + Input:\n>\n>         5\n>        /  \\\n>       2   -3\n>\n> + return [2, -3, 4], since all the values happen only once, return all of them in any order.\n>\n> Examples 2\n> + Input:\n>\n>         5\n>        /  \\\n>       2   -5\n>\n> + return [2], since 2 happens twice, however -5 only occur once.\n>\n> Note: You may assume the sum of values in any subtree is in the range of 32-bit signed integer.\n\n<!--more-->\n\nThis is Leetcode 508, and it is a standard problem based on Tree. We just need to mark the last condition of the subTree.\n\nSo, the code is as following:\n\n```\nclass Solution {\n    map<int, int> nodes;\n    public:\n        vector<int> findFrequentTreeSum(TreeNode* root) {\n            nodes.clear();\n            _visit(root);\n\n            int maxTimes = INT_MIN;\n            for (auto i : nodes) {\n                if (i.second > maxTimes) {\n                    maxTimes = i.second;\n                }\n            }\n\n            vector<int> res;\n            for (auto i : nodes) {\n                if (i.second == maxTimes) {\n                    res.push_back(i.first);\n                }\n            }\n\n            return res;\n        }\n\n        int _visit(TreeNode* currentNode) {\n            if (currentNode == NULL) {\n                return 0;\n            }\n\n            if (currentNode->left == NULL && currentNode->right == NULL) {\n                _record(currentNode->val);\n                return currentNode->val;\n            }\n\n            if (currentNode->left != NULL && currentNode->right == NULL) {\n                int value = currentNode->val + _visit(currentNode->left);\n                _record(value);\n                return value;\n            }\n\n            if (currentNode->left == NULL && currentNode->right != NULL) {\n                int value = currentNode->val + _visit(currentNode->right);\n                _record(value);\n                return value;\n            }\n\n            if (currentNode->left != NULL && currentNode->right != NULL) {\n                int value = currentNode->val + _visit(currentNode->left) + _visit(currentNode->right);\n                _record(value);\n                return value;\n            }\n\n            return 0;\n        }\n\n        void _record(int value) {\n            if (nodes.find(value) != nodes.end()) {\n                nodes.find(value)->second++;\n            } else {\n                nodes.insert(pair<int, int>(value, 1));\n            }\n        }\n};\n```\n\nDone, it gets AC.\n","source":"_posts/MostFrequentSubtreeSum.md","raw":"---\ntitle: Most Frequent Subtree Sum\ndate: 2017-02-07 09:23:57\ntags:\n    - Tree\n    - Hash Table\n---\n\n> Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.\n>\n> Examples 1\n> + Input:\n>\n>         5\n>        /  \\\n>       2   -3\n>\n> + return [2, -3, 4], since all the values happen only once, return all of them in any order.\n>\n> Examples 2\n> + Input:\n>\n>         5\n>        /  \\\n>       2   -5\n>\n> + return [2], since 2 happens twice, however -5 only occur once.\n>\n> Note: You may assume the sum of values in any subtree is in the range of 32-bit signed integer.\n\n<!--more-->\n\nThis is Leetcode 508, and it is a standard problem based on Tree. We just need to mark the last condition of the subTree.\n\nSo, the code is as following:\n\n```\nclass Solution {\n    map<int, int> nodes;\n    public:\n        vector<int> findFrequentTreeSum(TreeNode* root) {\n            nodes.clear();\n            _visit(root);\n\n            int maxTimes = INT_MIN;\n            for (auto i : nodes) {\n                if (i.second > maxTimes) {\n                    maxTimes = i.second;\n                }\n            }\n\n            vector<int> res;\n            for (auto i : nodes) {\n                if (i.second == maxTimes) {\n                    res.push_back(i.first);\n                }\n            }\n\n            return res;\n        }\n\n        int _visit(TreeNode* currentNode) {\n            if (currentNode == NULL) {\n                return 0;\n            }\n\n            if (currentNode->left == NULL && currentNode->right == NULL) {\n                _record(currentNode->val);\n                return currentNode->val;\n            }\n\n            if (currentNode->left != NULL && currentNode->right == NULL) {\n                int value = currentNode->val + _visit(currentNode->left);\n                _record(value);\n                return value;\n            }\n\n            if (currentNode->left == NULL && currentNode->right != NULL) {\n                int value = currentNode->val + _visit(currentNode->right);\n                _record(value);\n                return value;\n            }\n\n            if (currentNode->left != NULL && currentNode->right != NULL) {\n                int value = currentNode->val + _visit(currentNode->left) + _visit(currentNode->right);\n                _record(value);\n                return value;\n            }\n\n            return 0;\n        }\n\n        void _record(int value) {\n            if (nodes.find(value) != nodes.end()) {\n                nodes.find(value)->second++;\n            } else {\n                nodes.insert(pair<int, int>(value, 1));\n            }\n        }\n};\n```\n\nDone, it gets AC.\n","slug":"MostFrequentSubtreeSum","published":1,"updated":"2017-02-07T02:00:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5qz0016pff4006p805t","content":"<blockquote>\n<p>Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.</p>\n<p>Examples 1</p>\n<ul>\n<li><p>Input:</p>\n<pre><code>  5\n /  \\\n2   -3\n</code></pre></li>\n<li><p>return [2, -3, 4], since all the values happen only once, return all of them in any order.</p>\n</li>\n</ul>\n<p>Examples 2</p>\n<ul>\n<li><p>Input:</p>\n<pre><code>  5\n /  \\\n2   -5\n</code></pre></li>\n<li><p>return [2], since 2 happens twice, however -5 only occur once.</p>\n</li>\n</ul>\n<p>Note: You may assume the sum of values in any subtree is in the range of 32-bit signed integer.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 508, and it is a standard problem based on Tree. We just need to mark the last condition of the subTree.</p>\n<p>So, the code is as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    map&lt;int, int&gt; nodes;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; findFrequentTreeSum(TreeNode* root) &#123;</div><div class=\"line\">            nodes.clear();</div><div class=\"line\">            _visit(root);</div><div class=\"line\"></div><div class=\"line\">            int maxTimes = INT_MIN;</div><div class=\"line\">            for (auto i : nodes) &#123;</div><div class=\"line\">                if (i.second &gt; maxTimes) &#123;</div><div class=\"line\">                    maxTimes = i.second;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\">            for (auto i : nodes) &#123;</div><div class=\"line\">                if (i.second == maxTimes) &#123;</div><div class=\"line\">                    res.push_back(i.first);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int _visit(TreeNode* currentNode) &#123;</div><div class=\"line\">            if (currentNode == NULL) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (currentNode-&gt;left == NULL &amp;&amp; currentNode-&gt;right == NULL) &#123;</div><div class=\"line\">                _record(currentNode-&gt;val);</div><div class=\"line\">                return currentNode-&gt;val;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (currentNode-&gt;left != NULL &amp;&amp; currentNode-&gt;right == NULL) &#123;</div><div class=\"line\">                int value = currentNode-&gt;val + _visit(currentNode-&gt;left);</div><div class=\"line\">                _record(value);</div><div class=\"line\">                return value;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (currentNode-&gt;left == NULL &amp;&amp; currentNode-&gt;right != NULL) &#123;</div><div class=\"line\">                int value = currentNode-&gt;val + _visit(currentNode-&gt;right);</div><div class=\"line\">                _record(value);</div><div class=\"line\">                return value;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (currentNode-&gt;left != NULL &amp;&amp; currentNode-&gt;right != NULL) &#123;</div><div class=\"line\">                int value = currentNode-&gt;val + _visit(currentNode-&gt;left) + _visit(currentNode-&gt;right);</div><div class=\"line\">                _record(value);</div><div class=\"line\">                return value;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return 0;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _record(int value) &#123;</div><div class=\"line\">            if (nodes.find(value) != nodes.end()) &#123;</div><div class=\"line\">                nodes.find(value)-&gt;second++;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                nodes.insert(pair&lt;int, int&gt;(value, 1));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Done, it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.</p>\n<p>Examples 1</p>\n<ul>\n<li><p>Input:</p>\n<pre><code>  5\n /  \\\n2   -3\n</code></pre></li>\n<li><p>return [2, -3, 4], since all the values happen only once, return all of them in any order.</p>\n</li>\n</ul>\n<p>Examples 2</p>\n<ul>\n<li><p>Input:</p>\n<pre><code>  5\n /  \\\n2   -5\n</code></pre></li>\n<li><p>return [2], since 2 happens twice, however -5 only occur once.</p>\n</li>\n</ul>\n<p>Note: You may assume the sum of values in any subtree is in the range of 32-bit signed integer.</p>\n</blockquote>","more":"<p>This is Leetcode 508, and it is a standard problem based on Tree. We just need to mark the last condition of the subTree.</p>\n<p>So, the code is as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    map&lt;int, int&gt; nodes;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; findFrequentTreeSum(TreeNode* root) &#123;</div><div class=\"line\">            nodes.clear();</div><div class=\"line\">            _visit(root);</div><div class=\"line\"></div><div class=\"line\">            int maxTimes = INT_MIN;</div><div class=\"line\">            for (auto i : nodes) &#123;</div><div class=\"line\">                if (i.second &gt; maxTimes) &#123;</div><div class=\"line\">                    maxTimes = i.second;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\">            for (auto i : nodes) &#123;</div><div class=\"line\">                if (i.second == maxTimes) &#123;</div><div class=\"line\">                    res.push_back(i.first);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int _visit(TreeNode* currentNode) &#123;</div><div class=\"line\">            if (currentNode == NULL) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (currentNode-&gt;left == NULL &amp;&amp; currentNode-&gt;right == NULL) &#123;</div><div class=\"line\">                _record(currentNode-&gt;val);</div><div class=\"line\">                return currentNode-&gt;val;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (currentNode-&gt;left != NULL &amp;&amp; currentNode-&gt;right == NULL) &#123;</div><div class=\"line\">                int value = currentNode-&gt;val + _visit(currentNode-&gt;left);</div><div class=\"line\">                _record(value);</div><div class=\"line\">                return value;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (currentNode-&gt;left == NULL &amp;&amp; currentNode-&gt;right != NULL) &#123;</div><div class=\"line\">                int value = currentNode-&gt;val + _visit(currentNode-&gt;right);</div><div class=\"line\">                _record(value);</div><div class=\"line\">                return value;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (currentNode-&gt;left != NULL &amp;&amp; currentNode-&gt;right != NULL) &#123;</div><div class=\"line\">                int value = currentNode-&gt;val + _visit(currentNode-&gt;left) + _visit(currentNode-&gt;right);</div><div class=\"line\">                _record(value);</div><div class=\"line\">                return value;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return 0;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _record(int value) &#123;</div><div class=\"line\">            if (nodes.find(value) != nodes.end()) &#123;</div><div class=\"line\">                nodes.find(value)-&gt;second++;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                nodes.insert(pair&lt;int, int&gt;(value, 1));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Done, it gets AC.</p>"},{"title":"Next Greater Element I","date":"2017-02-05T06:24:59.000Z","_content":"\n\n> You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2.\n>\n> The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.\n>\n> Example 1:\n> + Input: nums1 = [4,1,2], nums2 = [1,3,4,2].\n> + Output: [-1,3,-1]\n> + Explanation:\n>     + For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.\n>     + For number 1 in the first array, the next greater number for it in the second array is 3.\n>     + For number 2 in the first array, there is no next greater number for it in the second array, so output -1.\n>\n> Example 2:\n> + Input: nums1 = [2,4], nums2 = [1,2,3,4].\n> + Output: [3,-1]\n> + Explanation:\n>     + For number 2 in the first array, the next greater number for it in the second array is 3.\n>     + For number 4 in the first array, there is no next greater number for it in the second array, so output -1.\n>\n> Note:\n> + All elements in nums1 and nums2 are unique.\n> + The length of both nums1 and nums2 would not exceed 1000.\n\n<!--more-->\n\nThis is Leetcode 496, and it is leetcode weekly contest in this week. Such an easy problem.\n\n```\nclass Solution {\n    public:\n        vector<int> nextGreaterElement(vector<int>& findNums, vector<int>& nums) {\n            vector<int> res;\n            for (int i = 0; i < (int)findNums.size(); i++) {\n                int standard = -1;\n                bool isOk = false;\n                for (int j = 0; j < (int)nums.size(); j++) {\n                    if (findNums[i] == nums[j]) {\n                        standard = j;\n                    }\n                    if (standard != -1 && j > standard && nums[j] > findNums[i]) {\n                        res.push_back(nums[j]);\n                        isOk = true;\n                        break;\n                    }\n                }\n                if (!isOk) {\n                    res.push_back(-1);\n                }\n            }\n            return res;\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/NextGreaterElementI.md","raw":"---\ntitle: Next Greater Element I\ndate: 2017-02-05 14:24:59\ntags:\n    - Array\n---\n\n\n> You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2.\n>\n> The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.\n>\n> Example 1:\n> + Input: nums1 = [4,1,2], nums2 = [1,3,4,2].\n> + Output: [-1,3,-1]\n> + Explanation:\n>     + For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.\n>     + For number 1 in the first array, the next greater number for it in the second array is 3.\n>     + For number 2 in the first array, there is no next greater number for it in the second array, so output -1.\n>\n> Example 2:\n> + Input: nums1 = [2,4], nums2 = [1,2,3,4].\n> + Output: [3,-1]\n> + Explanation:\n>     + For number 2 in the first array, the next greater number for it in the second array is 3.\n>     + For number 4 in the first array, there is no next greater number for it in the second array, so output -1.\n>\n> Note:\n> + All elements in nums1 and nums2 are unique.\n> + The length of both nums1 and nums2 would not exceed 1000.\n\n<!--more-->\n\nThis is Leetcode 496, and it is leetcode weekly contest in this week. Such an easy problem.\n\n```\nclass Solution {\n    public:\n        vector<int> nextGreaterElement(vector<int>& findNums, vector<int>& nums) {\n            vector<int> res;\n            for (int i = 0; i < (int)findNums.size(); i++) {\n                int standard = -1;\n                bool isOk = false;\n                for (int j = 0; j < (int)nums.size(); j++) {\n                    if (findNums[i] == nums[j]) {\n                        standard = j;\n                    }\n                    if (standard != -1 && j > standard && nums[j] > findNums[i]) {\n                        res.push_back(nums[j]);\n                        isOk = true;\n                        break;\n                    }\n                }\n                if (!isOk) {\n                    res.push_back(-1);\n                }\n            }\n            return res;\n        }\n};\n```\n\nIt gets AC.\n","slug":"NextGreaterElementI","published":1,"updated":"2017-02-05T06:27:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5r30017pff42s3ywqeo","content":"<blockquote>\n<p>You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1’s elements in the corresponding places of nums2.</p>\n<p>The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: nums1 = [4,1,2], nums2 = [1,3,4,2].</li>\n<li>Output: [-1,3,-1]</li>\n<li>Explanation:<ul>\n<li>For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.</li>\n<li>For number 1 in the first array, the next greater number for it in the second array is 3.</li>\n<li>For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</li>\n</ul>\n</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: nums1 = [2,4], nums2 = [1,2,3,4].</li>\n<li>Output: [3,-1]</li>\n<li>Explanation:<ul>\n<li>For number 2 in the first array, the next greater number for it in the second array is 3.</li>\n<li>For number 4 in the first array, there is no next greater number for it in the second array, so output -1.</li>\n</ul>\n</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>All elements in nums1 and nums2 are unique.</li>\n<li>The length of both nums1 and nums2 would not exceed 1000.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 496, and it is leetcode weekly contest in this week. Such an easy problem.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; findNums, vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\">            for (int i = 0; i &lt; (int)findNums.size(); i++) &#123;</div><div class=\"line\">                int standard = -1;</div><div class=\"line\">                bool isOk = false;</div><div class=\"line\">                for (int j = 0; j &lt; (int)nums.size(); j++) &#123;</div><div class=\"line\">                    if (findNums[i] == nums[j]) &#123;</div><div class=\"line\">                        standard = j;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    if (standard != -1 &amp;&amp; j &gt; standard &amp;&amp; nums[j] &gt; findNums[i]) &#123;</div><div class=\"line\">                        res.push_back(nums[j]);</div><div class=\"line\">                        isOk = true;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (!isOk) &#123;</div><div class=\"line\">                    res.push_back(-1);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1’s elements in the corresponding places of nums2.</p>\n<p>The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: nums1 = [4,1,2], nums2 = [1,3,4,2].</li>\n<li>Output: [-1,3,-1]</li>\n<li>Explanation:<ul>\n<li>For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.</li>\n<li>For number 1 in the first array, the next greater number for it in the second array is 3.</li>\n<li>For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</li>\n</ul>\n</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: nums1 = [2,4], nums2 = [1,2,3,4].</li>\n<li>Output: [3,-1]</li>\n<li>Explanation:<ul>\n<li>For number 2 in the first array, the next greater number for it in the second array is 3.</li>\n<li>For number 4 in the first array, there is no next greater number for it in the second array, so output -1.</li>\n</ul>\n</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>All elements in nums1 and nums2 are unique.</li>\n<li>The length of both nums1 and nums2 would not exceed 1000.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 496, and it is leetcode weekly contest in this week. Such an easy problem.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; findNums, vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\">            for (int i = 0; i &lt; (int)findNums.size(); i++) &#123;</div><div class=\"line\">                int standard = -1;</div><div class=\"line\">                bool isOk = false;</div><div class=\"line\">                for (int j = 0; j &lt; (int)nums.size(); j++) &#123;</div><div class=\"line\">                    if (findNums[i] == nums[j]) &#123;</div><div class=\"line\">                        standard = j;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    if (standard != -1 &amp;&amp; j &gt; standard &amp;&amp; nums[j] &gt; findNums[i]) &#123;</div><div class=\"line\">                        res.push_back(nums[j]);</div><div class=\"line\">                        isOk = true;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (!isOk) &#123;</div><div class=\"line\">                    res.push_back(-1);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Number Complement","date":"2017-01-24T15:33:22.000Z","_content":"\n> Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.\n>\n> Note:\n>\n>   + The given integer is guaranteed to fit within the range of a 32-bit signed integer.\n>   + You could assume no leading zero bit in the integer’s binary representation.\n>\n> Example 1:\n> + Input: 5 Output: 2\n> + Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\n>\n> Example 2:\n> + Input: 1 Output: 0\n> + Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\n\n<!--more-->\n\nThis is Leetcode 476. Easy problem. But here are many solutions.\n\nYou can divide the num by 2 and find the 1 bit and sum on the other hand.\n\nIt may cost O(logN) time complex.\n\nBut here I use another way:\n\n```\nclass Solution {\n    public:\n        int findComplement(int num) {\n            int level = 0;\n            while (pow(2, level) <= num) {\n                level++;\n            }\n            return (int)(pow(2, level) - 1) ^ num;\n        }\n};\n```\n\nYou can find that 0x101 ^ 0x111 = 0x010\n\nSo, That's what I use. And it gets AC.\n","source":"_posts/NumberComplement.md","raw":"---\ntitle: Number Complement\ndate: 2017-01-24 23:33:22\ntags:\n    - Bitmap\n---\n\n> Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.\n>\n> Note:\n>\n>   + The given integer is guaranteed to fit within the range of a 32-bit signed integer.\n>   + You could assume no leading zero bit in the integer’s binary representation.\n>\n> Example 1:\n> + Input: 5 Output: 2\n> + Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\n>\n> Example 2:\n> + Input: 1 Output: 0\n> + Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\n\n<!--more-->\n\nThis is Leetcode 476. Easy problem. But here are many solutions.\n\nYou can divide the num by 2 and find the 1 bit and sum on the other hand.\n\nIt may cost O(logN) time complex.\n\nBut here I use another way:\n\n```\nclass Solution {\n    public:\n        int findComplement(int num) {\n            int level = 0;\n            while (pow(2, level) <= num) {\n                level++;\n            }\n            return (int)(pow(2, level) - 1) ^ num;\n        }\n};\n```\n\nYou can find that 0x101 ^ 0x111 = 0x010\n\nSo, That's what I use. And it gets AC.\n","slug":"NumberComplement","published":1,"updated":"2017-01-24T15:51:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5r50019pff4jkomcw9z","content":"<blockquote>\n<p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>\n<p>Note:</p>\n<ul>\n<li>The given integer is guaranteed to fit within the range of a 32-bit signed integer.</li>\n<li>You could assume no leading zero bit in the integer’s binary representation.</li>\n</ul>\n<p>Example 1:</p>\n<ul>\n<li>Input: 5 Output: 2</li>\n<li>Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: 1 Output: 0</li>\n<li>Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 476. Easy problem. But here are many solutions.</p>\n<p>You can divide the num by 2 and find the 1 bit and sum on the other hand.</p>\n<p>It may cost O(logN) time complex.</p>\n<p>But here I use another way:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findComplement(int num) &#123;</div><div class=\"line\">            int level = 0;</div><div class=\"line\">            while (pow(2, level) &lt;= num) &#123;</div><div class=\"line\">                level++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return (int)(pow(2, level) - 1) ^ num;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>You can find that 0x101 ^ 0x111 = 0x010</p>\n<p>So, That’s what I use. And it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>\n<p>Note:</p>\n<ul>\n<li>The given integer is guaranteed to fit within the range of a 32-bit signed integer.</li>\n<li>You could assume no leading zero bit in the integer’s binary representation.</li>\n</ul>\n<p>Example 1:</p>\n<ul>\n<li>Input: 5 Output: 2</li>\n<li>Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: 1 Output: 0</li>\n<li>Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 476. Easy problem. But here are many solutions.</p>\n<p>You can divide the num by 2 and find the 1 bit and sum on the other hand.</p>\n<p>It may cost O(logN) time complex.</p>\n<p>But here I use another way:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findComplement(int num) &#123;</div><div class=\"line\">            int level = 0;</div><div class=\"line\">            while (pow(2, level) &lt;= num) &#123;</div><div class=\"line\">                level++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return (int)(pow(2, level) - 1) ^ num;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>You can find that 0x101 ^ 0x111 = 0x010</p>\n<p>So, That’s what I use. And it gets AC.</p>"},{"title":"Ones and Zeroes","date":"2017-01-20T15:51:54.000Z","_content":"\n> In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.\n>\n> For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.\n>\n> Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.\n>\n> Note:\n> + The given numbers of 0s and 1s will both not exceed 100\n> + The size of given string array won't exceed 600.\n>\n> Example 1:\n> + Input: Array = {\"10\", \"0001\", \"111001\", \"1\", \"0\"}, m = 5, n = 3;\n> + Output: 4\n>\n> Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”\n>\n> Example 2:\n> + Input: Array = {\"10\", \"0\", \"1\"}, m = 1, n = 1\n> + Output: 2\n>\n> Explanation: You could form \"10\", but then you'd have nothing left. Better form \"0\" and \"1\".\n\n<!-- more -->\nThis is Leetcode 474. As a noraml DP problem, the most important thing is to find the relationship.\n\nIn this case, we can find the relationship:\n\nwe can use `m` 0s and `n` 1s to make the max(DP[x][y], DP[x-i][y-j] + 1) as `i` and `j` means how many 1s and 0s of the current num.\n\nWhat we should do next is to find the `m to x` and `n to y` to make sure we consider every conditions.\n\nSo, the solution is coming:\n\n```\nclass Solution {\n    public:\n        int findMaxForm(vector<string>& strs, int m, int n) {\n            int DP[600][600];\n            for (int i = 0; i < 600; i++) {\n                for (int j = 0; j < 600; j++) {\n                    DP[i][j] = 0;\n                }\n            }\n            for (int i = 0; i < (int)strs.size(); i++) {\n                int num0 = 0;\n                int num1 = 0;\n                for (int j = 0; j < (int)strs[i].length(); j++) {\n                    if (strs[i][j] == '0') {\n                        num0++;\n                    } else {\n                        num1++;\n                    }\n                }\n\n                for (int i = m; i >= num0; i--) {\n                    for (int j = n; j >= num1; j--) {\n                        DP[i][j] = max(DP[i][j], DP[i-num0][j-num1] + 1);\n                    }\n                }\n            }\n            return DP[m][n];\n        }\n};\n```\n","source":"_posts/OnesandZeroes.md","raw":"---\ntitle: Ones and Zeroes\ndate: 2017-01-20 23:51:54\ntags:\n    - Dynamic Programming\n---\n\n> In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.\n>\n> For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.\n>\n> Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.\n>\n> Note:\n> + The given numbers of 0s and 1s will both not exceed 100\n> + The size of given string array won't exceed 600.\n>\n> Example 1:\n> + Input: Array = {\"10\", \"0001\", \"111001\", \"1\", \"0\"}, m = 5, n = 3;\n> + Output: 4\n>\n> Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”\n>\n> Example 2:\n> + Input: Array = {\"10\", \"0\", \"1\"}, m = 1, n = 1\n> + Output: 2\n>\n> Explanation: You could form \"10\", but then you'd have nothing left. Better form \"0\" and \"1\".\n\n<!-- more -->\nThis is Leetcode 474. As a noraml DP problem, the most important thing is to find the relationship.\n\nIn this case, we can find the relationship:\n\nwe can use `m` 0s and `n` 1s to make the max(DP[x][y], DP[x-i][y-j] + 1) as `i` and `j` means how many 1s and 0s of the current num.\n\nWhat we should do next is to find the `m to x` and `n to y` to make sure we consider every conditions.\n\nSo, the solution is coming:\n\n```\nclass Solution {\n    public:\n        int findMaxForm(vector<string>& strs, int m, int n) {\n            int DP[600][600];\n            for (int i = 0; i < 600; i++) {\n                for (int j = 0; j < 600; j++) {\n                    DP[i][j] = 0;\n                }\n            }\n            for (int i = 0; i < (int)strs.size(); i++) {\n                int num0 = 0;\n                int num1 = 0;\n                for (int j = 0; j < (int)strs[i].length(); j++) {\n                    if (strs[i][j] == '0') {\n                        num0++;\n                    } else {\n                        num1++;\n                    }\n                }\n\n                for (int i = m; i >= num0; i--) {\n                    for (int j = n; j >= num1; j--) {\n                        DP[i][j] = max(DP[i][j], DP[i-num0][j-num1] + 1);\n                    }\n                }\n            }\n            return DP[m][n];\n        }\n};\n```\n","slug":"OnesandZeroes","published":1,"updated":"2017-01-20T16:23:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5r7001bpff422yv22fr","content":"<blockquote>\n<p>In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.</p>\n<p>For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.</p>\n<p>Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.</p>\n<p>Note:</p>\n<ul>\n<li>The given numbers of 0s and 1s will both not exceed 100</li>\n<li>The size of given string array won’t exceed 600.</li>\n</ul>\n<p>Example 1:</p>\n<ul>\n<li>Input: Array = {“10”, “0001”, “111001”, “1”, “0”}, m = 5, n = 3;</li>\n<li>Output: 4</li>\n</ul>\n<p>Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”</p>\n<p>Example 2:</p>\n<ul>\n<li>Input: Array = {“10”, “0”, “1”}, m = 1, n = 1</li>\n<li>Output: 2</li>\n</ul>\n<p>Explanation: You could form “10”, but then you’d have nothing left. Better form “0” and “1”.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 474. As a noraml DP problem, the most important thing is to find the relationship.</p>\n<p>In this case, we can find the relationship:</p>\n<p>we can use <code>m</code> 0s and <code>n</code> 1s to make the max(DP[x][y], DP[x-i][y-j] + 1) as <code>i</code> and <code>j</code> means how many 1s and 0s of the current num.</p>\n<p>What we should do next is to find the <code>m to x</code> and <code>n to y</code> to make sure we consider every conditions.</p>\n<p>So, the solution is coming:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123;</div><div class=\"line\">            int DP[600][600];</div><div class=\"line\">            for (int i = 0; i &lt; 600; i++) &#123;</div><div class=\"line\">                for (int j = 0; j &lt; 600; j++) &#123;</div><div class=\"line\">                    DP[i][j] = 0;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = 0; i &lt; (int)strs.size(); i++) &#123;</div><div class=\"line\">                int num0 = 0;</div><div class=\"line\">                int num1 = 0;</div><div class=\"line\">                for (int j = 0; j &lt; (int)strs[i].length(); j++) &#123;</div><div class=\"line\">                    if (strs[i][j] == &apos;0&apos;) &#123;</div><div class=\"line\">                        num0++;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        num1++;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                for (int i = m; i &gt;= num0; i--) &#123;</div><div class=\"line\">                    for (int j = n; j &gt;= num1; j--) &#123;</div><div class=\"line\">                        DP[i][j] = max(DP[i][j], DP[i-num0][j-num1] + 1);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return DP[m][n];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n","excerpt":"<blockquote>\n<p>In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.</p>\n<p>For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.</p>\n<p>Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.</p>\n<p>Note:</p>\n<ul>\n<li>The given numbers of 0s and 1s will both not exceed 100</li>\n<li>The size of given string array won’t exceed 600.</li>\n</ul>\n<p>Example 1:</p>\n<ul>\n<li>Input: Array = {“10”, “0001”, “111001”, “1”, “0”}, m = 5, n = 3;</li>\n<li>Output: 4</li>\n</ul>\n<p>Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”</p>\n<p>Example 2:</p>\n<ul>\n<li>Input: Array = {“10”, “0”, “1”}, m = 1, n = 1</li>\n<li>Output: 2</li>\n</ul>\n<p>Explanation: You could form “10”, but then you’d have nothing left. Better form “0” and “1”.</p>\n</blockquote>","more":"<p>This is Leetcode 474. As a noraml DP problem, the most important thing is to find the relationship.</p>\n<p>In this case, we can find the relationship:</p>\n<p>we can use <code>m</code> 0s and <code>n</code> 1s to make the max(DP[x][y], DP[x-i][y-j] + 1) as <code>i</code> and <code>j</code> means how many 1s and 0s of the current num.</p>\n<p>What we should do next is to find the <code>m to x</code> and <code>n to y</code> to make sure we consider every conditions.</p>\n<p>So, the solution is coming:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123;</div><div class=\"line\">            int DP[600][600];</div><div class=\"line\">            for (int i = 0; i &lt; 600; i++) &#123;</div><div class=\"line\">                for (int j = 0; j &lt; 600; j++) &#123;</div><div class=\"line\">                    DP[i][j] = 0;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = 0; i &lt; (int)strs.size(); i++) &#123;</div><div class=\"line\">                int num0 = 0;</div><div class=\"line\">                int num1 = 0;</div><div class=\"line\">                for (int j = 0; j &lt; (int)strs[i].length(); j++) &#123;</div><div class=\"line\">                    if (strs[i][j] == &apos;0&apos;) &#123;</div><div class=\"line\">                        num0++;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        num1++;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                for (int i = m; i &gt;= num0; i--) &#123;</div><div class=\"line\">                    for (int j = n; j &gt;= num1; j--) &#123;</div><div class=\"line\">                        DP[i][j] = max(DP[i][j], DP[i-num0][j-num1] + 1);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return DP[m][n];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>"},{"title":"Partition Equal Subset Sum","date":"2017-01-06T05:46:25.000Z","_content":"\n> Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n>\n> Note:\n>\n> + Each of the array element will not exceed 100.\n> + The array size will not exceed 200.\n>\n> Example 1:\n>\n> Input: [1, 5, 11, 5]\n> Output: true\n>\n> Explanation: The array can be partitioned as [1, 5, 5] and [11].\n>\n> Example 2:\n>\n> Input: [1, 2, 3, 5]\n> Output: false\n>\n> Explanation: The array cannot be partitioned into equal sum subsets.\n\n<!-- more -->\n\nThis is Leetcode 416, and it is a leetweek problem. My last pass code like these:\n```\nclass Solution {\n    public:\n        bool canPartition(vector<int>& nums) {\n            if (nums.size() < 2) {\n                return false;\n            }\n            int sum = 0;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                sum = sum + nums[i];\n            }\n            if (sum % 2 != 0) {\n                return false;\n            }\n            return check(0, 0, nums, sum);\n        }\n\n        bool check(int start, int current, vector<int> nums, int sum) {\n            bool res = false;\n            if (current > sum / 2) {\n                return false;\n            }\n            if (current == sum / 2) {\n                return true;\n            }\n            for (int i = start + 1; i < (int)nums.size(); i++) {\n                res = res || check(i, current + nums[i], nums, sum);\n            }\n            return res;\n        }\n};\n```\nBecause the time complex of this recursive functoin is O(n!), the worst condition. So, we can change our mind to turn this problem into another one.\n\nFind a set of the subarray which its sum is sum / 2. And we can use the DP solution.\n\nBecause we know the sum of the array, so we make a array **dp** in size sum/2. And after a for loop. we will know the dp[num] and dp[sum/2 - num] can achieve. So, when we for twice, like:\n```\nfor (auto num : nums) {\n    for(int i = target; i >= num; i--) { // to be quick we don't visit the whole dp array\n        dp[i] = dp[i] || dp[i - num];\n    }\n}\n```\n\nSo, here comes a better solution based on DP:\n\n```\nusing namespace std;\nclass Solution {\n    public:\n        bool canPartition(vector<int>& nums) {\n            int sum = accumulate(nums.begin(), nums.end(), 0);\n            if (sum & 1) return false;\n            int half = sum >> 1;\n\n            vector<bool> accessibility(half + 1, false);\n            accessibility[0] = true;    // '0' is always reachable\n            //For all num in nums, check the accessibility from half - num to 0.\n            //If 'i' is accessible by former numbers, then 'i + num' is also accessible. (DP Algorithm)\n            for(int num: nums)\n                //Below here we must start from 'half' downto 'num', otherwise current 'num' might be multiply used.\n                //e.g.: If num == 2, then we will have 2, 4, 6... will all be accessible and lead to wrong answer.\n                for(int i = half; i >= num; i--){\n                    if (accessibility[i - num] == true){\n                        accessibility[i] = true;\n                    }\n                }\n            return accessibility[half];\n        }\n};\n```\n\nHowever it's space complex is O(n), so if you need a O(1) solution, I find a cool solution based on bitset.\n\n```\nbool canPartition(vector<int>& nums) {\n    bitset<5001> bits(1);\n    int sum = accumulate(nums.begin(), nums.end(), 0);\n    for (auto n : nums) bits |= bits << n;\n    return !(sum & 1) && bits[sum >> 1];\n}\n```\nWhy and how it works, remaining unknown.\n","source":"_posts/PartitionEqualSubsetSum.md","raw":"---\ntitle: Partition Equal Subset Sum\ndate: 2017-01-06 13:46:25\ntags:\n    - Dynamic Programming\n---\n\n> Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n>\n> Note:\n>\n> + Each of the array element will not exceed 100.\n> + The array size will not exceed 200.\n>\n> Example 1:\n>\n> Input: [1, 5, 11, 5]\n> Output: true\n>\n> Explanation: The array can be partitioned as [1, 5, 5] and [11].\n>\n> Example 2:\n>\n> Input: [1, 2, 3, 5]\n> Output: false\n>\n> Explanation: The array cannot be partitioned into equal sum subsets.\n\n<!-- more -->\n\nThis is Leetcode 416, and it is a leetweek problem. My last pass code like these:\n```\nclass Solution {\n    public:\n        bool canPartition(vector<int>& nums) {\n            if (nums.size() < 2) {\n                return false;\n            }\n            int sum = 0;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                sum = sum + nums[i];\n            }\n            if (sum % 2 != 0) {\n                return false;\n            }\n            return check(0, 0, nums, sum);\n        }\n\n        bool check(int start, int current, vector<int> nums, int sum) {\n            bool res = false;\n            if (current > sum / 2) {\n                return false;\n            }\n            if (current == sum / 2) {\n                return true;\n            }\n            for (int i = start + 1; i < (int)nums.size(); i++) {\n                res = res || check(i, current + nums[i], nums, sum);\n            }\n            return res;\n        }\n};\n```\nBecause the time complex of this recursive functoin is O(n!), the worst condition. So, we can change our mind to turn this problem into another one.\n\nFind a set of the subarray which its sum is sum / 2. And we can use the DP solution.\n\nBecause we know the sum of the array, so we make a array **dp** in size sum/2. And after a for loop. we will know the dp[num] and dp[sum/2 - num] can achieve. So, when we for twice, like:\n```\nfor (auto num : nums) {\n    for(int i = target; i >= num; i--) { // to be quick we don't visit the whole dp array\n        dp[i] = dp[i] || dp[i - num];\n    }\n}\n```\n\nSo, here comes a better solution based on DP:\n\n```\nusing namespace std;\nclass Solution {\n    public:\n        bool canPartition(vector<int>& nums) {\n            int sum = accumulate(nums.begin(), nums.end(), 0);\n            if (sum & 1) return false;\n            int half = sum >> 1;\n\n            vector<bool> accessibility(half + 1, false);\n            accessibility[0] = true;    // '0' is always reachable\n            //For all num in nums, check the accessibility from half - num to 0.\n            //If 'i' is accessible by former numbers, then 'i + num' is also accessible. (DP Algorithm)\n            for(int num: nums)\n                //Below here we must start from 'half' downto 'num', otherwise current 'num' might be multiply used.\n                //e.g.: If num == 2, then we will have 2, 4, 6... will all be accessible and lead to wrong answer.\n                for(int i = half; i >= num; i--){\n                    if (accessibility[i - num] == true){\n                        accessibility[i] = true;\n                    }\n                }\n            return accessibility[half];\n        }\n};\n```\n\nHowever it's space complex is O(n), so if you need a O(1) solution, I find a cool solution based on bitset.\n\n```\nbool canPartition(vector<int>& nums) {\n    bitset<5001> bits(1);\n    int sum = accumulate(nums.begin(), nums.end(), 0);\n    for (auto n : nums) bits |= bits << n;\n    return !(sum & 1) && bits[sum >> 1];\n}\n```\nWhy and how it works, remaining unknown.\n","slug":"PartitionEqualSubsetSum","published":1,"updated":"2017-01-13T03:10:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5r8001dpff4hn078qjo","content":"<blockquote>\n<p>Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>\n<p>Note:</p>\n<ul>\n<li>Each of the array element will not exceed 100.</li>\n<li>The array size will not exceed 200.</li>\n</ul>\n<p>Example 1:</p>\n<p>Input: [1, 5, 11, 5]<br>Output: true</p>\n<p>Explanation: The array can be partitioned as [1, 5, 5] and [11].</p>\n<p>Example 2:</p>\n<p>Input: [1, 2, 3, 5]<br>Output: false</p>\n<p>Explanation: The array cannot be partitioned into equal sum subsets.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 416, and it is a leetweek problem. My last pass code like these:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() &lt; 2) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int sum = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                sum = sum + nums[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (sum % 2 != 0) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return check(0, 0, nums, sum);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool check(int start, int current, vector&lt;int&gt; nums, int sum) &#123;</div><div class=\"line\">            bool res = false;</div><div class=\"line\">            if (current &gt; sum / 2) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (current == sum / 2) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = start + 1; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                res = res || check(i, current + nums[i], nums, sum);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>Because the time complex of this recursive functoin is O(n!), the worst condition. So, we can change our mind to turn this problem into another one.</p>\n<p>Find a set of the subarray which its sum is sum / 2. And we can use the DP solution.</p>\n<p>Because we know the sum of the array, so we make a array <strong>dp</strong> in size sum/2. And after a for loop. we will know the dp[num] and dp[sum/2 - num] can achieve. So, when we for twice, like:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (auto num : nums) &#123;</div><div class=\"line\">    for(int i = target; i &gt;= num; i--) &#123; // to be quick we don&apos;t visit the whole dp array</div><div class=\"line\">        dp[i] = dp[i] || dp[i - num];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>So, here comes a better solution based on DP:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            int sum = accumulate(nums.begin(), nums.end(), 0);</div><div class=\"line\">            if (sum &amp; 1) return false;</div><div class=\"line\">            int half = sum &gt;&gt; 1;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;bool&gt; accessibility(half + 1, false);</div><div class=\"line\">            accessibility[0] = true;    // &apos;0&apos; is always reachable</div><div class=\"line\">            //For all num in nums, check the accessibility from half - num to 0.</div><div class=\"line\">            //If &apos;i&apos; is accessible by former numbers, then &apos;i + num&apos; is also accessible. (DP Algorithm)</div><div class=\"line\">            for(int num: nums)</div><div class=\"line\">                //Below here we must start from &apos;half&apos; downto &apos;num&apos;, otherwise current &apos;num&apos; might be multiply used.</div><div class=\"line\">                //e.g.: If num == 2, then we will have 2, 4, 6... will all be accessible and lead to wrong answer.</div><div class=\"line\">                for(int i = half; i &gt;= num; i--)&#123;</div><div class=\"line\">                    if (accessibility[i - num] == true)&#123;</div><div class=\"line\">                        accessibility[i] = true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            return accessibility[half];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>However it’s space complex is O(n), so if you need a O(1) solution, I find a cool solution based on bitset.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    bitset&lt;5001&gt; bits(1);</div><div class=\"line\">    int sum = accumulate(nums.begin(), nums.end(), 0);</div><div class=\"line\">    for (auto n : nums) bits |= bits &lt;&lt; n;</div><div class=\"line\">    return !(sum &amp; 1) &amp;&amp; bits[sum &gt;&gt; 1];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Why and how it works, remaining unknown.</p>\n","excerpt":"<blockquote>\n<p>Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>\n<p>Note:</p>\n<ul>\n<li>Each of the array element will not exceed 100.</li>\n<li>The array size will not exceed 200.</li>\n</ul>\n<p>Example 1:</p>\n<p>Input: [1, 5, 11, 5]<br>Output: true</p>\n<p>Explanation: The array can be partitioned as [1, 5, 5] and [11].</p>\n<p>Example 2:</p>\n<p>Input: [1, 2, 3, 5]<br>Output: false</p>\n<p>Explanation: The array cannot be partitioned into equal sum subsets.</p>\n</blockquote>","more":"<p>This is Leetcode 416, and it is a leetweek problem. My last pass code like these:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() &lt; 2) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int sum = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                sum = sum + nums[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (sum % 2 != 0) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return check(0, 0, nums, sum);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool check(int start, int current, vector&lt;int&gt; nums, int sum) &#123;</div><div class=\"line\">            bool res = false;</div><div class=\"line\">            if (current &gt; sum / 2) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (current == sum / 2) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = start + 1; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                res = res || check(i, current + nums[i], nums, sum);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>Because the time complex of this recursive functoin is O(n!), the worst condition. So, we can change our mind to turn this problem into another one.</p>\n<p>Find a set of the subarray which its sum is sum / 2. And we can use the DP solution.</p>\n<p>Because we know the sum of the array, so we make a array <strong>dp</strong> in size sum/2. And after a for loop. we will know the dp[num] and dp[sum/2 - num] can achieve. So, when we for twice, like:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (auto num : nums) &#123;</div><div class=\"line\">    for(int i = target; i &gt;= num; i--) &#123; // to be quick we don&apos;t visit the whole dp array</div><div class=\"line\">        dp[i] = dp[i] || dp[i - num];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>So, here comes a better solution based on DP:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            int sum = accumulate(nums.begin(), nums.end(), 0);</div><div class=\"line\">            if (sum &amp; 1) return false;</div><div class=\"line\">            int half = sum &gt;&gt; 1;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;bool&gt; accessibility(half + 1, false);</div><div class=\"line\">            accessibility[0] = true;    // &apos;0&apos; is always reachable</div><div class=\"line\">            //For all num in nums, check the accessibility from half - num to 0.</div><div class=\"line\">            //If &apos;i&apos; is accessible by former numbers, then &apos;i + num&apos; is also accessible. (DP Algorithm)</div><div class=\"line\">            for(int num: nums)</div><div class=\"line\">                //Below here we must start from &apos;half&apos; downto &apos;num&apos;, otherwise current &apos;num&apos; might be multiply used.</div><div class=\"line\">                //e.g.: If num == 2, then we will have 2, 4, 6... will all be accessible and lead to wrong answer.</div><div class=\"line\">                for(int i = half; i &gt;= num; i--)&#123;</div><div class=\"line\">                    if (accessibility[i - num] == true)&#123;</div><div class=\"line\">                        accessibility[i] = true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            return accessibility[half];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>However it’s space complex is O(n), so if you need a O(1) solution, I find a cool solution based on bitset.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    bitset&lt;5001&gt; bits(1);</div><div class=\"line\">    int sum = accumulate(nums.begin(), nums.end(), 0);</div><div class=\"line\">    for (auto n : nums) bits |= bits &lt;&lt; n;</div><div class=\"line\">    return !(sum &amp; 1) &amp;&amp; bits[sum &gt;&gt; 1];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Why and how it works, remaining unknown.</p>"},{"title":"Path Sum III","date":"2017-01-07T11:46:25.000Z","_content":"\n> You are given a binary tree in which each node contains an integer value.\n>\n> Find the number of paths that sum to a given value.\n>\n> The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).\n>\n> The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.\n>\n> Example:\n>\n> root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8\n>\n>           10\n>          /  \\\n>         5   -3\n>        / \\    \\\n>       3   2   11\n>      / \\   \\\n>     3  -2   1\n>\n> Return 3. The paths that sum to 8 are:\n>\n> 1.  5 -> 3\n> 2.  5 -> 2 -> 1\n> 3. -3 -> 11\n\n<!-- more -->\n\n\nThis is Leetcode 437, easy problem, and it's solution as following:\n\n```\nclass Solution {\n    public:\n        int pathSum(TreeNode* root, int sum) {\n            if(root == NULL)\n                return 0;\n            return visit(root, sum) + pathSum(root->left, sum) + pathSum(root->right, sum);\n        }\n\n        int visit(TreeNode* node, int sum) {\n            int res = 0;\n            if(node == NULL)\n                return res;\n            if(sum == node->val)\n                res++;\n            res += visit(node->left, sum - node->val);\n            res += visit(node->right, sum - node->val);\n            return res;\n        }\n};\n```\n\nIt's time complex is O(nlogn) if it's a balanced tree while O(n^2) in the worst case.\n\nThe better solution is the DP solution using a map to store all the value of the tree node.\n\n```\nclass Solution {\n    public:\n        int help(TreeNode* root, int sum, unordered_map<int, int>& store, int pre) {\n            if (!root) return 0;\n            root->val += pre;\n            int res = (root->val == sum) + (store.count(root->val - sum) ? store[root->val - sum] : 0);\n            store[root->val]++;\n            res += help(root->left, sum, store, root->val) + help(root->right, sum, store, root->val);\n            store[root->val]--;\n            return res;\n        }\n\n        int pathSum(TreeNode* root, int sum) {\n            unordered_map<int, int> store;\n            return help(root, sum, store, 0);\n        }\n};\n```\n\nThat's it.\n","source":"_posts/PathSumIII.md","raw":"---\ntitle: Path Sum III\ndate: 2017-01-07 19:46:25\ntags:\n    - Tree\n---\n\n> You are given a binary tree in which each node contains an integer value.\n>\n> Find the number of paths that sum to a given value.\n>\n> The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).\n>\n> The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.\n>\n> Example:\n>\n> root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8\n>\n>           10\n>          /  \\\n>         5   -3\n>        / \\    \\\n>       3   2   11\n>      / \\   \\\n>     3  -2   1\n>\n> Return 3. The paths that sum to 8 are:\n>\n> 1.  5 -> 3\n> 2.  5 -> 2 -> 1\n> 3. -3 -> 11\n\n<!-- more -->\n\n\nThis is Leetcode 437, easy problem, and it's solution as following:\n\n```\nclass Solution {\n    public:\n        int pathSum(TreeNode* root, int sum) {\n            if(root == NULL)\n                return 0;\n            return visit(root, sum) + pathSum(root->left, sum) + pathSum(root->right, sum);\n        }\n\n        int visit(TreeNode* node, int sum) {\n            int res = 0;\n            if(node == NULL)\n                return res;\n            if(sum == node->val)\n                res++;\n            res += visit(node->left, sum - node->val);\n            res += visit(node->right, sum - node->val);\n            return res;\n        }\n};\n```\n\nIt's time complex is O(nlogn) if it's a balanced tree while O(n^2) in the worst case.\n\nThe better solution is the DP solution using a map to store all the value of the tree node.\n\n```\nclass Solution {\n    public:\n        int help(TreeNode* root, int sum, unordered_map<int, int>& store, int pre) {\n            if (!root) return 0;\n            root->val += pre;\n            int res = (root->val == sum) + (store.count(root->val - sum) ? store[root->val - sum] : 0);\n            store[root->val]++;\n            res += help(root->left, sum, store, root->val) + help(root->right, sum, store, root->val);\n            store[root->val]--;\n            return res;\n        }\n\n        int pathSum(TreeNode* root, int sum) {\n            unordered_map<int, int> store;\n            return help(root, sum, store, 0);\n        }\n};\n```\n\nThat's it.\n","slug":"PathSumIII","published":1,"updated":"2017-01-07T16:00:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5ra001gpff4qr0ra37s","content":"<blockquote>\n<p>You are given a binary tree in which each node contains an integer value.</p>\n<p>Find the number of paths that sum to a given value.</p>\n<p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p>\n<p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p>\n<p>Example:</p>\n<p>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</p>\n<pre><code>      10\n     /  \\\n    5   -3\n   / \\    \\\n  3   2   11\n / \\   \\\n3  -2   1\n</code></pre><p>Return 3. The paths that sum to 8 are:</p>\n<ol>\n<li>5 -&gt; 3</li>\n<li>5 -&gt; 2 -&gt; 1</li>\n<li>-3 -&gt; 11</li>\n</ol>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 437, easy problem, and it’s solution as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int pathSum(TreeNode* root, int sum) &#123;</div><div class=\"line\">            if(root == NULL)</div><div class=\"line\">                return 0;</div><div class=\"line\">            return visit(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int visit(TreeNode* node, int sum) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            if(node == NULL)</div><div class=\"line\">                return res;</div><div class=\"line\">            if(sum == node-&gt;val)</div><div class=\"line\">                res++;</div><div class=\"line\">            res += visit(node-&gt;left, sum - node-&gt;val);</div><div class=\"line\">            res += visit(node-&gt;right, sum - node-&gt;val);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It’s time complex is O(nlogn) if it’s a balanced tree while O(n^2) in the worst case.</p>\n<p>The better solution is the DP solution using a map to store all the value of the tree node.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int help(TreeNode* root, int sum, unordered_map&lt;int, int&gt;&amp; store, int pre) &#123;</div><div class=\"line\">            if (!root) return 0;</div><div class=\"line\">            root-&gt;val += pre;</div><div class=\"line\">            int res = (root-&gt;val == sum) + (store.count(root-&gt;val - sum) ? store[root-&gt;val - sum] : 0);</div><div class=\"line\">            store[root-&gt;val]++;</div><div class=\"line\">            res += help(root-&gt;left, sum, store, root-&gt;val) + help(root-&gt;right, sum, store, root-&gt;val);</div><div class=\"line\">            store[root-&gt;val]--;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int pathSum(TreeNode* root, int sum) &#123;</div><div class=\"line\">            unordered_map&lt;int, int&gt; store;</div><div class=\"line\">            return help(root, sum, store, 0);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>That’s it.</p>\n","excerpt":"<blockquote>\n<p>You are given a binary tree in which each node contains an integer value.</p>\n<p>Find the number of paths that sum to a given value.</p>\n<p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p>\n<p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p>\n<p>Example:</p>\n<p>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</p>\n<pre><code>      10\n     /  \\\n    5   -3\n   / \\    \\\n  3   2   11\n / \\   \\\n3  -2   1\n</code></pre><p>Return 3. The paths that sum to 8 are:</p>\n<ol>\n<li>5 -&gt; 3</li>\n<li>5 -&gt; 2 -&gt; 1</li>\n<li>-3 -&gt; 11</li>\n</ol>\n</blockquote>","more":"<p>This is Leetcode 437, easy problem, and it’s solution as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int pathSum(TreeNode* root, int sum) &#123;</div><div class=\"line\">            if(root == NULL)</div><div class=\"line\">                return 0;</div><div class=\"line\">            return visit(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int visit(TreeNode* node, int sum) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            if(node == NULL)</div><div class=\"line\">                return res;</div><div class=\"line\">            if(sum == node-&gt;val)</div><div class=\"line\">                res++;</div><div class=\"line\">            res += visit(node-&gt;left, sum - node-&gt;val);</div><div class=\"line\">            res += visit(node-&gt;right, sum - node-&gt;val);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It’s time complex is O(nlogn) if it’s a balanced tree while O(n^2) in the worst case.</p>\n<p>The better solution is the DP solution using a map to store all the value of the tree node.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int help(TreeNode* root, int sum, unordered_map&lt;int, int&gt;&amp; store, int pre) &#123;</div><div class=\"line\">            if (!root) return 0;</div><div class=\"line\">            root-&gt;val += pre;</div><div class=\"line\">            int res = (root-&gt;val == sum) + (store.count(root-&gt;val - sum) ? store[root-&gt;val - sum] : 0);</div><div class=\"line\">            store[root-&gt;val]++;</div><div class=\"line\">            res += help(root-&gt;left, sum, store, root-&gt;val) + help(root-&gt;right, sum, store, root-&gt;val);</div><div class=\"line\">            store[root-&gt;val]--;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int pathSum(TreeNode* root, int sum) &#123;</div><div class=\"line\">            unordered_map&lt;int, int&gt; store;</div><div class=\"line\">            return help(root, sum, store, 0);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>That’s it.</p>"},{"title":"Perfect Squares","date":"2017-01-16T07:31:29.000Z","_content":"\n>  Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.\n>\n>  For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.\n\n<!--more-->\n\nIt is Leetcode 279 and a quite easy DP problem.\n\nI used to find a hard way, for example, 1 4 9 16 25 are square numbers, and I use it as a seed to find the second level numbers. Use 1 as a example,\n\nI will find 2(1+1), 5(1+4), 10(1+9)... are level 2 square numbers, and so on. I will find level N. Once if find the target number, return the level number, and the problem is done.\n\nHowever, this solution gets a TLE. And, I just find another way to solve:\n\n```\nclass Solution {\n    public:\n        int numSquares(int n) {\n            vector<long> DP(n + 1, INT_MAX);\n            DP[0] = 0;\n            for (int i = 0; i <= n; i++) {\n                for (int idx = 0; idx <= (int)sqrt(i); idx++) {\n                    DP[i] = min(1 + DP[i - idx*idx], DP[i]);\n                }\n            }\n            return DP[n];\n        }\n};\n```\n\nMuch easier than the former one. And it gets AC.\n","source":"_posts/PerfectSquares.md","raw":"---\ntitle: Perfect Squares\ndate: 2017-01-16 15:31:29\ntags:\n    - Dynamic Programming\n    - Math\n    - Breadth-first Search\n---\n\n>  Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.\n>\n>  For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.\n\n<!--more-->\n\nIt is Leetcode 279 and a quite easy DP problem.\n\nI used to find a hard way, for example, 1 4 9 16 25 are square numbers, and I use it as a seed to find the second level numbers. Use 1 as a example,\n\nI will find 2(1+1), 5(1+4), 10(1+9)... are level 2 square numbers, and so on. I will find level N. Once if find the target number, return the level number, and the problem is done.\n\nHowever, this solution gets a TLE. And, I just find another way to solve:\n\n```\nclass Solution {\n    public:\n        int numSquares(int n) {\n            vector<long> DP(n + 1, INT_MAX);\n            DP[0] = 0;\n            for (int i = 0; i <= n; i++) {\n                for (int idx = 0; idx <= (int)sqrt(i); idx++) {\n                    DP[i] = min(1 + DP[i - idx*idx], DP[i]);\n                }\n            }\n            return DP[n];\n        }\n};\n```\n\nMuch easier than the former one. And it gets AC.\n","slug":"PerfectSquares","published":1,"updated":"2017-01-16T08:11:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5rc001ipff44yd6q5yz","content":"<blockquote>\n<p> Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to n.</p>\n<p> For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>It is Leetcode 279 and a quite easy DP problem.</p>\n<p>I used to find a hard way, for example, 1 4 9 16 25 are square numbers, and I use it as a seed to find the second level numbers. Use 1 as a example,</p>\n<p>I will find 2(1+1), 5(1+4), 10(1+9)… are level 2 square numbers, and so on. I will find level N. Once if find the target number, return the level number, and the problem is done.</p>\n<p>However, this solution gets a TLE. And, I just find another way to solve:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int numSquares(int n) &#123;</div><div class=\"line\">            vector&lt;long&gt; DP(n + 1, INT_MAX);</div><div class=\"line\">            DP[0] = 0;</div><div class=\"line\">            for (int i = 0; i &lt;= n; i++) &#123;</div><div class=\"line\">                for (int idx = 0; idx &lt;= (int)sqrt(i); idx++) &#123;</div><div class=\"line\">                    DP[i] = min(1 + DP[i - idx*idx], DP[i]);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return DP[n];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Much easier than the former one. And it gets AC.</p>\n","excerpt":"<blockquote>\n<p> Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to n.</p>\n<p> For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.</p>\n</blockquote>","more":"<p>It is Leetcode 279 and a quite easy DP problem.</p>\n<p>I used to find a hard way, for example, 1 4 9 16 25 are square numbers, and I use it as a seed to find the second level numbers. Use 1 as a example,</p>\n<p>I will find 2(1+1), 5(1+4), 10(1+9)… are level 2 square numbers, and so on. I will find level N. Once if find the target number, return the level number, and the problem is done.</p>\n<p>However, this solution gets a TLE. And, I just find another way to solve:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int numSquares(int n) &#123;</div><div class=\"line\">            vector&lt;long&gt; DP(n + 1, INT_MAX);</div><div class=\"line\">            DP[0] = 0;</div><div class=\"line\">            for (int i = 0; i &lt;= n; i++) &#123;</div><div class=\"line\">                for (int idx = 0; idx &lt;= (int)sqrt(i); idx++) &#123;</div><div class=\"line\">                    DP[i] = min(1 + DP[i - idx*idx], DP[i]);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return DP[n];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Much easier than the former one. And it gets AC.</p>"},{"title":"Predict the Winner","date":"2017-02-03T11:48:26.000Z","_content":"\n> Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.\n>\n> Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.\n>\n> Example 1:\n> + Input: [1, 5, 2]\n> + Output: False\n> + Explanation:\n>   + Initially, player 1 can choose between 1 and 2.\n>   + If he chooses 2 (or 1). Then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5.\n>   + Then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5.\n>   + Hence, player 1 will never be the winner and you need to return False.\n>\n> Example 2:\n> + Input: [1, 5, 233, 7]\n> + Output: True\n> + Explanation:\n>   + Player 1 first chooses 1. Then player 2 have to choose between 5 and 7.\n>   + No matter which number player 2 choose, player 1 can choose 233.\n>   + Finally, player 1 has more score (234) than player 2 (12).\n>   + So you need to return True representing player1 can win.\n>\n> Note:\n> + 1 <= length of the array <= 20.\n> + Any scores in the given array are non-negative integers and will not exceed 10,000,000.\n> + If the scores of both players are equal, then player 1 is still the winner.\n\n<!--more-->\n\nThis is Leetcode 486, and its No. is like the comic(\"[Re:ゼロから始める異世界生活](http://www.imdb.com/title/tt5607616/)\") male role called \"Subaru Natsuki\".\n\nIt is actually an interesting problem. You can find its solution is like \"Tower of Hanoi\", you need to find the conditions needed by player 1 to win.\n\nSo, here is his conditions, if his turn, he just need one choice to win, for the other's turn, he need both choice to win.\n\nHere is the condition section of code:\n\n```\nbool _calc(int startIdx, int endIdx, bool isA, int currentA, int currentB, vector<int> nums) {\n    if (endIdx == startIdx) {\n        if (isA) {\n            return currentA + nums[startIdx] >= currentB;\n        } else {\n            return currentA >= currentB + nums[startIdx];\n        }\n    } else {\n        if (isA) {\n            return _calc(startIdx + 1, endIdx, !isA, currentA + nums[startIdx], currentB, nums)\n                || _calc(startIdx, endIdx - 1, !isA, currentA + nums[endIdx], currentB, nums);\n        } else {\n            return _calc(startIdx + 1, endIdx, !isA, currentA, currentB + nums[startIdx], nums)\n                && _calc(startIdx, endIdx - 1, !isA, currentA, currentB + nums[endIdx], nums);\n        }\n    }\n}\n```\n\nAnd my solution is:\n\n```\nclass Solution {\n    public:\n        bool PredictTheWinner(vector<int>& nums) {\n            return _calc(0, nums.size() - 1, true, 0, 0, nums);\n        }\n\n        bool _calc(int startIdx, int endIdx, bool isA, int currentA, int currentB, vector<int> nums) {\n            if (endIdx == startIdx) {\n                if (isA) {\n                    return currentA + nums[startIdx] >= currentB;\n                } else {\n                    return currentA >= currentB + nums[startIdx];\n                }\n            } else {\n                if (isA) {\n                    return _calc(startIdx + 1, endIdx, !isA, currentA + nums[startIdx], currentB, nums)\n                        || _calc(startIdx, endIdx - 1, !isA, currentA + nums[endIdx], currentB, nums);\n                } else {\n                    return _calc(startIdx + 1, endIdx, !isA, currentA, currentB + nums[startIdx], nums)\n                        && _calc(startIdx, endIdx - 1, !isA, currentA, currentB + nums[endIdx], nums);\n                }\n            }\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/PredicttheWinner.md","raw":"---\ntitle: Predict the Winner\ndate: 2017-02-03 19:48:26\ntags:\n    - Dynamic Programming\n    - Minimax\n---\n\n> Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.\n>\n> Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.\n>\n> Example 1:\n> + Input: [1, 5, 2]\n> + Output: False\n> + Explanation:\n>   + Initially, player 1 can choose between 1 and 2.\n>   + If he chooses 2 (or 1). Then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5.\n>   + Then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5.\n>   + Hence, player 1 will never be the winner and you need to return False.\n>\n> Example 2:\n> + Input: [1, 5, 233, 7]\n> + Output: True\n> + Explanation:\n>   + Player 1 first chooses 1. Then player 2 have to choose between 5 and 7.\n>   + No matter which number player 2 choose, player 1 can choose 233.\n>   + Finally, player 1 has more score (234) than player 2 (12).\n>   + So you need to return True representing player1 can win.\n>\n> Note:\n> + 1 <= length of the array <= 20.\n> + Any scores in the given array are non-negative integers and will not exceed 10,000,000.\n> + If the scores of both players are equal, then player 1 is still the winner.\n\n<!--more-->\n\nThis is Leetcode 486, and its No. is like the comic(\"[Re:ゼロから始める異世界生活](http://www.imdb.com/title/tt5607616/)\") male role called \"Subaru Natsuki\".\n\nIt is actually an interesting problem. You can find its solution is like \"Tower of Hanoi\", you need to find the conditions needed by player 1 to win.\n\nSo, here is his conditions, if his turn, he just need one choice to win, for the other's turn, he need both choice to win.\n\nHere is the condition section of code:\n\n```\nbool _calc(int startIdx, int endIdx, bool isA, int currentA, int currentB, vector<int> nums) {\n    if (endIdx == startIdx) {\n        if (isA) {\n            return currentA + nums[startIdx] >= currentB;\n        } else {\n            return currentA >= currentB + nums[startIdx];\n        }\n    } else {\n        if (isA) {\n            return _calc(startIdx + 1, endIdx, !isA, currentA + nums[startIdx], currentB, nums)\n                || _calc(startIdx, endIdx - 1, !isA, currentA + nums[endIdx], currentB, nums);\n        } else {\n            return _calc(startIdx + 1, endIdx, !isA, currentA, currentB + nums[startIdx], nums)\n                && _calc(startIdx, endIdx - 1, !isA, currentA, currentB + nums[endIdx], nums);\n        }\n    }\n}\n```\n\nAnd my solution is:\n\n```\nclass Solution {\n    public:\n        bool PredictTheWinner(vector<int>& nums) {\n            return _calc(0, nums.size() - 1, true, 0, 0, nums);\n        }\n\n        bool _calc(int startIdx, int endIdx, bool isA, int currentA, int currentB, vector<int> nums) {\n            if (endIdx == startIdx) {\n                if (isA) {\n                    return currentA + nums[startIdx] >= currentB;\n                } else {\n                    return currentA >= currentB + nums[startIdx];\n                }\n            } else {\n                if (isA) {\n                    return _calc(startIdx + 1, endIdx, !isA, currentA + nums[startIdx], currentB, nums)\n                        || _calc(startIdx, endIdx - 1, !isA, currentA + nums[endIdx], currentB, nums);\n                } else {\n                    return _calc(startIdx + 1, endIdx, !isA, currentA, currentB + nums[startIdx], nums)\n                        && _calc(startIdx, endIdx - 1, !isA, currentA, currentB + nums[endIdx], nums);\n                }\n            }\n        }\n};\n```\n\nIt gets AC.\n","slug":"PredicttheWinner","published":1,"updated":"2017-02-04T07:50:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5rd001lpff4cvvpv0cl","content":"<blockquote>\n<p>Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.</p>\n<p>Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: [1, 5, 2]</li>\n<li>Output: False</li>\n<li>Explanation:<ul>\n<li>Initially, player 1 can choose between 1 and 2.</li>\n<li>If he chooses 2 (or 1). Then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5.</li>\n<li>Then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5.</li>\n<li>Hence, player 1 will never be the winner and you need to return False.</li>\n</ul>\n</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: [1, 5, 233, 7]</li>\n<li>Output: True</li>\n<li>Explanation:<ul>\n<li>Player 1 first chooses 1. Then player 2 have to choose between 5 and 7.</li>\n<li>No matter which number player 2 choose, player 1 can choose 233.</li>\n<li>Finally, player 1 has more score (234) than player 2 (12).</li>\n<li>So you need to return True representing player1 can win.</li>\n</ul>\n</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>1 &lt;= length of the array &lt;= 20.</li>\n<li>Any scores in the given array are non-negative integers and will not exceed 10,000,000.</li>\n<li>If the scores of both players are equal, then player 1 is still the winner.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 486, and its No. is like the comic(“<a href=\"http://www.imdb.com/title/tt5607616/\" target=\"_blank\" rel=\"external\">Re:ゼロから始める異世界生活</a>“) male role called “Subaru Natsuki”.</p>\n<p>It is actually an interesting problem. You can find its solution is like “Tower of Hanoi”, you need to find the conditions needed by player 1 to win.</p>\n<p>So, here is his conditions, if his turn, he just need one choice to win, for the other’s turn, he need both choice to win.</p>\n<p>Here is the condition section of code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool _calc(int startIdx, int endIdx, bool isA, int currentA, int currentB, vector&lt;int&gt; nums) &#123;</div><div class=\"line\">    if (endIdx == startIdx) &#123;</div><div class=\"line\">        if (isA) &#123;</div><div class=\"line\">            return currentA + nums[startIdx] &gt;= currentB;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return currentA &gt;= currentB + nums[startIdx];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        if (isA) &#123;</div><div class=\"line\">            return _calc(startIdx + 1, endIdx, !isA, currentA + nums[startIdx], currentB, nums)</div><div class=\"line\">                || _calc(startIdx, endIdx - 1, !isA, currentA + nums[endIdx], currentB, nums);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return _calc(startIdx + 1, endIdx, !isA, currentA, currentB + nums[startIdx], nums)</div><div class=\"line\">                &amp;&amp; _calc(startIdx, endIdx - 1, !isA, currentA, currentB + nums[endIdx], nums);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>And my solution is:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool PredictTheWinner(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            return _calc(0, nums.size() - 1, true, 0, 0, nums);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool _calc(int startIdx, int endIdx, bool isA, int currentA, int currentB, vector&lt;int&gt; nums) &#123;</div><div class=\"line\">            if (endIdx == startIdx) &#123;</div><div class=\"line\">                if (isA) &#123;</div><div class=\"line\">                    return currentA + nums[startIdx] &gt;= currentB;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    return currentA &gt;= currentB + nums[startIdx];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                if (isA) &#123;</div><div class=\"line\">                    return _calc(startIdx + 1, endIdx, !isA, currentA + nums[startIdx], currentB, nums)</div><div class=\"line\">                        || _calc(startIdx, endIdx - 1, !isA, currentA + nums[endIdx], currentB, nums);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    return _calc(startIdx + 1, endIdx, !isA, currentA, currentB + nums[startIdx], nums)</div><div class=\"line\">                        &amp;&amp; _calc(startIdx, endIdx - 1, !isA, currentA, currentB + nums[endIdx], nums);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.</p>\n<p>Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: [1, 5, 2]</li>\n<li>Output: False</li>\n<li>Explanation:<ul>\n<li>Initially, player 1 can choose between 1 and 2.</li>\n<li>If he chooses 2 (or 1). Then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5.</li>\n<li>Then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5.</li>\n<li>Hence, player 1 will never be the winner and you need to return False.</li>\n</ul>\n</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: [1, 5, 233, 7]</li>\n<li>Output: True</li>\n<li>Explanation:<ul>\n<li>Player 1 first chooses 1. Then player 2 have to choose between 5 and 7.</li>\n<li>No matter which number player 2 choose, player 1 can choose 233.</li>\n<li>Finally, player 1 has more score (234) than player 2 (12).</li>\n<li>So you need to return True representing player1 can win.</li>\n</ul>\n</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>1 &lt;= length of the array &lt;= 20.</li>\n<li>Any scores in the given array are non-negative integers and will not exceed 10,000,000.</li>\n<li>If the scores of both players are equal, then player 1 is still the winner.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 486, and its No. is like the comic(“<a href=\"http://www.imdb.com/title/tt5607616/\">Re:ゼロから始める異世界生活</a>“) male role called “Subaru Natsuki”.</p>\n<p>It is actually an interesting problem. You can find its solution is like “Tower of Hanoi”, you need to find the conditions needed by player 1 to win.</p>\n<p>So, here is his conditions, if his turn, he just need one choice to win, for the other’s turn, he need both choice to win.</p>\n<p>Here is the condition section of code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool _calc(int startIdx, int endIdx, bool isA, int currentA, int currentB, vector&lt;int&gt; nums) &#123;</div><div class=\"line\">    if (endIdx == startIdx) &#123;</div><div class=\"line\">        if (isA) &#123;</div><div class=\"line\">            return currentA + nums[startIdx] &gt;= currentB;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return currentA &gt;= currentB + nums[startIdx];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        if (isA) &#123;</div><div class=\"line\">            return _calc(startIdx + 1, endIdx, !isA, currentA + nums[startIdx], currentB, nums)</div><div class=\"line\">                || _calc(startIdx, endIdx - 1, !isA, currentA + nums[endIdx], currentB, nums);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return _calc(startIdx + 1, endIdx, !isA, currentA, currentB + nums[startIdx], nums)</div><div class=\"line\">                &amp;&amp; _calc(startIdx, endIdx - 1, !isA, currentA, currentB + nums[endIdx], nums);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>And my solution is:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool PredictTheWinner(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            return _calc(0, nums.size() - 1, true, 0, 0, nums);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool _calc(int startIdx, int endIdx, bool isA, int currentA, int currentB, vector&lt;int&gt; nums) &#123;</div><div class=\"line\">            if (endIdx == startIdx) &#123;</div><div class=\"line\">                if (isA) &#123;</div><div class=\"line\">                    return currentA + nums[startIdx] &gt;= currentB;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    return currentA &gt;= currentB + nums[startIdx];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                if (isA) &#123;</div><div class=\"line\">                    return _calc(startIdx + 1, endIdx, !isA, currentA + nums[startIdx], currentB, nums)</div><div class=\"line\">                        || _calc(startIdx, endIdx - 1, !isA, currentA + nums[endIdx], currentB, nums);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    return _calc(startIdx + 1, endIdx, !isA, currentA, currentB + nums[startIdx], nums)</div><div class=\"line\">                        &amp;&amp; _calc(startIdx, endIdx - 1, !isA, currentA, currentB + nums[endIdx], nums);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Relative Ranks","date":"2017-02-05T06:23:59.000Z","_content":"\n\n> Given scores of N athletes, find their relative ranks and the men with the top three highest scores, who will be awarded medals: \"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\".\n>\n> Example 1:\n>\n> + Input: [5, 4, 3, 2, 1]\n> + Output: [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"]\n> + Explanation:\n>     + The first three athletes got the top three highest scores, so they got \"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\".\n>     + For the left two athletes, you just need to output their relative ranks according to their scores.\n>\n> Note:\n> + N is a positive integer and won't exceed 10,000.\n> + All the scores of athletes are guaranteed to be unique.\n\n<!--more-->\n\nThis is Leetcode 506, and it is one of this week's weekly contest.\n\nEasy one.\n\n```\nbool msort( const int &v1, const int &v2) {\n    return v1 > v2;\n}\nclass Solution {\n    public:\n        vector<string> findRelativeRanks(vector<int>& nums) {\n            vector<string> res;\n            vector<int> origin(nums);\n            map<int, string> rankmap;\n\n            string ranks[3] = {\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"};\n\n            sort(nums.begin(), nums.end(), msort);\n\n            for (int i = 0; i < (int)nums.size(); i++) {\n                if (i < 3) {\n                    rankmap.insert(pair<int, string>(nums[i], ranks[i]));\n                } else {\n                    ostringstream stm;\n                    stm << i + 1;\n                    rankmap.insert(pair<int, string>(nums[i], stm.str()));\n                }\n            }\n\n            for (int i = 0; i < (int)origin.size(); i++) {\n                res.push_back(rankmap.find(origin[i])->second);\n            }\n            return res;\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/RelativeRanks.md","raw":"---\ntitle: Relative Ranks\ndate: 2017-02-05 14:23:59\ntags:\n    - Array\n---\n\n\n> Given scores of N athletes, find their relative ranks and the men with the top three highest scores, who will be awarded medals: \"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\".\n>\n> Example 1:\n>\n> + Input: [5, 4, 3, 2, 1]\n> + Output: [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"]\n> + Explanation:\n>     + The first three athletes got the top three highest scores, so they got \"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\".\n>     + For the left two athletes, you just need to output their relative ranks according to their scores.\n>\n> Note:\n> + N is a positive integer and won't exceed 10,000.\n> + All the scores of athletes are guaranteed to be unique.\n\n<!--more-->\n\nThis is Leetcode 506, and it is one of this week's weekly contest.\n\nEasy one.\n\n```\nbool msort( const int &v1, const int &v2) {\n    return v1 > v2;\n}\nclass Solution {\n    public:\n        vector<string> findRelativeRanks(vector<int>& nums) {\n            vector<string> res;\n            vector<int> origin(nums);\n            map<int, string> rankmap;\n\n            string ranks[3] = {\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"};\n\n            sort(nums.begin(), nums.end(), msort);\n\n            for (int i = 0; i < (int)nums.size(); i++) {\n                if (i < 3) {\n                    rankmap.insert(pair<int, string>(nums[i], ranks[i]));\n                } else {\n                    ostringstream stm;\n                    stm << i + 1;\n                    rankmap.insert(pair<int, string>(nums[i], stm.str()));\n                }\n            }\n\n            for (int i = 0; i < (int)origin.size(); i++) {\n                res.push_back(rankmap.find(origin[i])->second);\n            }\n            return res;\n        }\n};\n```\n\nIt gets AC.\n","slug":"RelativeRanks","published":1,"updated":"2017-02-05T06:48:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5rh001npff4vcm4dj7h","content":"<blockquote>\n<p>Given scores of N athletes, find their relative ranks and the men with the top three highest scores, who will be awarded medals: “Gold Medal”, “Silver Medal” and “Bronze Medal”.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: [5, 4, 3, 2, 1]</li>\n<li>Output: [“Gold Medal”, “Silver Medal”, “Bronze Medal”, “4”, “5”]</li>\n<li>Explanation:<ul>\n<li>The first three athletes got the top three highest scores, so they got “Gold Medal”, “Silver Medal” and “Bronze Medal”.</li>\n<li>For the left two athletes, you just need to output their relative ranks according to their scores.</li>\n</ul>\n</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>N is a positive integer and won’t exceed 10,000.</li>\n<li>All the scores of athletes are guaranteed to be unique.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 506, and it is one of this week’s weekly contest.</p>\n<p>Easy one.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool msort( const int &amp;v1, const int &amp;v2) &#123;</div><div class=\"line\">    return v1 &gt; v2;</div><div class=\"line\">&#125;</div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;string&gt; findRelativeRanks(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            vector&lt;string&gt; res;</div><div class=\"line\">            vector&lt;int&gt; origin(nums);</div><div class=\"line\">            map&lt;int, string&gt; rankmap;</div><div class=\"line\"></div><div class=\"line\">            string ranks[3] = &#123;&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;&#125;;</div><div class=\"line\"></div><div class=\"line\">            sort(nums.begin(), nums.end(), msort);</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (i &lt; 3) &#123;</div><div class=\"line\">                    rankmap.insert(pair&lt;int, string&gt;(nums[i], ranks[i]));</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    ostringstream stm;</div><div class=\"line\">                    stm &lt;&lt; i + 1;</div><div class=\"line\">                    rankmap.insert(pair&lt;int, string&gt;(nums[i], stm.str()));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)origin.size(); i++) &#123;</div><div class=\"line\">                res.push_back(rankmap.find(origin[i])-&gt;second);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given scores of N athletes, find their relative ranks and the men with the top three highest scores, who will be awarded medals: “Gold Medal”, “Silver Medal” and “Bronze Medal”.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: [5, 4, 3, 2, 1]</li>\n<li>Output: [“Gold Medal”, “Silver Medal”, “Bronze Medal”, “4”, “5”]</li>\n<li>Explanation:<ul>\n<li>The first three athletes got the top three highest scores, so they got “Gold Medal”, “Silver Medal” and “Bronze Medal”.</li>\n<li>For the left two athletes, you just need to output their relative ranks according to their scores.</li>\n</ul>\n</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>N is a positive integer and won’t exceed 10,000.</li>\n<li>All the scores of athletes are guaranteed to be unique.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 506, and it is one of this week’s weekly contest.</p>\n<p>Easy one.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool msort( const int &amp;v1, const int &amp;v2) &#123;</div><div class=\"line\">    return v1 &gt; v2;</div><div class=\"line\">&#125;</div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;string&gt; findRelativeRanks(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            vector&lt;string&gt; res;</div><div class=\"line\">            vector&lt;int&gt; origin(nums);</div><div class=\"line\">            map&lt;int, string&gt; rankmap;</div><div class=\"line\"></div><div class=\"line\">            string ranks[3] = &#123;&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;&#125;;</div><div class=\"line\"></div><div class=\"line\">            sort(nums.begin(), nums.end(), msort);</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (i &lt; 3) &#123;</div><div class=\"line\">                    rankmap.insert(pair&lt;int, string&gt;(nums[i], ranks[i]));</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    ostringstream stm;</div><div class=\"line\">                    stm &lt;&lt; i + 1;</div><div class=\"line\">                    rankmap.insert(pair&lt;int, string&gt;(nums[i], stm.str()));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)origin.size(); i++) &#123;</div><div class=\"line\">                res.push_back(rankmap.find(origin[i])-&gt;second);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Target Sum","date":"2017-01-28T14:49:36.000Z","_content":"\n\n> You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.\n>\n> Find out how many ways to assign symbols to make sum of integers equal to target S.\n>\n> Example 1:\n>\n> Input: nums is [1, 1, 1, 1, 1], S is 3.\n> Output: 5\n>\n> Explanation:\n>\n> + -1+1+1+1+1 = 3\n> + +1-1+1+1+1 = 3\n> + +1+1-1+1+1 = 3\n> + +1+1+1-1+1 = 3\n> + +1+1+1+1-1 = 3\n>\n> There are 5 ways to assign symbols to make the sum of nums be target 3.\n>\n> Note:\n>\n> + The length of the given array is positive and will not exceed 20.\n> + The sum of elements in the given array will not exceed 1000.\n> + Your output answer is guaranteed to be fitted in a 32-bit integer.\n\n<!--more-->\n\nThis is Leetcode 494. And I tried a not best solution, just use the DFS:\n\n```\nclass Solution {\n    public:\n\n        int res;\n\n        int findTargetSumWays(vector<int>& nums, int target) {\n            res = 0;\n            _calc(nums, 0, target, 0);\n            return res;\n        }\n\n        void _calc(vector<int>& nums, int idx, int target, int current) {\n            if ((int)(nums.size()) == idx) {\n                if (current == target) {\n                    res++;\n                }\n            } else {\n                _calc(nums, idx + 1, target, current + nums[idx]);\n                _calc(nums, idx + 1, target, current - nums[idx]);\n            }\n        }\n};\n```\n\nAnd, it passed ?!\n\nSo, I try to find a better way to solve the problem, and I find I can try with DP.\n\nYou can use the following Java code:\n\n```\npublic class Solution {\n    public int findTargetSumWays(int[] nums, int s) {\n        int sum = 0;\n        for(int i: nums) sum+=i;\n        if(s>sum || s<-sum) return 0;\n        int[] dp = new int[2*sum+1];\n        dp[0+sum] = 1;\n        for(int i = 0; i<nums.length; i++){\n            int[] next = new int[2*sum+1];\n            for(int k = 0; k<2*sum+1; k++){\n                if(dp[k]!=0){\n                    next[k + nums[i]] += dp[k];\n                    next[k - nums[i]] += dp[k];\n                }\n            }\n            dp = next;\n        }\n        return dp[sum+s];\n    }\n}\n```\n\nExplaination:\n> ![](https://discuss.leetcode.com/uploads/files/1485048726667-screen-shot-2017-01-21-at-8.31.48-pm.jpg)\n","source":"_posts/TargetSum.md","raw":"---\ntitle: Target Sum\ndate: 2017-01-28 22:49:36\ntags:\n    - Depth-first Search\n    - Dynamic Programming\n---\n\n\n> You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.\n>\n> Find out how many ways to assign symbols to make sum of integers equal to target S.\n>\n> Example 1:\n>\n> Input: nums is [1, 1, 1, 1, 1], S is 3.\n> Output: 5\n>\n> Explanation:\n>\n> + -1+1+1+1+1 = 3\n> + +1-1+1+1+1 = 3\n> + +1+1-1+1+1 = 3\n> + +1+1+1-1+1 = 3\n> + +1+1+1+1-1 = 3\n>\n> There are 5 ways to assign symbols to make the sum of nums be target 3.\n>\n> Note:\n>\n> + The length of the given array is positive and will not exceed 20.\n> + The sum of elements in the given array will not exceed 1000.\n> + Your output answer is guaranteed to be fitted in a 32-bit integer.\n\n<!--more-->\n\nThis is Leetcode 494. And I tried a not best solution, just use the DFS:\n\n```\nclass Solution {\n    public:\n\n        int res;\n\n        int findTargetSumWays(vector<int>& nums, int target) {\n            res = 0;\n            _calc(nums, 0, target, 0);\n            return res;\n        }\n\n        void _calc(vector<int>& nums, int idx, int target, int current) {\n            if ((int)(nums.size()) == idx) {\n                if (current == target) {\n                    res++;\n                }\n            } else {\n                _calc(nums, idx + 1, target, current + nums[idx]);\n                _calc(nums, idx + 1, target, current - nums[idx]);\n            }\n        }\n};\n```\n\nAnd, it passed ?!\n\nSo, I try to find a better way to solve the problem, and I find I can try with DP.\n\nYou can use the following Java code:\n\n```\npublic class Solution {\n    public int findTargetSumWays(int[] nums, int s) {\n        int sum = 0;\n        for(int i: nums) sum+=i;\n        if(s>sum || s<-sum) return 0;\n        int[] dp = new int[2*sum+1];\n        dp[0+sum] = 1;\n        for(int i = 0; i<nums.length; i++){\n            int[] next = new int[2*sum+1];\n            for(int k = 0; k<2*sum+1; k++){\n                if(dp[k]!=0){\n                    next[k + nums[i]] += dp[k];\n                    next[k - nums[i]] += dp[k];\n                }\n            }\n            dp = next;\n        }\n        return dp[sum+s];\n    }\n}\n```\n\nExplaination:\n> ![](https://discuss.leetcode.com/uploads/files/1485048726667-screen-shot-2017-01-21-at-8.31.48-pm.jpg)\n","slug":"TargetSum","published":1,"updated":"2017-01-28T15:41:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5ri001qpff4lgt2ejm4","content":"<blockquote>\n<p>You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.</p>\n<p>Find out how many ways to assign symbols to make sum of integers equal to target S.</p>\n<p>Example 1:</p>\n<p>Input: nums is [1, 1, 1, 1, 1], S is 3.<br>Output: 5</p>\n<p>Explanation:</p>\n<ul>\n<li>-1+1+1+1+1 = 3</li>\n<li>+1-1+1+1+1 = 3</li>\n<li>+1+1-1+1+1 = 3</li>\n<li>+1+1+1-1+1 = 3</li>\n<li>+1+1+1+1-1 = 3</li>\n</ul>\n<p>There are 5 ways to assign symbols to make the sum of nums be target 3.</p>\n<p>Note:</p>\n<ul>\n<li>The length of the given array is positive and will not exceed 20.</li>\n<li>The sum of elements in the given array will not exceed 1000.</li>\n<li>Your output answer is guaranteed to be fitted in a 32-bit integer.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 494. And I tried a not best solution, just use the DFS:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\"></div><div class=\"line\">        int res;</div><div class=\"line\"></div><div class=\"line\">        int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class=\"line\">            res = 0;</div><div class=\"line\">            _calc(nums, 0, target, 0);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _calc(vector&lt;int&gt;&amp; nums, int idx, int target, int current) &#123;</div><div class=\"line\">            if ((int)(nums.size()) == idx) &#123;</div><div class=\"line\">                if (current == target) &#123;</div><div class=\"line\">                    res++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                _calc(nums, idx + 1, target, current + nums[idx]);</div><div class=\"line\">                _calc(nums, idx + 1, target, current - nums[idx]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And, it passed ?!</p>\n<p>So, I try to find a better way to solve the problem, and I find I can try with DP.</p>\n<p>You can use the following Java code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Solution &#123;</div><div class=\"line\">    public int findTargetSumWays(int[] nums, int s) &#123;</div><div class=\"line\">        int sum = 0;</div><div class=\"line\">        for(int i: nums) sum+=i;</div><div class=\"line\">        if(s&gt;sum || s&lt;-sum) return 0;</div><div class=\"line\">        int[] dp = new int[2*sum+1];</div><div class=\"line\">        dp[0+sum] = 1;</div><div class=\"line\">        for(int i = 0; i&lt;nums.length; i++)&#123;</div><div class=\"line\">            int[] next = new int[2*sum+1];</div><div class=\"line\">            for(int k = 0; k&lt;2*sum+1; k++)&#123;</div><div class=\"line\">                if(dp[k]!=0)&#123;</div><div class=\"line\">                    next[k + nums[i]] += dp[k];</div><div class=\"line\">                    next[k - nums[i]] += dp[k];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            dp = next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return dp[sum+s];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Explaination:</p>\n<blockquote>\n<p><img src=\"https://discuss.leetcode.com/uploads/files/1485048726667-screen-shot-2017-01-21-at-8.31.48-pm.jpg\" alt=\"\"></p>\n</blockquote>\n","excerpt":"<blockquote>\n<p>You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.</p>\n<p>Find out how many ways to assign symbols to make sum of integers equal to target S.</p>\n<p>Example 1:</p>\n<p>Input: nums is [1, 1, 1, 1, 1], S is 3.<br>Output: 5</p>\n<p>Explanation:</p>\n<ul>\n<li>-1+1+1+1+1 = 3</li>\n<li>+1-1+1+1+1 = 3</li>\n<li>+1+1-1+1+1 = 3</li>\n<li>+1+1+1-1+1 = 3</li>\n<li>+1+1+1+1-1 = 3</li>\n</ul>\n<p>There are 5 ways to assign symbols to make the sum of nums be target 3.</p>\n<p>Note:</p>\n<ul>\n<li>The length of the given array is positive and will not exceed 20.</li>\n<li>The sum of elements in the given array will not exceed 1000.</li>\n<li>Your output answer is guaranteed to be fitted in a 32-bit integer.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 494. And I tried a not best solution, just use the DFS:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\"></div><div class=\"line\">        int res;</div><div class=\"line\"></div><div class=\"line\">        int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class=\"line\">            res = 0;</div><div class=\"line\">            _calc(nums, 0, target, 0);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _calc(vector&lt;int&gt;&amp; nums, int idx, int target, int current) &#123;</div><div class=\"line\">            if ((int)(nums.size()) == idx) &#123;</div><div class=\"line\">                if (current == target) &#123;</div><div class=\"line\">                    res++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                _calc(nums, idx + 1, target, current + nums[idx]);</div><div class=\"line\">                _calc(nums, idx + 1, target, current - nums[idx]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And, it passed ?!</p>\n<p>So, I try to find a better way to solve the problem, and I find I can try with DP.</p>\n<p>You can use the following Java code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Solution &#123;</div><div class=\"line\">    public int findTargetSumWays(int[] nums, int s) &#123;</div><div class=\"line\">        int sum = 0;</div><div class=\"line\">        for(int i: nums) sum+=i;</div><div class=\"line\">        if(s&gt;sum || s&lt;-sum) return 0;</div><div class=\"line\">        int[] dp = new int[2*sum+1];</div><div class=\"line\">        dp[0+sum] = 1;</div><div class=\"line\">        for(int i = 0; i&lt;nums.length; i++)&#123;</div><div class=\"line\">            int[] next = new int[2*sum+1];</div><div class=\"line\">            for(int k = 0; k&lt;2*sum+1; k++)&#123;</div><div class=\"line\">                if(dp[k]!=0)&#123;</div><div class=\"line\">                    next[k + nums[i]] += dp[k];</div><div class=\"line\">                    next[k - nums[i]] += dp[k];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            dp = next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return dp[sum+s];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Explaination:</p>\n<blockquote>\n<p><img src=\"https://discuss.leetcode.com/uploads/files/1485048726667-screen-shot-2017-01-21-at-8.31.48-pm.jpg\" alt=\"\"></p>\n</blockquote>"},{"title":"Ransom Note","date":"2017-01-12T15:45:36.000Z","_content":"\n> Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.\n>\n> Each letter in the magazine string can only be used once in your ransom note.\n>\n> Note:\n> You may assume that both strings contain only lowercase letters.\n>\n> canConstruct(\"a\", \"b\") -> false\n> canConstruct(\"aa\", \"ab\") -> false\n> canConstruct(\"aa\", \"aab\") -> true\n\n<!--more-->\n\nThis is Leetcode 383 and it is an easy problem. Just notice one thing: whiteSpace, numbers, should be taken into consideration. So the length of the char array should not be only 26.\n\n\n```\nclass Solution {\n    public:\n        bool canConstruct(string ransomNote, string magazine) {\n            int chars[512] = {0};\n            for (int i = 0; i < (int)magazine.size(); i++) {\n                chars[(int)magazine[i]]++;\n            }\n            for (int i = 0; i < (int)ransomNote.size(); i++) {\n                chars[(int)ransomNote[i]]--;\n                if (chars[(int)ransomNote[i]] < 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n};\n```\n\nAnd it gets AC.\n","source":"_posts/RansomNote.md","raw":"---\ntitle: Ransom Note\ndate: 2017-01-12 23:45:36\ntags:\n    - String\n---\n\n> Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.\n>\n> Each letter in the magazine string can only be used once in your ransom note.\n>\n> Note:\n> You may assume that both strings contain only lowercase letters.\n>\n> canConstruct(\"a\", \"b\") -> false\n> canConstruct(\"aa\", \"ab\") -> false\n> canConstruct(\"aa\", \"aab\") -> true\n\n<!--more-->\n\nThis is Leetcode 383 and it is an easy problem. Just notice one thing: whiteSpace, numbers, should be taken into consideration. So the length of the char array should not be only 26.\n\n\n```\nclass Solution {\n    public:\n        bool canConstruct(string ransomNote, string magazine) {\n            int chars[512] = {0};\n            for (int i = 0; i < (int)magazine.size(); i++) {\n                chars[(int)magazine[i]]++;\n            }\n            for (int i = 0; i < (int)ransomNote.size(); i++) {\n                chars[(int)ransomNote[i]]--;\n                if (chars[(int)ransomNote[i]] < 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n};\n```\n\nAnd it gets AC.\n","slug":"RansomNote","published":1,"updated":"2017-01-12T15:58:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5rl001spff4tzp85nqv","content":"<blockquote>\n<p>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.</p>\n<p>Each letter in the magazine string can only be used once in your ransom note.</p>\n<p>Note:<br>You may assume that both strings contain only lowercase letters.</p>\n<p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 383 and it is an easy problem. Just notice one thing: whiteSpace, numbers, should be taken into consideration. So the length of the char array should not be only 26.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool canConstruct(string ransomNote, string magazine) &#123;</div><div class=\"line\">            int chars[512] = &#123;0&#125;;</div><div class=\"line\">            for (int i = 0; i &lt; (int)magazine.size(); i++) &#123;</div><div class=\"line\">                chars[(int)magazine[i]]++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = 0; i &lt; (int)ransomNote.size(); i++) &#123;</div><div class=\"line\">                chars[(int)ransomNote[i]]--;</div><div class=\"line\">                if (chars[(int)ransomNote[i]] &lt; 0) &#123;</div><div class=\"line\">                    return false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.</p>\n<p>Each letter in the magazine string can only be used once in your ransom note.</p>\n<p>Note:<br>You may assume that both strings contain only lowercase letters.</p>\n<p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p>\n</blockquote>","more":"<p>This is Leetcode 383 and it is an easy problem. Just notice one thing: whiteSpace, numbers, should be taken into consideration. So the length of the char array should not be only 26.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool canConstruct(string ransomNote, string magazine) &#123;</div><div class=\"line\">            int chars[512] = &#123;0&#125;;</div><div class=\"line\">            for (int i = 0; i &lt; (int)magazine.size(); i++) &#123;</div><div class=\"line\">                chars[(int)magazine[i]]++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = 0; i &lt; (int)ransomNote.size(); i++) &#123;</div><div class=\"line\">                chars[(int)ransomNote[i]]--;</div><div class=\"line\">                if (chars[(int)ransomNote[i]] &lt; 0) &#123;</div><div class=\"line\">                    return false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>"},{"title":"Teemo Attacking","date":"2017-02-02T12:17:16.000Z","_content":"\n> In LLP world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo's attacking ascending time series towards Ashe and the poisoning time duration per Teemo's attacking, you need to output the total time that Ashe is in poisoned condition.\n>\n> You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.\n>\n> Example 1:\n> + Input: [1,4], 2\n> + Output: 4\n> + Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. This poisoned status will last 2 seconds until the end of time point 2. And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. So you finally need to output 4.\n>\n> Example 2:\n> + Input: [1,2], 2\n> + Output: 3\n> + Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. This poisoned status will last 2 seconds until the end of time point 2. However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. Since the poisoned status won't add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. So you finally need to output 3.\n>\n> Note:\n> + You may assume the length of given time series array won't exceed 10000.\n> + You may assume the numbers in the Teemo's attacking time series and his poisoning time duration per attacking are non-negative integers, which won't exceed 10,000,000.\n\n<!--more-->\n\nThis is Leetcode 495. It is an interesting problem, I like LLP, and Teemo is my favorite hero. So, I understand the problem description quickly and figure it out rapidly.\n\nIts tag is Array but I think use bitset will be a better solution if the time number is small.\n\nHere is the solution:\n\n```\nclass Solution {\n    public:\n        int findPoisonedDuration(vector<int>& timeSeries, int duration) {\n            if (timeSeries.size() == 0) {\n                return 0;\n            }\n\n            int res = 0;\n\n            sort(timeSeries.begin(), timeSeries.end());\n\n            for (int i = 0; i < (int)timeSeries.size() - 1; i++) {\n                if (timeSeries[i] + duration >= timeSeries[i + 1]) {\n                    res = res + (timeSeries[i + 1] - timeSeries[i]);\n                } else {\n                    res = res + duration;\n                }\n            }\n\n            return res + duration;\n        }\n};\n```\n\nSo easy, and it gets AC.\n","source":"_posts/TeemoAttacking.md","raw":"---\ntitle: Teemo Attacking\ndate: 2017-02-02 20:17:16\ntags:\n    - Array\n---\n\n> In LLP world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo's attacking ascending time series towards Ashe and the poisoning time duration per Teemo's attacking, you need to output the total time that Ashe is in poisoned condition.\n>\n> You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.\n>\n> Example 1:\n> + Input: [1,4], 2\n> + Output: 4\n> + Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. This poisoned status will last 2 seconds until the end of time point 2. And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. So you finally need to output 4.\n>\n> Example 2:\n> + Input: [1,2], 2\n> + Output: 3\n> + Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. This poisoned status will last 2 seconds until the end of time point 2. However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. Since the poisoned status won't add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. So you finally need to output 3.\n>\n> Note:\n> + You may assume the length of given time series array won't exceed 10000.\n> + You may assume the numbers in the Teemo's attacking time series and his poisoning time duration per attacking are non-negative integers, which won't exceed 10,000,000.\n\n<!--more-->\n\nThis is Leetcode 495. It is an interesting problem, I like LLP, and Teemo is my favorite hero. So, I understand the problem description quickly and figure it out rapidly.\n\nIts tag is Array but I think use bitset will be a better solution if the time number is small.\n\nHere is the solution:\n\n```\nclass Solution {\n    public:\n        int findPoisonedDuration(vector<int>& timeSeries, int duration) {\n            if (timeSeries.size() == 0) {\n                return 0;\n            }\n\n            int res = 0;\n\n            sort(timeSeries.begin(), timeSeries.end());\n\n            for (int i = 0; i < (int)timeSeries.size() - 1; i++) {\n                if (timeSeries[i] + duration >= timeSeries[i + 1]) {\n                    res = res + (timeSeries[i + 1] - timeSeries[i]);\n                } else {\n                    res = res + duration;\n                }\n            }\n\n            return res + duration;\n        }\n};\n```\n\nSo easy, and it gets AC.\n","slug":"TeemoAttacking","published":1,"updated":"2017-02-02T12:46:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5ro001vpff4fgze3xkt","content":"<blockquote>\n<p>In LLP world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo’s attacking ascending time series towards Ashe and the poisoning time duration per Teemo’s attacking, you need to output the total time that Ashe is in poisoned condition.</p>\n<p>You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: [1,4], 2</li>\n<li>Output: 4</li>\n<li>Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. This poisoned status will last 2 seconds until the end of time point 2. And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. So you finally need to output 4.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: [1,2], 2</li>\n<li>Output: 3</li>\n<li>Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. This poisoned status will last 2 seconds until the end of time point 2. However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. Since the poisoned status won’t add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. So you finally need to output 3.</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>You may assume the length of given time series array won’t exceed 10000.</li>\n<li>You may assume the numbers in the Teemo’s attacking time series and his poisoning time duration per attacking are non-negative integers, which won’t exceed 10,000,000.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 495. It is an interesting problem, I like LLP, and Teemo is my favorite hero. So, I understand the problem description quickly and figure it out rapidly.</p>\n<p>Its tag is Array but I think use bitset will be a better solution if the time number is small.</p>\n<p>Here is the solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findPoisonedDuration(vector&lt;int&gt;&amp; timeSeries, int duration) &#123;</div><div class=\"line\">            if (timeSeries.size() == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int res = 0;</div><div class=\"line\"></div><div class=\"line\">            sort(timeSeries.begin(), timeSeries.end());</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)timeSeries.size() - 1; i++) &#123;</div><div class=\"line\">                if (timeSeries[i] + duration &gt;= timeSeries[i + 1]) &#123;</div><div class=\"line\">                    res = res + (timeSeries[i + 1] - timeSeries[i]);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    res = res + duration;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res + duration;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>So easy, and it gets AC.</p>\n","excerpt":"<blockquote>\n<p>In LLP world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo’s attacking ascending time series towards Ashe and the poisoning time duration per Teemo’s attacking, you need to output the total time that Ashe is in poisoned condition.</p>\n<p>You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: [1,4], 2</li>\n<li>Output: 4</li>\n<li>Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. This poisoned status will last 2 seconds until the end of time point 2. And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. So you finally need to output 4.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: [1,2], 2</li>\n<li>Output: 3</li>\n<li>Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. This poisoned status will last 2 seconds until the end of time point 2. However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. Since the poisoned status won’t add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. So you finally need to output 3.</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>You may assume the length of given time series array won’t exceed 10000.</li>\n<li>You may assume the numbers in the Teemo’s attacking time series and his poisoning time duration per attacking are non-negative integers, which won’t exceed 10,000,000.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 495. It is an interesting problem, I like LLP, and Teemo is my favorite hero. So, I understand the problem description quickly and figure it out rapidly.</p>\n<p>Its tag is Array but I think use bitset will be a better solution if the time number is small.</p>\n<p>Here is the solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findPoisonedDuration(vector&lt;int&gt;&amp; timeSeries, int duration) &#123;</div><div class=\"line\">            if (timeSeries.size() == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int res = 0;</div><div class=\"line\"></div><div class=\"line\">            sort(timeSeries.begin(), timeSeries.end());</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)timeSeries.size() - 1; i++) &#123;</div><div class=\"line\">                if (timeSeries[i] + duration &gt;= timeSeries[i + 1]) &#123;</div><div class=\"line\">                    res = res + (timeSeries[i + 1] - timeSeries[i]);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    res = res + duration;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res + duration;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>So easy, and it gets AC.</p>"},{"title":"Total Hamming Distance","date":"2017-01-02T05:46:25.000Z","_content":"\n> The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\n>\n> Now your job is to find the total Hamming distance between all pairs of the given numbers.\n>\n> Example:\n>\n> Input: 4, 14, 2\n> Output: 6\n>\n> Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just\n> showing the four bits relevant in this case). So the answer will be:\n> HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\n>\n> Note:\n> + Elements of the given array are in the range of 0 to 10^9\n> + Length of the array will not exceed 10^4.\n>\n> Subscribe to see which companies asked this question\n\n<!--more-->\n\nThis is the leetcode No.477, we can quickly find a solution like this:\n\n```\nusing namespace std;\n\nclass Solution {\npublic:\n    int totalHammingDistance(vector<int>& nums) {\n        int sum = 0;\n        for (int i = 0; i < (int)nums.size() - 1; i++) {\n            for (int j = i + 1; j < (int)nums.size(); j++) {\n                sum += hamming_distance(nums[i], nums[j]);\n            }\n        }\n        return sum;\n    }\n\n    int hamming_distance(unsigned long long x, unsigned long long y) {\n        return __builtin_popcountll(x ^ y);\n    }\n};\n```\n\nIt is correct, however it time complex is O(n^2), and the result is TLE.\n\nSo, I found a better solution here. As we can see from the question, we can find the number is int type, and no larger than 2^32 in that we use a 32 bit size bitmap. For better explaination, I use 8 bit size as example.\n\n```\n0000 0000\n1110 0010\n1101 0101\n```\n\nWe get such an array, and we just need to figure out how many 1s in each index. Take 1st index as an example, we get one 1 bit, and the total distance for the 1st index is (3-1)*(1) which stands for (n - bitCount) * bitCount.\n\nSo, what we should do is to add the total 32 bits.\n\nLast, here comes to a solution:\n\n```\nint totalHammingDistance(vector<int>& nums) {\n    int total = 0, bitCount = 0;\n    for (int idx = 0; idx < 32; idx++) {\n        for (int i = 0; i < (int)nums.size(); i++) {\n            bitCount += (nums[i] >> idx) & 1;\n        }\n        total += bitCount * (nums.size() - bitCount);\n    }\n    return total;\n}\n```\n\nAnd it's time complex is O(n*32) which means O(n) and it's accepted.\n","source":"_posts/TotalHammingDistance.md","raw":"---\ntitle: Total Hamming Distance\ndate: 2017-01-02 13:46:25\ntags: \n    - Bitmap\n---\n\n> The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\n>\n> Now your job is to find the total Hamming distance between all pairs of the given numbers.\n>\n> Example:\n>\n> Input: 4, 14, 2\n> Output: 6\n>\n> Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just\n> showing the four bits relevant in this case). So the answer will be:\n> HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\n>\n> Note:\n> + Elements of the given array are in the range of 0 to 10^9\n> + Length of the array will not exceed 10^4.\n>\n> Subscribe to see which companies asked this question\n\n<!--more-->\n\nThis is the leetcode No.477, we can quickly find a solution like this:\n\n```\nusing namespace std;\n\nclass Solution {\npublic:\n    int totalHammingDistance(vector<int>& nums) {\n        int sum = 0;\n        for (int i = 0; i < (int)nums.size() - 1; i++) {\n            for (int j = i + 1; j < (int)nums.size(); j++) {\n                sum += hamming_distance(nums[i], nums[j]);\n            }\n        }\n        return sum;\n    }\n\n    int hamming_distance(unsigned long long x, unsigned long long y) {\n        return __builtin_popcountll(x ^ y);\n    }\n};\n```\n\nIt is correct, however it time complex is O(n^2), and the result is TLE.\n\nSo, I found a better solution here. As we can see from the question, we can find the number is int type, and no larger than 2^32 in that we use a 32 bit size bitmap. For better explaination, I use 8 bit size as example.\n\n```\n0000 0000\n1110 0010\n1101 0101\n```\n\nWe get such an array, and we just need to figure out how many 1s in each index. Take 1st index as an example, we get one 1 bit, and the total distance for the 1st index is (3-1)*(1) which stands for (n - bitCount) * bitCount.\n\nSo, what we should do is to add the total 32 bits.\n\nLast, here comes to a solution:\n\n```\nint totalHammingDistance(vector<int>& nums) {\n    int total = 0, bitCount = 0;\n    for (int idx = 0; idx < 32; idx++) {\n        for (int i = 0; i < (int)nums.size(); i++) {\n            bitCount += (nums[i] >> idx) & 1;\n        }\n        total += bitCount * (nums.size() - bitCount);\n    }\n    return total;\n}\n```\n\nAnd it's time complex is O(n*32) which means O(n) and it's accepted.\n","slug":"TotalHammingDistance","published":1,"updated":"2017-01-13T03:10:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5rp001xpff4xbyylze2","content":"<blockquote>\n<p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p>\n<p>Now your job is to find the total Hamming distance between all pairs of the given numbers.</p>\n<p>Example:</p>\n<p>Input: 4, 14, 2<br>Output: 6</p>\n<p>Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just<br>showing the four bits relevant in this case). So the answer will be:<br>HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</p>\n<p>Note:</p>\n<ul>\n<li>Elements of the given array are in the range of 0 to 10^9</li>\n<li>Length of the array will not exceed 10^4.</li>\n</ul>\n<p>Subscribe to see which companies asked this question</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is the leetcode No.477, we can quickly find a solution like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">        int sum = 0;</div><div class=\"line\">        for (int i = 0; i &lt; (int)nums.size() - 1; i++) &#123;</div><div class=\"line\">            for (int j = i + 1; j &lt; (int)nums.size(); j++) &#123;</div><div class=\"line\">                sum += hamming_distance(nums[i], nums[j]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return sum;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int hamming_distance(unsigned long long x, unsigned long long y) &#123;</div><div class=\"line\">        return __builtin_popcountll(x ^ y);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It is correct, however it time complex is O(n^2), and the result is TLE.</p>\n<p>So, I found a better solution here. As we can see from the question, we can find the number is int type, and no larger than 2^32 in that we use a 32 bit size bitmap. For better explaination, I use 8 bit size as example.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">0000 0000</div><div class=\"line\">1110 0010</div><div class=\"line\">1101 0101</div></pre></td></tr></table></figure>\n<p>We get such an array, and we just need to figure out how many 1s in each index. Take 1st index as an example, we get one 1 bit, and the total distance for the 1st index is (3-1)<em>(1) which stands for (n - bitCount) </em> bitCount.</p>\n<p>So, what we should do is to add the total 32 bits.</p>\n<p>Last, here comes to a solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    int total = 0, bitCount = 0;</div><div class=\"line\">    for (int idx = 0; idx &lt; 32; idx++) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">            bitCount += (nums[i] &gt;&gt; idx) &amp; 1;</div><div class=\"line\">        &#125;</div><div class=\"line\">        total += bitCount * (nums.size() - bitCount);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return total;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>And it’s time complex is O(n*32) which means O(n) and it’s accepted.</p>\n","excerpt":"<blockquote>\n<p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p>\n<p>Now your job is to find the total Hamming distance between all pairs of the given numbers.</p>\n<p>Example:</p>\n<p>Input: 4, 14, 2<br>Output: 6</p>\n<p>Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just<br>showing the four bits relevant in this case). So the answer will be:<br>HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</p>\n<p>Note:</p>\n<ul>\n<li>Elements of the given array are in the range of 0 to 10^9</li>\n<li>Length of the array will not exceed 10^4.</li>\n</ul>\n<p>Subscribe to see which companies asked this question</p>\n</blockquote>","more":"<p>This is the leetcode No.477, we can quickly find a solution like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">        int sum = 0;</div><div class=\"line\">        for (int i = 0; i &lt; (int)nums.size() - 1; i++) &#123;</div><div class=\"line\">            for (int j = i + 1; j &lt; (int)nums.size(); j++) &#123;</div><div class=\"line\">                sum += hamming_distance(nums[i], nums[j]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return sum;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int hamming_distance(unsigned long long x, unsigned long long y) &#123;</div><div class=\"line\">        return __builtin_popcountll(x ^ y);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It is correct, however it time complex is O(n^2), and the result is TLE.</p>\n<p>So, I found a better solution here. As we can see from the question, we can find the number is int type, and no larger than 2^32 in that we use a 32 bit size bitmap. For better explaination, I use 8 bit size as example.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">0000 0000</div><div class=\"line\">1110 0010</div><div class=\"line\">1101 0101</div></pre></td></tr></table></figure>\n<p>We get such an array, and we just need to figure out how many 1s in each index. Take 1st index as an example, we get one 1 bit, and the total distance for the 1st index is (3-1)<em>(1) which stands for (n - bitCount) </em> bitCount.</p>\n<p>So, what we should do is to add the total 32 bits.</p>\n<p>Last, here comes to a solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    int total = 0, bitCount = 0;</div><div class=\"line\">    for (int idx = 0; idx &lt; 32; idx++) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">            bitCount += (nums[i] &gt;&gt; idx) &amp; 1;</div><div class=\"line\">        &#125;</div><div class=\"line\">        total += bitCount * (nums.size() - bitCount);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return total;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>And it’s time complex is O(n*32) which means O(n) and it’s accepted.</p>"},{"title":"Unique Substrings in Wraparound String","date":"2017-01-30T14:33:40.000Z","_content":"\n> Consider the string s to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so s will look like this: \"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\".\n>\n> Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s.\n>\n> Note: p consists of only lowercase English letters and the size of p might be over 10000.\n>\n> Example 1:\n> + Input: \"a\"\n> + Output: 1\n> + Explanation: Only the substring \"a\" of string \"a\" is in the string \u0010s.\n>\n> Example 2:\n> + Input: \"cac\"\n> + Output: 2\n> + Explanation: There are two substrings \"a\", \"c\" of string \"cac\" in the string s.\n>\n> Example 3:\n> + Input: \"zab\"\n> + Output: 6\n> + Explanation: There are six substrings \"z\", \"a\", \"b\", \"za\", \"ab\", \"zab\" of string \"zab\" in the string s.\n\n<!--more-->\n\nThis is Leetcode 467. And it's a easy DP problem. Here is my solution:\n\n```\nclass Solution {\n\n    public:\n        int findSubstringInWraproundString(string p) {\n            vector<int> letters(26, 0);\n            int res = 0, len = 0;\n            for (int i = 0; i < (int)p.size(); i++) {\n                int cur = p[i] - 'a';\n                if (i > 0 && p[i - 1] != (cur + 26 - 1) % 26 + 'a') len = 0;\n                if (++len > letters[cur]) {\n                    res += len - letters[cur];\n                    letters[cur] = len;\n                }\n            }\n            return res;\n        }\n};\n\n```\n\nAnd, it gets AC.\n","source":"_posts/UniqueSubstringsinWraparoundString.md","raw":"---\ntitle: Unique Substrings in Wraparound String\ndate: 2017-01-30 22:33:40\ntags:\n    - Dynamic Programming\n---\n\n> Consider the string s to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so s will look like this: \"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\".\n>\n> Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s.\n>\n> Note: p consists of only lowercase English letters and the size of p might be over 10000.\n>\n> Example 1:\n> + Input: \"a\"\n> + Output: 1\n> + Explanation: Only the substring \"a\" of string \"a\" is in the string \u0010s.\n>\n> Example 2:\n> + Input: \"cac\"\n> + Output: 2\n> + Explanation: There are two substrings \"a\", \"c\" of string \"cac\" in the string s.\n>\n> Example 3:\n> + Input: \"zab\"\n> + Output: 6\n> + Explanation: There are six substrings \"z\", \"a\", \"b\", \"za\", \"ab\", \"zab\" of string \"zab\" in the string s.\n\n<!--more-->\n\nThis is Leetcode 467. And it's a easy DP problem. Here is my solution:\n\n```\nclass Solution {\n\n    public:\n        int findSubstringInWraproundString(string p) {\n            vector<int> letters(26, 0);\n            int res = 0, len = 0;\n            for (int i = 0; i < (int)p.size(); i++) {\n                int cur = p[i] - 'a';\n                if (i > 0 && p[i - 1] != (cur + 26 - 1) % 26 + 'a') len = 0;\n                if (++len > letters[cur]) {\n                    res += len - letters[cur];\n                    letters[cur] = len;\n                }\n            }\n            return res;\n        }\n};\n\n```\n\nAnd, it gets AC.\n","slug":"UniqueSubstringsinWraparoundString","published":1,"updated":"2017-01-30T15:07:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5rq0020pff479vqpkvc","content":"<blockquote>\n<p>Consider the string s to be the infinite wraparound string of “abcdefghijklmnopqrstuvwxyz”, so s will look like this: “…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd….”.</p>\n<p>Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s.</p>\n<p>Note: p consists of only lowercase English letters and the size of p might be over 10000.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: “a”</li>\n<li>Output: 1</li>\n<li>Explanation: Only the substring “a” of string “a” is in the string \u0010s.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: “cac”</li>\n<li>Output: 2</li>\n<li>Explanation: There are two substrings “a”, “c” of string “cac” in the string s.</li>\n</ul>\n<p>Example 3:</p>\n<ul>\n<li>Input: “zab”</li>\n<li>Output: 6</li>\n<li>Explanation: There are six substrings “z”, “a”, “b”, “za”, “ab”, “zab” of string “zab” in the string s.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 467. And it’s a easy DP problem. Here is my solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\"></div><div class=\"line\">    public:</div><div class=\"line\">        int findSubstringInWraproundString(string p) &#123;</div><div class=\"line\">            vector&lt;int&gt; letters(26, 0);</div><div class=\"line\">            int res = 0, len = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)p.size(); i++) &#123;</div><div class=\"line\">                int cur = p[i] - &apos;a&apos;;</div><div class=\"line\">                if (i &gt; 0 &amp;&amp; p[i - 1] != (cur + 26 - 1) % 26 + &apos;a&apos;) len = 0;</div><div class=\"line\">                if (++len &gt; letters[cur]) &#123;</div><div class=\"line\">                    res += len - letters[cur];</div><div class=\"line\">                    letters[cur] = len;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And, it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Consider the string s to be the infinite wraparound string of “abcdefghijklmnopqrstuvwxyz”, so s will look like this: “…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd….”.</p>\n<p>Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s.</p>\n<p>Note: p consists of only lowercase English letters and the size of p might be over 10000.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: “a”</li>\n<li>Output: 1</li>\n<li>Explanation: Only the substring “a” of string “a” is in the string \u0010s.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: “cac”</li>\n<li>Output: 2</li>\n<li>Explanation: There are two substrings “a”, “c” of string “cac” in the string s.</li>\n</ul>\n<p>Example 3:</p>\n<ul>\n<li>Input: “zab”</li>\n<li>Output: 6</li>\n<li>Explanation: There are six substrings “z”, “a”, “b”, “za”, “ab”, “zab” of string “zab” in the string s.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 467. And it’s a easy DP problem. Here is my solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\"></div><div class=\"line\">    public:</div><div class=\"line\">        int findSubstringInWraproundString(string p) &#123;</div><div class=\"line\">            vector&lt;int&gt; letters(26, 0);</div><div class=\"line\">            int res = 0, len = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)p.size(); i++) &#123;</div><div class=\"line\">                int cur = p[i] - &apos;a&apos;;</div><div class=\"line\">                if (i &gt; 0 &amp;&amp; p[i - 1] != (cur + 26 - 1) % 26 + &apos;a&apos;) len = 0;</div><div class=\"line\">                if (++len &gt; letters[cur]) &#123;</div><div class=\"line\">                    res += len - letters[cur];</div><div class=\"line\">                    letters[cur] = len;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And, it gets AC.</p>"},{"title":"Valid Perfect Square","date":"2017-01-25T14:15:29.000Z","_content":"\n> Given a positive integer num, write a function which returns True if num is a perfect square else False.\n>\n> Note: Do not use any built-in library function such as sqrt.\n>\n> Example 1:\n> + Input: 16\n> + Returns: True\n>\n> Example 2:\n> + Input: 14\n> + Returns: False\n\n<!--more-->\n\nIt's Leetcode 367. Easy problem, but it's easy to get wrong when the mid * mid is larger than the INT_MAX.\n\n```\nclass Solution {\n    public:\n        bool isPerfectSquare(int num) {\n            long long start = 0, end = num; // use long long to avoid such a case\n            while (start <= end) {\n                long long mid = end - ((end - start) / 2);\n                if (mid * mid == num) {\n                    return true;\n                } else if (mid * mid > num) {\n                    end = mid - 1;\n                } else {\n                    start = mid + 1;\n                }\n            }\n            return false;\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/ValidPerfectSquare.md","raw":"---\ntitle: Valid Perfect Square\ndate: 2017-01-25 22:15:29\ntags:\n    - Binary Search\n    - Math\n---\n\n> Given a positive integer num, write a function which returns True if num is a perfect square else False.\n>\n> Note: Do not use any built-in library function such as sqrt.\n>\n> Example 1:\n> + Input: 16\n> + Returns: True\n>\n> Example 2:\n> + Input: 14\n> + Returns: False\n\n<!--more-->\n\nIt's Leetcode 367. Easy problem, but it's easy to get wrong when the mid * mid is larger than the INT_MAX.\n\n```\nclass Solution {\n    public:\n        bool isPerfectSquare(int num) {\n            long long start = 0, end = num; // use long long to avoid such a case\n            while (start <= end) {\n                long long mid = end - ((end - start) / 2);\n                if (mid * mid == num) {\n                    return true;\n                } else if (mid * mid > num) {\n                    end = mid - 1;\n                } else {\n                    start = mid + 1;\n                }\n            }\n            return false;\n        }\n};\n```\n\nIt gets AC.\n","slug":"ValidPerfectSquare","published":1,"updated":"2017-01-25T14:25:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciywhq5rr0022pff4ty3gxftm","content":"<blockquote>\n<p>Given a positive integer num, write a function which returns True if num is a perfect square else False.</p>\n<p>Note: Do not use any built-in library function such as sqrt.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: 16</li>\n<li>Returns: True</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: 14</li>\n<li>Returns: False</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>It’s Leetcode 367. Easy problem, but it’s easy to get wrong when the mid * mid is larger than the INT_MAX.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool isPerfectSquare(int num) &#123;</div><div class=\"line\">            long long start = 0, end = num; // use long long to avoid such a case</div><div class=\"line\">            while (start &lt;= end) &#123;</div><div class=\"line\">                long long mid = end - ((end - start) / 2);</div><div class=\"line\">                if (mid * mid == num) &#123;</div><div class=\"line\">                    return true;</div><div class=\"line\">                &#125; else if (mid * mid &gt; num) &#123;</div><div class=\"line\">                    end = mid - 1;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    start = mid + 1;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a positive integer num, write a function which returns True if num is a perfect square else False.</p>\n<p>Note: Do not use any built-in library function such as sqrt.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: 16</li>\n<li>Returns: True</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: 14</li>\n<li>Returns: False</li>\n</ul>\n</blockquote>","more":"<p>It’s Leetcode 367. Easy problem, but it’s easy to get wrong when the mid * mid is larger than the INT_MAX.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool isPerfectSquare(int num) &#123;</div><div class=\"line\">            long long start = 0, end = num; // use long long to avoid such a case</div><div class=\"line\">            while (start &lt;= end) &#123;</div><div class=\"line\">                long long mid = end - ((end - start) / 2);</div><div class=\"line\">                if (mid * mid == num) &#123;</div><div class=\"line\">                    return true;</div><div class=\"line\">                &#125; else if (mid * mid &gt; num) &#123;</div><div class=\"line\">                    end = mid - 1;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    start = mid + 1;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ciywhq5pk0000pff4ucah6t66","tag_id":"ciywhq5pr0002pff4a1hentuo","_id":"ciywhq5q00007pff4ygkhhin4"},{"post_id":"ciywhq5po0001pff4nh2393lr","tag_id":"ciywhq5q00006pff40o5k8pk3","_id":"ciywhq5q9000cpff4xsnkwr08"},{"post_id":"ciywhq5pu0003pff41r8fjk4b","tag_id":"ciywhq5q8000apff48qxu88ry","_id":"ciywhq5qd000gpff41kaohiha"},{"post_id":"ciywhq5pv0004pff43gk7tz63","tag_id":"ciywhq5q00006pff40o5k8pk3","_id":"ciywhq5qh000kpff4b04n7wuq"},{"post_id":"ciywhq5py0005pff47rm9pv72","tag_id":"ciywhq5q00006pff40o5k8pk3","_id":"ciywhq5qj000opff44o7iiocn"},{"post_id":"ciywhq5q10008pff4eaqpv7hr","tag_id":"ciywhq5pr0002pff4a1hentuo","_id":"ciywhq5qp000spff4xo5e4cq4"},{"post_id":"ciywhq5q10008pff4eaqpv7hr","tag_id":"ciywhq5qi000mpff4nck6lp22","_id":"ciywhq5qq000upff491uu1bnr"},{"post_id":"ciywhq5q30009pff4p1lmmb6r","tag_id":"ciywhq5qn000qpff4daiv0mcg","_id":"ciywhq5qs000xpff4skvorbsa"},{"post_id":"ciywhq5qr000vpff4m243rdis","tag_id":"ciywhq5qi000mpff4nck6lp22","_id":"ciywhq5qt000zpff43zkq9vd1"},{"post_id":"ciywhq5qs000ypff4uxy5o544","tag_id":"ciywhq5q00006pff40o5k8pk3","_id":"ciywhq5qv0012pff43gloyr1c"},{"post_id":"ciywhq5q9000bpff44sdu2eew","tag_id":"ciywhq5qr000wpff4djiex1r6","_id":"ciywhq5r7001apff4tqc1aoyx"},{"post_id":"ciywhq5q9000bpff44sdu2eew","tag_id":"ciywhq5qv0011pff4xqfdw3j9","_id":"ciywhq5r8001cpff4u7yjm5s7"},{"post_id":"ciywhq5q9000bpff44sdu2eew","tag_id":"ciywhq5qy0015pff4sdef49i6","_id":"ciywhq5r9001fpff4vxtdtn56"},{"post_id":"ciywhq5r30017pff42s3ywqeo","tag_id":"ciywhq5qv0011pff4xqfdw3j9","_id":"ciywhq5rb001hpff495qlelob"},{"post_id":"ciywhq5r7001bpff422yv22fr","tag_id":"ciywhq5q00006pff40o5k8pk3","_id":"ciywhq5rd001kpff4rn0nllkq"},{"post_id":"ciywhq5r8001dpff4hn078qjo","tag_id":"ciywhq5q00006pff40o5k8pk3","_id":"ciywhq5rg001mpff4b8kppqjb"},{"post_id":"ciywhq5ra001gpff4qr0ra37s","tag_id":"ciywhq5qn000qpff4daiv0mcg","_id":"ciywhq5ri001ppff46z50dxzv"},{"post_id":"ciywhq5qa000dpff4naulfqgm","tag_id":"ciywhq5r50018pff47nsx5re5","_id":"ciywhq5rl001rpff4p6wl2abl"},{"post_id":"ciywhq5qa000dpff4naulfqgm","tag_id":"ciywhq5r9001epff4xg3fqisr","_id":"ciywhq5rn001upff4kaktgfrc"},{"post_id":"ciywhq5rh001npff4vcm4dj7h","tag_id":"ciywhq5qv0011pff4xqfdw3j9","_id":"ciywhq5ro001wpff4njavbkqy"},{"post_id":"ciywhq5ri001qpff4lgt2ejm4","tag_id":"ciywhq5qi000mpff4nck6lp22","_id":"ciywhq5rq001zpff4r285nx9g"},{"post_id":"ciywhq5ri001qpff4lgt2ejm4","tag_id":"ciywhq5q00006pff40o5k8pk3","_id":"ciywhq5rr0021pff4id6tvdcn"},{"post_id":"ciywhq5qc000fpff4mz3wx6i5","tag_id":"ciywhq5qi000mpff4nck6lp22","_id":"ciywhq5rt0024pff4gbsz7bdk"},{"post_id":"ciywhq5qc000fpff4mz3wx6i5","tag_id":"ciywhq5qn000qpff4daiv0mcg","_id":"ciywhq5ru0025pff49enj6h5j"},{"post_id":"ciywhq5rl001spff4tzp85nqv","tag_id":"ciywhq5r9001epff4xg3fqisr","_id":"ciywhq5rv0027pff4j6wxkf19"},{"post_id":"ciywhq5ro001vpff4fgze3xkt","tag_id":"ciywhq5qv0011pff4xqfdw3j9","_id":"ciywhq5rv0028pff4chvm3be6"},{"post_id":"ciywhq5qe000hpff4p3p5ts2w","tag_id":"ciywhq5qr000wpff4djiex1r6","_id":"ciywhq5rw002apff4nyb33tzf"},{"post_id":"ciywhq5rq0020pff479vqpkvc","tag_id":"ciywhq5q00006pff40o5k8pk3","_id":"ciywhq5rw002bpff4hpurqz23"},{"post_id":"ciywhq5qg000jpff40wa4xavv","tag_id":"ciywhq5qi000mpff4nck6lp22","_id":"ciywhq5rx002dpff4q69xom8u"},{"post_id":"ciywhq5qh000lpff4wvmt3yzu","tag_id":"ciywhq5qr000wpff4djiex1r6","_id":"ciywhq5rx002fpff4ayvuzc1l"},{"post_id":"ciywhq5qh000lpff4wvmt3yzu","tag_id":"ciywhq5r50018pff47nsx5re5","_id":"ciywhq5rx002gpff49155n2ns"},{"post_id":"ciywhq5qh000lpff4wvmt3yzu","tag_id":"ciywhq5qy0015pff4sdef49i6","_id":"ciywhq5ry002ipff4q7fagtrg"},{"post_id":"ciywhq5qh000lpff4wvmt3yzu","tag_id":"ciywhq5rw002cpff4j6etkvgk","_id":"ciywhq5ry002jpff4wlm6pj35"},{"post_id":"ciywhq5qi000npff42kggtbdf","tag_id":"ciywhq5rx002epff4pm2667mw","_id":"ciywhq5ry002lpff4sex19c2b"},{"post_id":"ciywhq5qi000npff42kggtbdf","tag_id":"ciywhq5rx002hpff45k01ftit","_id":"ciywhq5ry002mpff4s029vzp7"},{"post_id":"ciywhq5qk000ppff4ee03a9n8","tag_id":"ciywhq5rx002epff4pm2667mw","_id":"ciywhq5rz002opff40hbwlcv5"},{"post_id":"ciywhq5qk000ppff4ee03a9n8","tag_id":"ciywhq5q00006pff40o5k8pk3","_id":"ciywhq5rz002ppff4khw5tzfg"},{"post_id":"ciywhq5qn000rpff4g49nf6qy","tag_id":"ciywhq5qi000mpff4nck6lp22","_id":"ciywhq5s0002spff4xlfb2tzx"},{"post_id":"ciywhq5qn000rpff4g49nf6qy","tag_id":"ciywhq5ry002npff4n2kiavfo","_id":"ciywhq5s0002tpff4j5gyivk7"},{"post_id":"ciywhq5qn000rpff4g49nf6qy","tag_id":"ciywhq5rz002qpff46s7m1ocb","_id":"ciywhq5s1002vpff40bt9woeq"},{"post_id":"ciywhq5qp000tpff4i0bssx3j","tag_id":"ciywhq5r9001epff4xg3fqisr","_id":"ciywhq5s1002wpff466mjyosl"},{"post_id":"ciywhq5qt0010pff4duxx9tal","tag_id":"ciywhq5rx002hpff45k01ftit","_id":"ciywhq5s1002ypff4zubxvrme"},{"post_id":"ciywhq5qw0013pff4wlbodbgd","tag_id":"ciywhq5rx002epff4pm2667mw","_id":"ciywhq5s20030pff49zk1sk9w"},{"post_id":"ciywhq5qx0014pff46r3ybbp7","tag_id":"ciywhq5s2002zpff4x7dbl462","_id":"ciywhq5s30032pff4edlpdlno"},{"post_id":"ciywhq5qz0016pff4006p805t","tag_id":"ciywhq5qn000qpff4daiv0mcg","_id":"ciywhq5s40034pff4ccqor1yr"},{"post_id":"ciywhq5qz0016pff4006p805t","tag_id":"ciywhq5r50018pff47nsx5re5","_id":"ciywhq5s40035pff4ba5okv5r"},{"post_id":"ciywhq5r50019pff4jkomcw9z","tag_id":"ciywhq5rx002hpff45k01ftit","_id":"ciywhq5s50037pff4r990ug8d"},{"post_id":"ciywhq5rc001ipff44yd6q5yz","tag_id":"ciywhq5q00006pff40o5k8pk3","_id":"ciywhq5s7003apff4da8s324f"},{"post_id":"ciywhq5rc001ipff44yd6q5yz","tag_id":"ciywhq5rx002epff4pm2667mw","_id":"ciywhq5s7003bpff4oipwzxct"},{"post_id":"ciywhq5rc001ipff44yd6q5yz","tag_id":"ciywhq5s50038pff4x3i1ijqj","_id":"ciywhq5s9003dpff4kyijjokt"},{"post_id":"ciywhq5rd001lpff4cvvpv0cl","tag_id":"ciywhq5q00006pff40o5k8pk3","_id":"ciywhq5s9003epff4ojacb5vq"},{"post_id":"ciywhq5rd001lpff4cvvpv0cl","tag_id":"ciywhq5s50039pff451yoryqk","_id":"ciywhq5sa003gpff4akehmtgk"},{"post_id":"ciywhq5rp001xpff4xbyylze2","tag_id":"ciywhq5rx002hpff45k01ftit","_id":"ciywhq5sa003hpff49yzgcggw"},{"post_id":"ciywhq5rr0022pff4ty3gxftm","tag_id":"ciywhq5qr000wpff4djiex1r6","_id":"ciywhq5sb003ipff41iwbo8ka"},{"post_id":"ciywhq5rr0022pff4ty3gxftm","tag_id":"ciywhq5rx002epff4pm2667mw","_id":"ciywhq5sb003jpff4z66vrjt2"}],"Tag":[{"name":"Stack","_id":"ciywhq5pr0002pff4a1hentuo"},{"name":"Dynamic Programming","_id":"ciywhq5q00006pff40o5k8pk3"},{"name":"Simulation","_id":"ciywhq5q8000apff48qxu88ry"},{"name":"Depth-first Search","_id":"ciywhq5qi000mpff4nck6lp22"},{"name":"Tree","_id":"ciywhq5qn000qpff4daiv0mcg"},{"name":"Binary Search","_id":"ciywhq5qr000wpff4djiex1r6"},{"name":"Array","_id":"ciywhq5qv0011pff4xqfdw3j9"},{"name":"Two Pointers","_id":"ciywhq5qy0015pff4sdef49i6"},{"name":"Hash Table","_id":"ciywhq5r50018pff47nsx5re5"},{"name":"String","_id":"ciywhq5r9001epff4xg3fqisr"},{"name":"Sort","_id":"ciywhq5rw002cpff4j6etkvgk"},{"name":"Math","_id":"ciywhq5rx002epff4pm2667mw"},{"name":"Bitmap","_id":"ciywhq5rx002hpff45k01ftit"},{"name":"Memoization","_id":"ciywhq5ry002npff4n2kiavfo"},{"name":"Topological sort","_id":"ciywhq5rz002qpff46s7m1ocb"},{"name":"Description","_id":"ciywhq5s2002zpff4x7dbl462"},{"name":"Breadth-first Search","_id":"ciywhq5s50038pff4x3i1ijqj"},{"name":"Minimax","_id":"ciywhq5s50039pff451yoryqk"}]}}