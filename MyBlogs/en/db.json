{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/apollo/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":0,"renderable":1},{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":0,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":0,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":0,"renderable":1}],"Cache":[{"_id":"themes/apollo/_config.yml","hash":"f65fed4069d98c155406d7d781ad73d0b817be4d","modified":1483958861000},{"_id":"themes/apollo/gulpfile.js","hash":"857a026b6643a2cd52c65d4ae0dc7fe9618206ee","modified":1483958398000},{"_id":"themes/apollo/LICENSE","hash":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1483958398000},{"_id":"themes/apollo/.gitignore","hash":"a006beea0877a0aa3610ee00e73f62cb1d45125b","modified":1483958398000},{"_id":"themes/apollo/package.json","hash":"eb1e76ec0b7ed6c6c7b2bd32b4f1e1bbe15800ca","modified":1483958398000},{"_id":"themes/apollo/README.md","hash":"201c76d030a98578ed5a6ad5c766a7bde91c32d3","modified":1483958398000},{"_id":"source/_posts/GroupAnagrams.md","hash":"a8c2b50cc1279e87ab542c3cf02349bc45eff683","modified":1484029048000},{"_id":"source/_posts/132Pattern.md","hash":"b3231694a12d04c8e059841ac9b78868ef04be05","modified":1483495208000},{"_id":"source/_posts/BattleshipsinaBoard.md","hash":"7b802fc1894ee7a8064d72053fad5abcb5ec4a8f","modified":1483595187000},{"_id":"source/_posts/Heaters.md","hash":"f6b1d02ddd7647d8cd6512efefe8f0b2c9205f93","modified":1483507667000},{"_id":"source/_posts/IntersectionofTwoArraysII.md","hash":"99d1ce4e9874ac725ecf2079404fcf40ab4f4faf","modified":1483887680000},{"_id":"source/_posts/LongestIncreasingPathinaMatrix.md","hash":"b0c9d9cc27c46fd7d00e96a11eee85694aa63ab0","modified":1483950266000},{"_id":"source/_posts/NewStart.md","hash":"8e373a9c4e54ad72603e05d0edd11cdfeb3a0673","modified":1483426041000},{"_id":"source/_posts/PartitionEqualSubsetSum.md","hash":"09b3f969a58407ef3d7f0bc52dcc423044999387","modified":1483691844000},{"_id":"source/_posts/PathSumIII.md","hash":"a130adbb00393e837e3243522a8502bb57d4c73e","modified":1483804827000},{"_id":"source/_posts/TotalHammingDistance.md","hash":"c44ffcf424f702efdb91945decaed6e68d9e0941","modified":1483426048000},{"_id":"themes/apollo/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1483958398000},{"_id":"themes/apollo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1483958391000},{"_id":"themes/apollo/.git/config","hash":"e8486e77527181934f2dda23e50b879ab7641244","modified":1483958398000},{"_id":"themes/apollo/.git/index","hash":"b8d892235126d9650a92a3e97bb420f5e245d749","modified":1483958497000},{"_id":"themes/apollo/.git/packed-refs","hash":"baa5eb6eb429b61eb5b65e1d8615b6f8b1e63432","modified":1483958398000},{"_id":"themes/apollo/languages/en.yml","hash":"40292f2a48e4e6361132033a47c516cb33127b6c","modified":1483958398000},{"_id":"themes/apollo/source/favicon.ico","hash":"b8eb4ec54a6ce48e939cfdcb775493d3d0ab58ef","modified":1483958555000},{"_id":"themes/apollo/layout/post.jade","hash":"245c26244c075c3632d1545c3b228ee9d112f15d","modified":1483958398000},{"_id":"themes/apollo/layout/archive.jade","hash":"62797414355bf4474092bc3a32726c8340820ffb","modified":1483958398000},{"_id":"themes/apollo/languages/zh-cn.yml","hash":"9e4b03e14c094000257ea254fd660dde4c7af63c","modified":1483958398000},{"_id":"themes/apollo/layout/index.jade","hash":"55f2f1b4b5364a0e09cb18e1112664c6415fb881","modified":1483958398000},{"_id":"themes/apollo/doc/doc-zh.md","hash":"d43c1f6bff66426744a2c6f031d19ff09cdeb2d1","modified":1483958398000},{"_id":"themes/apollo/doc/doc-en.md","hash":"d6d9756b2085cdd8ee51eb5594427e2abf170e94","modified":1483958398000},{"_id":"themes/apollo/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1483958391000},{"_id":"themes/apollo/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1483958391000},{"_id":"themes/apollo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1483958391000},{"_id":"themes/apollo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1483958391000},{"_id":"themes/apollo/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1483958391000},{"_id":"themes/apollo/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1483958391000},{"_id":"themes/apollo/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1483958391000},{"_id":"themes/apollo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1483958391000},{"_id":"themes/apollo/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1483958391000},{"_id":"themes/apollo/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1483958391000},{"_id":"themes/apollo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1483958391000},{"_id":"themes/apollo/.git/logs/HEAD","hash":"8701c2898a90aaf4191288a1309b18b7dd32c70d","modified":1483958398000},{"_id":"themes/apollo/source/css/apollo.css","hash":"57bbf3eb1a5ff9d92e7b65b9d9abe4012c28a4b4","modified":1483958814000},{"_id":"themes/apollo/source/scss/apollo.scss","hash":"e0092f469264b55b25e0d441274f1c812147e7d1","modified":1483958398000},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1483958398000},{"_id":"themes/apollo/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1483958398000},{"_id":"themes/apollo/layout/mixins/post.jade","hash":"cd9447e9b0ad22213e6a17d9a9b948f9f998f921","modified":1483958398000},{"_id":"themes/apollo/layout/partial/comment.jade","hash":"ff0a2c269c2434da2ac5529872f1d6184a71f96d","modified":1483958398000},{"_id":"themes/apollo/layout/mixins/paginator.jade","hash":"f4ee2fb61a32e199b48cf93771749edc8a007391","modified":1483958398000},{"_id":"themes/apollo/layout/partial/copyright.jade","hash":"217f8b17054e5079f2d30bb7e2e4e36c0f2161b7","modified":1483958398000},{"_id":"themes/apollo/layout/partial/head.jade","hash":"05c64904bc0cd04bc2a07ad3850d4f38a70f628e","modified":1483959605000},{"_id":"themes/apollo/layout/partial/nav.jade","hash":"f4842d9d3d763fbb823d112a6f49f24cc42a0ad4","modified":1483958398000},{"_id":"themes/apollo/layout/partial/layout.jade","hash":"d28fa3c39fca9624a87e7e83736cf2509dc14a43","modified":1483959597000},{"_id":"themes/apollo/layout/partial/scripts.jade","hash":"1e15c76006418301dccae80dc0f44f0bf2fa8c3b","modified":1483959509000},{"_id":"themes/apollo/.git/refs/heads/master","hash":"6b2a807377b6c438afb49e62934a0da70cdc77f9","modified":1483958398000},{"_id":"themes/apollo/source/scss/_partial/archive-post-list.scss","hash":"d2f740a7d48349b7536777c795f82ab740836d0f","modified":1483958398000},{"_id":"themes/apollo/source/scss/_partial/base.scss","hash":"ae967b2049ecb9b8c4e139ecce32fd9fb5358ac5","modified":1483958398000},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","hash":"1309667e3000037170cfbb5b8c9c65f4ffcf6814","modified":1483958398000},{"_id":"themes/apollo/source/scss/_partial/footer.scss","hash":"094aca6e52f11b139ac7980ca03fa7b9d8fc7b2f","modified":1483958398000},{"_id":"themes/apollo/source/scss/_partial/header.scss","hash":"153bde88bf8ffeae4ffd813d8cc694dd83d33d94","modified":1483958398000},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","hash":"6b5c59f3d2295944f934aee2c1156012a3306d5d","modified":1483958398000},{"_id":"themes/apollo/source/scss/_partial/post.scss","hash":"912776a0eb7ad5a387b9aa929c857b6edd0c113e","modified":1483958398000},{"_id":"themes/apollo/.git/objects/pack/pack-45a21a80109c48dff7a583ed686467a5aa8e7c15.idx","hash":"264aab8e71a9a6b6b2a8fa1e91952f52ca5d6958","modified":1483958398000},{"_id":"themes/apollo/source/scss/_partial/mq.scss","hash":"fc5dda52cfbb10e27e2471e03f4606fb3d588225","modified":1483958398000},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","hash":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1483958398000},{"_id":"themes/apollo/.git/logs/refs/heads/master","hash":"8701c2898a90aaf4191288a1309b18b7dd32c70d","modified":1483958398000},{"_id":"themes/apollo/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1483958398000},{"_id":"themes/apollo/.git/objects/pack/pack-45a21a80109c48dff7a583ed686467a5aa8e7c15.pack","hash":"fa8aff67d51f4307c747e3e514795c3196f4e6b8","modified":1483958398000},{"_id":"themes/apollo/.git/logs/refs/remotes/origin/HEAD","hash":"8701c2898a90aaf4191288a1309b18b7dd32c70d","modified":1483958398000},{"_id":"public/sitemap.xml","hash":"28b8714720b80bd193ac6e138d9376507ebeb2c1","modified":1484029051715},{"_id":"public/atom.xml","hash":"9b67914b1fdae7d44bdf0263a812c07b7ffc5edb","modified":1484029051718},{"_id":"public/2017/01/09/LongestIncreasingPathinaMatrix/index.html","hash":"06657c7e1ca7492408ee98e71be3a155b17529f2","modified":1484029051734},{"_id":"public/2017/01/07/PathSumIII/index.html","hash":"797b4c0e28417b823c22f6db710ee931d9bcf6d4","modified":1484029051736},{"_id":"public/2017/01/06/PartitionEqualSubsetSum/index.html","hash":"ef81cab80d78cece99264c8a50a5d10428b94b9f","modified":1484029051736},{"_id":"public/2017/01/08/IntersectionofTwoArraysII/index.html","hash":"17eabff7beb3a64f08ee664ab9b3e52df99b9d5e","modified":1484029051736},{"_id":"public/2017/01/04/Heaters/index.html","hash":"c7c2666e35905a709d3d83086e1e2094908ab2b5","modified":1484029051736},{"_id":"public/2017/01/03/132Pattern/index.html","hash":"25fe42c4eb285a4f3733c8124db2bcd597d56973","modified":1484029051737},{"_id":"public/2017/01/02/TotalHammingDistance/index.html","hash":"3faaef2b9dabf86061ab17c5382e5af78e068768","modified":1484029051738},{"_id":"public/2017/01/01/NewStart/index.html","hash":"62388911584cced2ca2f8373b40b36e5a51024aa","modified":1484029051738},{"_id":"public/index.html","hash":"71c078f541e83bf6f5c373ea045e333dcc930a99","modified":1484029051738},{"_id":"public/archives/index.html","hash":"8c12d25a2cf0bac707b93c6e3a288ffd4283b26c","modified":1484029051738},{"_id":"public/tags/Simulation/index.html","hash":"4c9e951adf9aa4ec84326c7af0259e9356668ab5","modified":1484029051738},{"_id":"public/page/2/index.html","hash":"57134a3bead9d9c56786e45bac396a65a529611a","modified":1484029051738},{"_id":"public/tags/Hash-Table/index.html","hash":"b59daf2569f1e2247c65c4dda293000c4211a84a","modified":1484029051738},{"_id":"public/tags/Stack/index.html","hash":"90ac147dc02e202c8d4e5f3b2382cc5430827283","modified":1484029051738},{"_id":"public/tags/Binary-Search/index.html","hash":"b7382f7eace09aa44064ffab3f4fb4ed7c7c402f","modified":1484029051738},{"_id":"public/tags/Two-Pointers/index.html","hash":"ee44b8fa119f50aa5db3d066e80a860b6225ac14","modified":1484029051738},{"_id":"public/tags/Sort/index.html","hash":"ee44b8fa119f50aa5db3d066e80a860b6225ac14","modified":1484029051738},{"_id":"public/tags/Depth-first-Search/index.html","hash":"7145c763caed7a5ed56d1133281c7b4382c38ebb","modified":1484029051738},{"_id":"public/tags/Dynamic-Programming/index.html","hash":"6e1c572b048e91376b3949f185fb0f58725617c3","modified":1484029051739},{"_id":"public/2017/01/05/BattleshipsinaBoard/index.html","hash":"521727bb57dcef9c20b8016894222bca566240e2","modified":1484029051739},{"_id":"public/2017/01/10/GroupAnagrams/index.html","hash":"91cb385f09bb334cd8792bea0bcca7a56f7ac180","modified":1484029051741},{"_id":"public/tags/String/index.html","hash":"9258a31b35e09b856072181444578b590712e237","modified":1484029051741},{"_id":"public/tags/Topological-sort/index.html","hash":"7145c763caed7a5ed56d1133281c7b4382c38ebb","modified":1484029051741},{"_id":"public/tags/Memoization/index.html","hash":"7145c763caed7a5ed56d1133281c7b4382c38ebb","modified":1484029051742},{"_id":"public/tags/Description/index.html","hash":"70c6deb1189ca0213e436118c61149ea97ce1217","modified":1484029051742},{"_id":"public/tags/Tree/index.html","hash":"d2ea48b8811d2f39847c4e167334c9339c011b1c","modified":1484029051742},{"_id":"public/tags/Bitmap/index.html","hash":"d532711e3fd6d582c0a6ca080abef08251b4fd48","modified":1484029051742},{"_id":"public/favicon.ico","hash":"b8eb4ec54a6ce48e939cfdcb775493d3d0ab58ef","modified":1484029051744},{"_id":"public/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1484029051744},{"_id":"public/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1484029051744},{"_id":"public/css/apollo.css","hash":"57bbf3eb1a5ff9d92e7b65b9d9abe4012c28a4b4","modified":1484029051751},{"_id":"public/scss/apollo.css","hash":"9941dd928aa33d6a2a6229c65e81b731d5c7dbb7","modified":1484029051772}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Group Anagrams","date":"2017-01-10T06:07:57.000Z","_content":"\n> Given an array of strings, group anagrams together.\n>\n> For example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],\n> Return:\n>\n>       [\n>           [\"ate\", \"eat\",\"tea\"],\n>           [\"nat\",\"tan\"],\n>           [\"bat\"]\n>       ]\n>\n> Note: All inputs will be in lower-case.\n<!--more-->\n\nThis is Leetcode 49, what a easy problem. We can quickly figure out two method:\n\nThe first one is:\n> 1. choose one string as the standard one.\n> 2. for each to check if this one has the same chars as the standard.\n> 3. if same, than, mark it has been used, and store it to the result.\n\nThe time complex of this method is O(n^2*m), m is dependent on the length of the string. It's is not a fast method, but it uses the least memory.\n\nThe second one is to use the map or hash map to help.\n> 1. for each to count its structure. for example, tae can be descriped as '1a0b0c0d1e0f0g0h0i0j0k0l0m0n0o0p0q0r0s1t0u0v0w0x0y0z'\n> 2. then make the key to the map and check each word which has the same structure.\n\nThe time copolex of this method is O(n*m).\n\nSo, I use the second one to write the result code as following:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        vector<vector<string> > groupAnagrams(vector<string>& strs) {\n            vector<string> keys;\n            map<string, vector<string> > retMap;\n            for (int i = 0; i < (int)strs.size(); i++) {\n                int chars[26] = {0};\n                for (int j = 0; j < (int)strs[i].length(); j++) {\n                    chars[strs[i][j] - 'a']++;\n                }\n                string currentKey = \"\";\n                for (int j = 0; j < 26; j++) {\n                    currentKey = currentKey + (char)('0' + chars[j]);\n                    currentKey = currentKey + (char)('a' + j);\n                }\n\n                if (retMap.find(currentKey) != retMap.end()) {\n                    retMap[currentKey].push_back(strs[i]);\n                } else {\n                    vector<string> currentValue;\n                    currentValue.push_back(strs[i]);\n                    retMap.insert(pair<string, vector<string> >(currentKey, currentValue));\n                }\n            }\n\n            vector<vector<string> > res;\n            for (pair<string, vector<string> > values: retMap) {\n                res.push_back(values.second);\n            }\n            return res;\n        }\n};\n```\n\nAnd it gets AC.\n","source":"_posts/GroupAnagrams.md","raw":"---\ntitle: Group Anagrams\ndate: 2017-01-10 14:07:57\ntags:\n    - Hash Table\n    - String\n---\n\n> Given an array of strings, group anagrams together.\n>\n> For example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],\n> Return:\n>\n>       [\n>           [\"ate\", \"eat\",\"tea\"],\n>           [\"nat\",\"tan\"],\n>           [\"bat\"]\n>       ]\n>\n> Note: All inputs will be in lower-case.\n<!--more-->\n\nThis is Leetcode 49, what a easy problem. We can quickly figure out two method:\n\nThe first one is:\n> 1. choose one string as the standard one.\n> 2. for each to check if this one has the same chars as the standard.\n> 3. if same, than, mark it has been used, and store it to the result.\n\nThe time complex of this method is O(n^2*m), m is dependent on the length of the string. It's is not a fast method, but it uses the least memory.\n\nThe second one is to use the map or hash map to help.\n> 1. for each to count its structure. for example, tae can be descriped as '1a0b0c0d1e0f0g0h0i0j0k0l0m0n0o0p0q0r0s1t0u0v0w0x0y0z'\n> 2. then make the key to the map and check each word which has the same structure.\n\nThe time copolex of this method is O(n*m).\n\nSo, I use the second one to write the result code as following:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        vector<vector<string> > groupAnagrams(vector<string>& strs) {\n            vector<string> keys;\n            map<string, vector<string> > retMap;\n            for (int i = 0; i < (int)strs.size(); i++) {\n                int chars[26] = {0};\n                for (int j = 0; j < (int)strs[i].length(); j++) {\n                    chars[strs[i][j] - 'a']++;\n                }\n                string currentKey = \"\";\n                for (int j = 0; j < 26; j++) {\n                    currentKey = currentKey + (char)('0' + chars[j]);\n                    currentKey = currentKey + (char)('a' + j);\n                }\n\n                if (retMap.find(currentKey) != retMap.end()) {\n                    retMap[currentKey].push_back(strs[i]);\n                } else {\n                    vector<string> currentValue;\n                    currentValue.push_back(strs[i]);\n                    retMap.insert(pair<string, vector<string> >(currentKey, currentValue));\n                }\n            }\n\n            vector<vector<string> > res;\n            for (pair<string, vector<string> > values: retMap) {\n                res.push_back(values.second);\n            }\n            return res;\n        }\n};\n```\n\nAnd it gets AC.\n","slug":"GroupAnagrams","published":1,"updated":"2017-01-10T06:17:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixr4kw6800006uf44aq1kxi3","content":"<blockquote>\n<p>Given an array of strings, group anagrams together.</p>\n<p>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>Return:</p>\n<pre><code>[\n    [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;],\n    [&quot;nat&quot;,&quot;tan&quot;],\n    [&quot;bat&quot;]\n]\n</code></pre><p>Note: All inputs will be in lower-case.<br><a id=\"more\"></a></p>\n</blockquote>\n<p>This is Leetcode 49, what a easy problem. We can quickly figure out two method:</p>\n<p>The first one is:</p>\n<blockquote>\n<ol>\n<li>choose one string as the standard one.</li>\n<li>for each to check if this one has the same chars as the standard.</li>\n<li>if same, than, mark it has been used, and store it to the result.</li>\n</ol>\n</blockquote>\n<p>The time complex of this method is O(n^2*m), m is dependent on the length of the string. It’s is not a fast method, but it uses the least memory.</p>\n<p>The second one is to use the map or hash map to help.</p>\n<blockquote>\n<ol>\n<li>for each to count its structure. for example, tae can be descriped as ‘1a0b0c0d1e0f0g0h0i0j0k0l0m0n0o0p0q0r0s1t0u0v0w0x0y0z’</li>\n<li>then make the key to the map and check each word which has the same structure.</li>\n</ol>\n</blockquote>\n<p>The time copolex of this method is O(n*m).</p>\n<p>So, I use the second one to write the result code as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;vector&lt;string&gt; &gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</div><div class=\"line\">            vector&lt;string&gt; keys;</div><div class=\"line\">            map&lt;string, vector&lt;string&gt; &gt; retMap;</div><div class=\"line\">            for (int i = 0; i &lt; (int)strs.size(); i++) &#123;</div><div class=\"line\">                int chars[26] = &#123;0&#125;;</div><div class=\"line\">                for (int j = 0; j &lt; (int)strs[i].length(); j++) &#123;</div><div class=\"line\">                    chars[strs[i][j] - &apos;a&apos;]++;</div><div class=\"line\">                &#125;</div><div class=\"line\">                string currentKey = &quot;&quot;;</div><div class=\"line\">                for (int j = 0; j &lt; 26; j++) &#123;</div><div class=\"line\">                    currentKey = currentKey + (char)(&apos;0&apos; + chars[j]);</div><div class=\"line\">                    currentKey = currentKey + (char)(&apos;a&apos; + j);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                if (retMap.find(currentKey) != retMap.end()) &#123;</div><div class=\"line\">                    retMap[currentKey].push_back(strs[i]);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    vector&lt;string&gt; currentValue;</div><div class=\"line\">                    currentValue.push_back(strs[i]);</div><div class=\"line\">                    retMap.insert(pair&lt;string, vector&lt;string&gt; &gt;(currentKey, currentValue));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;vector&lt;string&gt; &gt; res;</div><div class=\"line\">            for (pair&lt;string, vector&lt;string&gt; &gt; values: retMap) &#123;</div><div class=\"line\">                res.push_back(values.second);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given an array of strings, group anagrams together.</p>\n<p>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>Return:</p>\n<pre><code>[\n    [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;],\n    [&quot;nat&quot;,&quot;tan&quot;],\n    [&quot;bat&quot;]\n]\n</code></pre><p>Note: All inputs will be in lower-case.<br>","more":"</p>\n</blockquote>\n<p>This is Leetcode 49, what a easy problem. We can quickly figure out two method:</p>\n<p>The first one is:</p>\n<blockquote>\n<ol>\n<li>choose one string as the standard one.</li>\n<li>for each to check if this one has the same chars as the standard.</li>\n<li>if same, than, mark it has been used, and store it to the result.</li>\n</ol>\n</blockquote>\n<p>The time complex of this method is O(n^2*m), m is dependent on the length of the string. It’s is not a fast method, but it uses the least memory.</p>\n<p>The second one is to use the map or hash map to help.</p>\n<blockquote>\n<ol>\n<li>for each to count its structure. for example, tae can be descriped as ‘1a0b0c0d1e0f0g0h0i0j0k0l0m0n0o0p0q0r0s1t0u0v0w0x0y0z’</li>\n<li>then make the key to the map and check each word which has the same structure.</li>\n</ol>\n</blockquote>\n<p>The time copolex of this method is O(n*m).</p>\n<p>So, I use the second one to write the result code as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;vector&lt;string&gt; &gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</div><div class=\"line\">            vector&lt;string&gt; keys;</div><div class=\"line\">            map&lt;string, vector&lt;string&gt; &gt; retMap;</div><div class=\"line\">            for (int i = 0; i &lt; (int)strs.size(); i++) &#123;</div><div class=\"line\">                int chars[26] = &#123;0&#125;;</div><div class=\"line\">                for (int j = 0; j &lt; (int)strs[i].length(); j++) &#123;</div><div class=\"line\">                    chars[strs[i][j] - &apos;a&apos;]++;</div><div class=\"line\">                &#125;</div><div class=\"line\">                string currentKey = &quot;&quot;;</div><div class=\"line\">                for (int j = 0; j &lt; 26; j++) &#123;</div><div class=\"line\">                    currentKey = currentKey + (char)(&apos;0&apos; + chars[j]);</div><div class=\"line\">                    currentKey = currentKey + (char)(&apos;a&apos; + j);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                if (retMap.find(currentKey) != retMap.end()) &#123;</div><div class=\"line\">                    retMap[currentKey].push_back(strs[i]);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    vector&lt;string&gt; currentValue;</div><div class=\"line\">                    currentValue.push_back(strs[i]);</div><div class=\"line\">                    retMap.insert(pair&lt;string, vector&lt;string&gt; &gt;(currentKey, currentValue));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;vector&lt;string&gt; &gt; res;</div><div class=\"line\">            for (pair&lt;string, vector&lt;string&gt; &gt; values: retMap) &#123;</div><div class=\"line\">                res.push_back(values.second);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>"},{"title":"132 Pattern","date":"2017-01-03T05:46:25.000Z","_content":"\n> Given a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such that i < j < k and ai < ak < aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.\n>\n> Note: n will be less than 15,000.\n>\n> Example 1:\n>\n> Input: [1, 2, 3, 4]\n>\n> Output: False\n>\n> Explanation: There is no 132 pattern in the sequence.\n>\n> Example 2:\n>\n> Input: [3, 1, 4, 2]\n>\n> Output: True\n>\n> Explanation: There is a 132 pattern in the sequence: [1, 4, 2].\n>\n> Example 3:\n>\n> Input: [-1, 3, 2, 0]\n>\n> Output: True\n>\n> Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\n\n<!--more-->\n\nThis is Leetcode 456. As the problem description, we can quickly write this solution like this:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        bool find132pattern(vector<int>& nums) {\n            for (int i = 0; i < (int)nums.size() - 2; i++) {\n                for (int j = i + 1; j < (int)nums.size() - 1; j++) {\n                    for (int k = j + 1; k < (int)nums.size(); k++) {\n                        if (check(nums, i, j, k)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        bool check(vector<int> &nums, int idx, int idy, int idz) {\n            if (nums[idx] < nums[idy]\n                    && nums[idz] < nums[idy]\n                    && nums[idx] < nums[idz]) {\n                return true;\n            }\n            return false;\n        }\n};\n```\nBut it's time complex is O(n^3), and it will get TLE. So, we try to think another way. As a similar problem, try to find a array S1 < S2 < S3, we will find use two pointers to aim at the start and the end of the array.\n\nSo, here we can use a similar solution. We can use a stack to store the num which is bigger than S3, and store it try to find the possible S3.\n\nFor more detail, use [9, 11, 8, 9, 10, 7, 9] as an example:\n\nEXAMPLE:\n + i = 6, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = None, Stack = Empty\n + i = 5, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 7, S3 candidate = None, Stack = [9]\n + i = 4, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 10, S3 candidate = None, Stack = [9,7]\n + i = 3, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = 9, Stack = [10]\n + i = 2, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 8, S3 candidate = 9, Stack = [10,9] We have 8 < 9, sequence found!\n\nSo, the solution is:\n\n```\nbool find132pattern(vector<int>& nums) {\n    int s3 = INT_MIN, s1;\n    std::stack<int> stack;\n    for (int i = nums.size() - 1; i >= 0; i--) {\n        s1 = nums[i];\n        if (s3 > s1) {\n            return true;\n        } else {\n            while (!stack.empty() && nums[i] > stack.top()) {\n                s3 = stack.top();\n                stack.pop();\n            }\n        }\n        stack.push(nums[i]);\n    }\n    return false;\n}\n```\n","source":"_posts/132Pattern.md","raw":"---\ntitle: 132 Pattern\ndate: 2017-01-03 13:46:25\ntags:\n    - Stack\n---\n\n> Given a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such that i < j < k and ai < ak < aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.\n>\n> Note: n will be less than 15,000.\n>\n> Example 1:\n>\n> Input: [1, 2, 3, 4]\n>\n> Output: False\n>\n> Explanation: There is no 132 pattern in the sequence.\n>\n> Example 2:\n>\n> Input: [3, 1, 4, 2]\n>\n> Output: True\n>\n> Explanation: There is a 132 pattern in the sequence: [1, 4, 2].\n>\n> Example 3:\n>\n> Input: [-1, 3, 2, 0]\n>\n> Output: True\n>\n> Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\n\n<!--more-->\n\nThis is Leetcode 456. As the problem description, we can quickly write this solution like this:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        bool find132pattern(vector<int>& nums) {\n            for (int i = 0; i < (int)nums.size() - 2; i++) {\n                for (int j = i + 1; j < (int)nums.size() - 1; j++) {\n                    for (int k = j + 1; k < (int)nums.size(); k++) {\n                        if (check(nums, i, j, k)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        bool check(vector<int> &nums, int idx, int idy, int idz) {\n            if (nums[idx] < nums[idy]\n                    && nums[idz] < nums[idy]\n                    && nums[idx] < nums[idz]) {\n                return true;\n            }\n            return false;\n        }\n};\n```\nBut it's time complex is O(n^3), and it will get TLE. So, we try to think another way. As a similar problem, try to find a array S1 < S2 < S3, we will find use two pointers to aim at the start and the end of the array.\n\nSo, here we can use a similar solution. We can use a stack to store the num which is bigger than S3, and store it try to find the possible S3.\n\nFor more detail, use [9, 11, 8, 9, 10, 7, 9] as an example:\n\nEXAMPLE:\n + i = 6, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = None, Stack = Empty\n + i = 5, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 7, S3 candidate = None, Stack = [9]\n + i = 4, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 10, S3 candidate = None, Stack = [9,7]\n + i = 3, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = 9, Stack = [10]\n + i = 2, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 8, S3 candidate = 9, Stack = [10,9] We have 8 < 9, sequence found!\n\nSo, the solution is:\n\n```\nbool find132pattern(vector<int>& nums) {\n    int s3 = INT_MIN, s1;\n    std::stack<int> stack;\n    for (int i = nums.size() - 1; i >= 0; i--) {\n        s1 = nums[i];\n        if (s3 > s1) {\n            return true;\n        } else {\n            while (!stack.empty() && nums[i] > stack.top()) {\n                s3 = stack.top();\n                stack.pop();\n            }\n        }\n        stack.push(nums[i]);\n    }\n    return false;\n}\n```\n","slug":"132Pattern","published":1,"updated":"2017-01-04T02:00:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixr4kw6c00016uf4mzcpgdyg","content":"<blockquote>\n<p>Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.</p>\n<p>Note: n will be less than 15,000.</p>\n<p>Example 1:</p>\n<p>Input: [1, 2, 3, 4]</p>\n<p>Output: False</p>\n<p>Explanation: There is no 132 pattern in the sequence.</p>\n<p>Example 2:</p>\n<p>Input: [3, 1, 4, 2]</p>\n<p>Output: True</p>\n<p>Explanation: There is a 132 pattern in the sequence: [1, 4, 2].</p>\n<p>Example 3:</p>\n<p>Input: [-1, 3, 2, 0]</p>\n<p>Output: True</p>\n<p>Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 456. As the problem description, we can quickly write this solution like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool find132pattern(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size() - 2; i++) &#123;</div><div class=\"line\">                for (int j = i + 1; j &lt; (int)nums.size() - 1; j++) &#123;</div><div class=\"line\">                    for (int k = j + 1; k &lt; (int)nums.size(); k++) &#123;</div><div class=\"line\">                        if (check(nums, i, j, k)) &#123;</div><div class=\"line\">                            return true;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool check(vector&lt;int&gt; &amp;nums, int idx, int idy, int idz) &#123;</div><div class=\"line\">            if (nums[idx] &lt; nums[idy]</div><div class=\"line\">                    &amp;&amp; nums[idz] &lt; nums[idy]</div><div class=\"line\">                    &amp;&amp; nums[idx] &lt; nums[idz]) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>But it’s time complex is O(n^3), and it will get TLE. So, we try to think another way. As a similar problem, try to find a array S1 &lt; S2 &lt; S3, we will find use two pointers to aim at the start and the end of the array.</p>\n<p>So, here we can use a similar solution. We can use a stack to store the num which is bigger than S3, and store it try to find the possible S3.</p>\n<p>For more detail, use [9, 11, 8, 9, 10, 7, 9] as an example:</p>\n<p>EXAMPLE:</p>\n<ul>\n<li>i = 6, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = None, Stack = Empty</li>\n<li>i = 5, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 7, S3 candidate = None, Stack = [9]</li>\n<li>i = 4, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 10, S3 candidate = None, Stack = [9,7]</li>\n<li>i = 3, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = 9, Stack = [10]</li>\n<li>i = 2, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 8, S3 candidate = 9, Stack = [10,9] We have 8 &lt; 9, sequence found!</li>\n</ul>\n<p>So, the solution is:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool find132pattern(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    int s3 = INT_MIN, s1;</div><div class=\"line\">    std::stack&lt;int&gt; stack;</div><div class=\"line\">    for (int i = nums.size() - 1; i &gt;= 0; i--) &#123;</div><div class=\"line\">        s1 = nums[i];</div><div class=\"line\">        if (s3 &gt; s1) &#123;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            while (!stack.empty() &amp;&amp; nums[i] &gt; stack.top()) &#123;</div><div class=\"line\">                s3 = stack.top();</div><div class=\"line\">                stack.pop();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        stack.push(nums[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<blockquote>\n<p>Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.</p>\n<p>Note: n will be less than 15,000.</p>\n<p>Example 1:</p>\n<p>Input: [1, 2, 3, 4]</p>\n<p>Output: False</p>\n<p>Explanation: There is no 132 pattern in the sequence.</p>\n<p>Example 2:</p>\n<p>Input: [3, 1, 4, 2]</p>\n<p>Output: True</p>\n<p>Explanation: There is a 132 pattern in the sequence: [1, 4, 2].</p>\n<p>Example 3:</p>\n<p>Input: [-1, 3, 2, 0]</p>\n<p>Output: True</p>\n<p>Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].</p>\n</blockquote>","more":"<p>This is Leetcode 456. As the problem description, we can quickly write this solution like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool find132pattern(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size() - 2; i++) &#123;</div><div class=\"line\">                for (int j = i + 1; j &lt; (int)nums.size() - 1; j++) &#123;</div><div class=\"line\">                    for (int k = j + 1; k &lt; (int)nums.size(); k++) &#123;</div><div class=\"line\">                        if (check(nums, i, j, k)) &#123;</div><div class=\"line\">                            return true;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool check(vector&lt;int&gt; &amp;nums, int idx, int idy, int idz) &#123;</div><div class=\"line\">            if (nums[idx] &lt; nums[idy]</div><div class=\"line\">                    &amp;&amp; nums[idz] &lt; nums[idy]</div><div class=\"line\">                    &amp;&amp; nums[idx] &lt; nums[idz]) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>But it’s time complex is O(n^3), and it will get TLE. So, we try to think another way. As a similar problem, try to find a array S1 &lt; S2 &lt; S3, we will find use two pointers to aim at the start and the end of the array.</p>\n<p>So, here we can use a similar solution. We can use a stack to store the num which is bigger than S3, and store it try to find the possible S3.</p>\n<p>For more detail, use [9, 11, 8, 9, 10, 7, 9] as an example:</p>\n<p>EXAMPLE:</p>\n<ul>\n<li>i = 6, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = None, Stack = Empty</li>\n<li>i = 5, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 7, S3 candidate = None, Stack = [9]</li>\n<li>i = 4, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 10, S3 candidate = None, Stack = [9,7]</li>\n<li>i = 3, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = 9, Stack = [10]</li>\n<li>i = 2, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 8, S3 candidate = 9, Stack = [10,9] We have 8 &lt; 9, sequence found!</li>\n</ul>\n<p>So, the solution is:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool find132pattern(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    int s3 = INT_MIN, s1;</div><div class=\"line\">    std::stack&lt;int&gt; stack;</div><div class=\"line\">    for (int i = nums.size() - 1; i &gt;= 0; i--) &#123;</div><div class=\"line\">        s1 = nums[i];</div><div class=\"line\">        if (s3 &gt; s1) &#123;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            while (!stack.empty() &amp;&amp; nums[i] &gt; stack.top()) &#123;</div><div class=\"line\">                s3 = stack.top();</div><div class=\"line\">                stack.pop();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        stack.push(nums[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"Battleships in a Board","date":"2017-01-05T05:46:25.000Z","_content":"\n> Given an 2D board, count how many different battleships are in it. The battleships are represented with 'X's, empty slots are represented with '.'s. You may assume the following rules:\n>\n>  + You receive a valid board, made of only battleships or empty slots.\n>  + Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.\n>  + At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.\n>\n> Example:\n>\n> X..X\n> ...X\n> ...X\n>\n> In the above board there are 2 battleships.\n>\n> Invalid Example:\n>\n> ...X\n> XXXX\n> ...X\n>\n> This is an invalid board that you will not receive - as battleships will always have a cell separating between them.\n>\n> Follow up:\n> Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?\n\n<!-- more -->\n\nThis is Leetcode 419, and it's easy enough to figure out with simulation way as following:\n\n1. find the first X char, from up to down and left to right.\n2. if found, then search up and right, to check whether it is ok.\n3. use a global flag to mark if it's good for the result.\n\nThis method will use O(n*n) array to mark the visited position, if not it will modify the value of the board to make sure no cell will visit twice.\n\nFor example, if we use a visited array to mark the visited cells. the solution will be like these:\n\n```\nbool checkShip(vector<vector<char> > &board, int **visited, int idx, int idy) {\n    if (visited[idx][idy]) {\n        return false;\n    }\n\n    bool res = true;\n    // check the direction, down\n    int currentIdx = idx, currentIdy = idy;\n    while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n        if (board[currentIdx][currentIdy] == 'X') {\n            if (currentIdy + 1 < (int)board[0].size() && board[currentIdx][currentIdy + 1] == 'X') {\n                res = false;\n                break;\n            }\n            if (currentIdy - 1 >= 0 && board[currentIdx][currentIdy - 1] == 'X') {\n                res = false;\n                break;\n            }\n        } else {\n            res = true;\n            break;\n        }\n        currentIdx++;\n    }\n    // check the direction, right\n    currentIdx = idx, currentIdy = idy;\n    if (!res) {\n        res = true;\n        while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n            if (board[currentIdx][currentIdy] == 'X') {\n                if (currentIdx + 1 < (int)board.size() && board[currentIdx + 1][currentIdy] == 'X') {\n                    res = false;\n                    break;\n                }\n                if (currentIdx - 1 >= 0 && board[currentIdx - 1][currentIdy] == 'X') {\n                    res = false;\n                    break;\n                }\n            } else {\n                res = true;\n                break;\n            }\n            currentIdy++;\n        }\n    }\n    _visit(board, visited, idx, idy);\n    return res;\n}\n\nvoid _visit(vector<vector<char> > &board, int **visited, int idx, int idy) {\n    if (idx < 0 || idy < 0|| idx >= (int)board.size() || idy >= (int)board[0].size()) {\n        return;\n    }\n    if (visited[idx][idy]) {\n        return;\n    }\n    if (board[idx][idy] == '.') {\n        return;\n    }\n    visited[idx][idy] = 1;\n    _visit(board, visited, idx + 1, idy);\n    _visit(board, visited, idx, idy + 1);\n    _visit(board, visited, idx - 1, idy);\n    _visit(board, visited, idx, idy - 1);\n}\n\nint countBattleships(vector<vector<char> >& board) {\n    int* visited[board.size()];\n    for (int i = 0; i < (int)board.size(); i++) {\n        visited[i] = new int[board[0].size()];\n        memset(visited[i], 0, sizeof(int) * board[0].size());\n    }\n    int res = 0;\n    for (int idx = 0; idx < (int)board.size(); idx++) {\n        for (int idy = 0; idy < (int)board[0].size(); idy++) {\n            if (board[idx][idy] == 'X' && checkShip(board, visited, idx, idy)) {\n                res++;\n            }\n        }\n    }\n    return res;\n}\n```\n\nBut, if we can give up the visited array, just make sure the current cell's left or up have X char to mark it has been visited. It will make sense.\n\nSo, we should add these method to replace the former visited array:\n\n```\nbool isVisited(vector<vector<char> > &board, int idx, int idy) {\n    if (idx == 0 && idy == 0) {\n        return false;\n    } else if (idx == 0) {\n        return board[idx][idy - 1] == 'X';\n    } else if (idy == 0) {\n        return board[idx - 1][idy] == 'X';\n    } else {\n        return board[idx - 1][idy] == 'X' || board[idx][idy - 1] == 'X';\n    }\n}\n```\nSo, the last AC code will like these:\n\n```\nclass Solution {\n    public:\n        bool isVisited(vector<vector<char> > &board, int idx, int idy) {\n            if (idx == 0 && idy == 0) {\n                return false;\n            } else if (idx == 0) {\n                return board[idx][idy - 1] == 'X';\n            } else if (idy == 0) {\n                return board[idx - 1][idy] == 'X';\n            } else {\n                return board[idx - 1][idy] == 'X' || board[idx][idy - 1] == 'X';\n            }\n        }\n\n        bool checkShip(vector<vector<char> > &board, int idx, int idy) {\n            if (isVisited(board, idx, idy)) {\n                return false;\n            }\n\n            bool res = true;\n            // check the direction, down\n            int currentIdx = idx, currentIdy = idy;\n            while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n                if (board[currentIdx][currentIdy] == 'X') {\n                    if (currentIdy + 1 < (int)board[0].size() && board[currentIdx][currentIdy + 1] == 'X') {\n                        res = false;\n                        break;\n                    }\n                    if (currentIdy - 1 >= 0 && board[currentIdx][currentIdy - 1] == 'X') {\n                        res = false;\n                        break;\n                    }\n                } else {\n                    res = true;\n                    break;\n                }\n                currentIdx++;\n            }\n            // check the direction, right\n            currentIdx = idx, currentIdy = idy;\n            if (!res) {\n                res = true;\n                while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n                    if (board[currentIdx][currentIdy] == 'X') {\n                        if (currentIdx + 1 < (int)board.size() && board[currentIdx + 1][currentIdy] == 'X') {\n                            res = false;\n                            break;\n                        }\n                        if (currentIdx - 1 >= 0 && board[currentIdx - 1][currentIdy] == 'X') {\n                            res = false;\n                            break;\n                        }\n                    } else {\n                        res = true;\n                        break;\n                    }\n                    currentIdy++;\n                }\n            }\n            _visit(board, idx, idy);\n            return res;\n        }\n\n        void _visit(vector<vector<char> > &board, int idx, int idy) {\n            if (idx < 0 || idy < 0|| idx >= (int)board.size() || idy >= (int)board[0].size()) {\n                return;\n            }\n            if (isVisited(board, idx, idy)) {\n                return;\n            }\n            if (board[idx][idy] == '.') {\n                return;\n            }\n            // visited[idx][idy] = 1;\n            _visit(board, idx + 1, idy);\n            _visit(board, idx, idy + 1);\n            _visit(board, idx - 1, idy);\n            _visit(board, idx, idy - 1);\n        }\n\n        int countBattleships(vector<vector<char> >& board) {\n            int res = 0;\n            for (int idx = 0; idx < (int)board.size(); idx++) {\n                for (int idy = 0; idy < (int)board[0].size(); idy++) {\n                    if (board[idx][idy] == 'X' && checkShip(board, idx, idy)) {\n                        res++;\n                    }\n                }\n            }\n            return res;\n        }\n};\n```\n","source":"_posts/BattleshipsinaBoard.md","raw":"---\ntitle: Battleships in a Board\ndate: 2017-01-05 13:46:25\ntags:\n    - Simulation\n---\n\n> Given an 2D board, count how many different battleships are in it. The battleships are represented with 'X's, empty slots are represented with '.'s. You may assume the following rules:\n>\n>  + You receive a valid board, made of only battleships or empty slots.\n>  + Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.\n>  + At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.\n>\n> Example:\n>\n> X..X\n> ...X\n> ...X\n>\n> In the above board there are 2 battleships.\n>\n> Invalid Example:\n>\n> ...X\n> XXXX\n> ...X\n>\n> This is an invalid board that you will not receive - as battleships will always have a cell separating between them.\n>\n> Follow up:\n> Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?\n\n<!-- more -->\n\nThis is Leetcode 419, and it's easy enough to figure out with simulation way as following:\n\n1. find the first X char, from up to down and left to right.\n2. if found, then search up and right, to check whether it is ok.\n3. use a global flag to mark if it's good for the result.\n\nThis method will use O(n*n) array to mark the visited position, if not it will modify the value of the board to make sure no cell will visit twice.\n\nFor example, if we use a visited array to mark the visited cells. the solution will be like these:\n\n```\nbool checkShip(vector<vector<char> > &board, int **visited, int idx, int idy) {\n    if (visited[idx][idy]) {\n        return false;\n    }\n\n    bool res = true;\n    // check the direction, down\n    int currentIdx = idx, currentIdy = idy;\n    while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n        if (board[currentIdx][currentIdy] == 'X') {\n            if (currentIdy + 1 < (int)board[0].size() && board[currentIdx][currentIdy + 1] == 'X') {\n                res = false;\n                break;\n            }\n            if (currentIdy - 1 >= 0 && board[currentIdx][currentIdy - 1] == 'X') {\n                res = false;\n                break;\n            }\n        } else {\n            res = true;\n            break;\n        }\n        currentIdx++;\n    }\n    // check the direction, right\n    currentIdx = idx, currentIdy = idy;\n    if (!res) {\n        res = true;\n        while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n            if (board[currentIdx][currentIdy] == 'X') {\n                if (currentIdx + 1 < (int)board.size() && board[currentIdx + 1][currentIdy] == 'X') {\n                    res = false;\n                    break;\n                }\n                if (currentIdx - 1 >= 0 && board[currentIdx - 1][currentIdy] == 'X') {\n                    res = false;\n                    break;\n                }\n            } else {\n                res = true;\n                break;\n            }\n            currentIdy++;\n        }\n    }\n    _visit(board, visited, idx, idy);\n    return res;\n}\n\nvoid _visit(vector<vector<char> > &board, int **visited, int idx, int idy) {\n    if (idx < 0 || idy < 0|| idx >= (int)board.size() || idy >= (int)board[0].size()) {\n        return;\n    }\n    if (visited[idx][idy]) {\n        return;\n    }\n    if (board[idx][idy] == '.') {\n        return;\n    }\n    visited[idx][idy] = 1;\n    _visit(board, visited, idx + 1, idy);\n    _visit(board, visited, idx, idy + 1);\n    _visit(board, visited, idx - 1, idy);\n    _visit(board, visited, idx, idy - 1);\n}\n\nint countBattleships(vector<vector<char> >& board) {\n    int* visited[board.size()];\n    for (int i = 0; i < (int)board.size(); i++) {\n        visited[i] = new int[board[0].size()];\n        memset(visited[i], 0, sizeof(int) * board[0].size());\n    }\n    int res = 0;\n    for (int idx = 0; idx < (int)board.size(); idx++) {\n        for (int idy = 0; idy < (int)board[0].size(); idy++) {\n            if (board[idx][idy] == 'X' && checkShip(board, visited, idx, idy)) {\n                res++;\n            }\n        }\n    }\n    return res;\n}\n```\n\nBut, if we can give up the visited array, just make sure the current cell's left or up have X char to mark it has been visited. It will make sense.\n\nSo, we should add these method to replace the former visited array:\n\n```\nbool isVisited(vector<vector<char> > &board, int idx, int idy) {\n    if (idx == 0 && idy == 0) {\n        return false;\n    } else if (idx == 0) {\n        return board[idx][idy - 1] == 'X';\n    } else if (idy == 0) {\n        return board[idx - 1][idy] == 'X';\n    } else {\n        return board[idx - 1][idy] == 'X' || board[idx][idy - 1] == 'X';\n    }\n}\n```\nSo, the last AC code will like these:\n\n```\nclass Solution {\n    public:\n        bool isVisited(vector<vector<char> > &board, int idx, int idy) {\n            if (idx == 0 && idy == 0) {\n                return false;\n            } else if (idx == 0) {\n                return board[idx][idy - 1] == 'X';\n            } else if (idy == 0) {\n                return board[idx - 1][idy] == 'X';\n            } else {\n                return board[idx - 1][idy] == 'X' || board[idx][idy - 1] == 'X';\n            }\n        }\n\n        bool checkShip(vector<vector<char> > &board, int idx, int idy) {\n            if (isVisited(board, idx, idy)) {\n                return false;\n            }\n\n            bool res = true;\n            // check the direction, down\n            int currentIdx = idx, currentIdy = idy;\n            while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n                if (board[currentIdx][currentIdy] == 'X') {\n                    if (currentIdy + 1 < (int)board[0].size() && board[currentIdx][currentIdy + 1] == 'X') {\n                        res = false;\n                        break;\n                    }\n                    if (currentIdy - 1 >= 0 && board[currentIdx][currentIdy - 1] == 'X') {\n                        res = false;\n                        break;\n                    }\n                } else {\n                    res = true;\n                    break;\n                }\n                currentIdx++;\n            }\n            // check the direction, right\n            currentIdx = idx, currentIdy = idy;\n            if (!res) {\n                res = true;\n                while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n                    if (board[currentIdx][currentIdy] == 'X') {\n                        if (currentIdx + 1 < (int)board.size() && board[currentIdx + 1][currentIdy] == 'X') {\n                            res = false;\n                            break;\n                        }\n                        if (currentIdx - 1 >= 0 && board[currentIdx - 1][currentIdy] == 'X') {\n                            res = false;\n                            break;\n                        }\n                    } else {\n                        res = true;\n                        break;\n                    }\n                    currentIdy++;\n                }\n            }\n            _visit(board, idx, idy);\n            return res;\n        }\n\n        void _visit(vector<vector<char> > &board, int idx, int idy) {\n            if (idx < 0 || idy < 0|| idx >= (int)board.size() || idy >= (int)board[0].size()) {\n                return;\n            }\n            if (isVisited(board, idx, idy)) {\n                return;\n            }\n            if (board[idx][idy] == '.') {\n                return;\n            }\n            // visited[idx][idy] = 1;\n            _visit(board, idx + 1, idy);\n            _visit(board, idx, idy + 1);\n            _visit(board, idx - 1, idy);\n            _visit(board, idx, idy - 1);\n        }\n\n        int countBattleships(vector<vector<char> >& board) {\n            int res = 0;\n            for (int idx = 0; idx < (int)board.size(); idx++) {\n                for (int idy = 0; idy < (int)board[0].size(); idy++) {\n                    if (board[idx][idy] == 'X' && checkShip(board, idx, idy)) {\n                        res++;\n                    }\n                }\n            }\n            return res;\n        }\n};\n```\n","slug":"BattleshipsinaBoard","published":1,"updated":"2017-01-05T05:46:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixr4kw6h00036uf435w229ku","content":"<blockquote>\n<p>Given an 2D board, count how many different battleships are in it. The battleships are represented with ‘X’s, empty slots are represented with ‘.’s. You may assume the following rules:</p>\n<ul>\n<li>You receive a valid board, made of only battleships or empty slots.</li>\n<li>Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.</li>\n<li>At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.</li>\n</ul>\n<p>Example:</p>\n<p>X..X<br>…X<br>…X</p>\n<p>In the above board there are 2 battleships.</p>\n<p>Invalid Example:</p>\n<p>…X<br>XXXX<br>…X</p>\n<p>This is an invalid board that you will not receive - as battleships will always have a cell separating between them.</p>\n<p>Follow up:<br>Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 419, and it’s easy enough to figure out with simulation way as following:</p>\n<ol>\n<li>find the first X char, from up to down and left to right.</li>\n<li>if found, then search up and right, to check whether it is ok.</li>\n<li>use a global flag to mark if it’s good for the result.</li>\n</ol>\n<p>This method will use O(n*n) array to mark the visited position, if not it will modify the value of the board to make sure no cell will visit twice.</p>\n<p>For example, if we use a visited array to mark the visited cells. the solution will be like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool checkShip(vector&lt;vector&lt;char&gt; &gt; &amp;board, int **visited, int idx, int idy) &#123;</div><div class=\"line\">    if (visited[idx][idy]) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    bool res = true;</div><div class=\"line\">    // check the direction, down</div><div class=\"line\">    int currentIdx = idx, currentIdy = idy;</div><div class=\"line\">    while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">        if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">            if (currentIdy + 1 &lt; (int)board[0].size() &amp;&amp; board[currentIdx][currentIdy + 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                res = false;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentIdy - 1 &gt;= 0 &amp;&amp; board[currentIdx][currentIdy - 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                res = false;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            res = true;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        currentIdx++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // check the direction, right</div><div class=\"line\">    currentIdx = idx, currentIdy = idy;</div><div class=\"line\">    if (!res) &#123;</div><div class=\"line\">        res = true;</div><div class=\"line\">        while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">            if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                if (currentIdx + 1 &lt; (int)board.size() &amp;&amp; board[currentIdx + 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    res = false;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (currentIdx - 1 &gt;= 0 &amp;&amp; board[currentIdx - 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    res = false;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                res = true;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentIdy++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    _visit(board, visited, idx, idy);</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void _visit(vector&lt;vector&lt;char&gt; &gt; &amp;board, int **visited, int idx, int idy) &#123;</div><div class=\"line\">    if (idx &lt; 0 || idy &lt; 0|| idx &gt;= (int)board.size() || idy &gt;= (int)board[0].size()) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (visited[idx][idy]) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (board[idx][idy] == &apos;.&apos;) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    visited[idx][idy] = 1;</div><div class=\"line\">    _visit(board, visited, idx + 1, idy);</div><div class=\"line\">    _visit(board, visited, idx, idy + 1);</div><div class=\"line\">    _visit(board, visited, idx - 1, idy);</div><div class=\"line\">    _visit(board, visited, idx, idy - 1);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int countBattleships(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</div><div class=\"line\">    int* visited[board.size()];</div><div class=\"line\">    for (int i = 0; i &lt; (int)board.size(); i++) &#123;</div><div class=\"line\">        visited[i] = new int[board[0].size()];</div><div class=\"line\">        memset(visited[i], 0, sizeof(int) * board[0].size());</div><div class=\"line\">    &#125;</div><div class=\"line\">    int res = 0;</div><div class=\"line\">    for (int idx = 0; idx &lt; (int)board.size(); idx++) &#123;</div><div class=\"line\">        for (int idy = 0; idy &lt; (int)board[0].size(); idy++) &#123;</div><div class=\"line\">            if (board[idx][idy] == &apos;X&apos; &amp;&amp; checkShip(board, visited, idx, idy)) &#123;</div><div class=\"line\">                res++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>But, if we can give up the visited array, just make sure the current cell’s left or up have X char to mark it has been visited. It will make sense.</p>\n<p>So, we should add these method to replace the former visited array:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool isVisited(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">    if (idx == 0 &amp;&amp; idy == 0) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125; else if (idx == 0) &#123;</div><div class=\"line\">        return board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">    &#125; else if (idy == 0) &#123;</div><div class=\"line\">        return board[idx - 1][idy] == &apos;X&apos;;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return board[idx - 1][idy] == &apos;X&apos; || board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>So, the last AC code will like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool isVisited(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (idx == 0 &amp;&amp; idy == 0) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125; else if (idx == 0) &#123;</div><div class=\"line\">                return board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">            &#125; else if (idy == 0) &#123;</div><div class=\"line\">                return board[idx - 1][idy] == &apos;X&apos;;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return board[idx - 1][idy] == &apos;X&apos; || board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool checkShip(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (isVisited(board, idx, idy)) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            bool res = true;</div><div class=\"line\">            // check the direction, down</div><div class=\"line\">            int currentIdx = idx, currentIdy = idy;</div><div class=\"line\">            while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">                if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    if (currentIdy + 1 &lt; (int)board[0].size() &amp;&amp; board[currentIdx][currentIdy + 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                        res = false;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    if (currentIdy - 1 &gt;= 0 &amp;&amp; board[currentIdx][currentIdy - 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                        res = false;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    res = true;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                currentIdx++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // check the direction, right</div><div class=\"line\">            currentIdx = idx, currentIdy = idy;</div><div class=\"line\">            if (!res) &#123;</div><div class=\"line\">                res = true;</div><div class=\"line\">                while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">                    if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                        if (currentIdx + 1 &lt; (int)board.size() &amp;&amp; board[currentIdx + 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                            res = false;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (currentIdx - 1 &gt;= 0 &amp;&amp; board[currentIdx - 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                            res = false;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        res = true;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    currentIdy++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            _visit(board, idx, idy);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _visit(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (idx &lt; 0 || idy &lt; 0|| idx &gt;= (int)board.size() || idy &gt;= (int)board[0].size()) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (isVisited(board, idx, idy)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (board[idx][idy] == &apos;.&apos;) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // visited[idx][idy] = 1;</div><div class=\"line\">            _visit(board, idx + 1, idy);</div><div class=\"line\">            _visit(board, idx, idy + 1);</div><div class=\"line\">            _visit(board, idx - 1, idy);</div><div class=\"line\">            _visit(board, idx, idy - 1);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int countBattleships(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)board.size(); idx++) &#123;</div><div class=\"line\">                for (int idy = 0; idy &lt; (int)board[0].size(); idy++) &#123;</div><div class=\"line\">                    if (board[idx][idy] == &apos;X&apos; &amp;&amp; checkShip(board, idx, idy)) &#123;</div><div class=\"line\">                        res++;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n","excerpt":"<blockquote>\n<p>Given an 2D board, count how many different battleships are in it. The battleships are represented with ‘X’s, empty slots are represented with ‘.’s. You may assume the following rules:</p>\n<ul>\n<li>You receive a valid board, made of only battleships or empty slots.</li>\n<li>Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.</li>\n<li>At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.</li>\n</ul>\n<p>Example:</p>\n<p>X..X<br>…X<br>…X</p>\n<p>In the above board there are 2 battleships.</p>\n<p>Invalid Example:</p>\n<p>…X<br>XXXX<br>…X</p>\n<p>This is an invalid board that you will not receive - as battleships will always have a cell separating between them.</p>\n<p>Follow up:<br>Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?</p>\n</blockquote>","more":"<p>This is Leetcode 419, and it’s easy enough to figure out with simulation way as following:</p>\n<ol>\n<li>find the first X char, from up to down and left to right.</li>\n<li>if found, then search up and right, to check whether it is ok.</li>\n<li>use a global flag to mark if it’s good for the result.</li>\n</ol>\n<p>This method will use O(n*n) array to mark the visited position, if not it will modify the value of the board to make sure no cell will visit twice.</p>\n<p>For example, if we use a visited array to mark the visited cells. the solution will be like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool checkShip(vector&lt;vector&lt;char&gt; &gt; &amp;board, int **visited, int idx, int idy) &#123;</div><div class=\"line\">    if (visited[idx][idy]) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    bool res = true;</div><div class=\"line\">    // check the direction, down</div><div class=\"line\">    int currentIdx = idx, currentIdy = idy;</div><div class=\"line\">    while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">        if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">            if (currentIdy + 1 &lt; (int)board[0].size() &amp;&amp; board[currentIdx][currentIdy + 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                res = false;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentIdy - 1 &gt;= 0 &amp;&amp; board[currentIdx][currentIdy - 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                res = false;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            res = true;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        currentIdx++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // check the direction, right</div><div class=\"line\">    currentIdx = idx, currentIdy = idy;</div><div class=\"line\">    if (!res) &#123;</div><div class=\"line\">        res = true;</div><div class=\"line\">        while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">            if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                if (currentIdx + 1 &lt; (int)board.size() &amp;&amp; board[currentIdx + 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    res = false;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (currentIdx - 1 &gt;= 0 &amp;&amp; board[currentIdx - 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    res = false;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                res = true;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentIdy++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    _visit(board, visited, idx, idy);</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void _visit(vector&lt;vector&lt;char&gt; &gt; &amp;board, int **visited, int idx, int idy) &#123;</div><div class=\"line\">    if (idx &lt; 0 || idy &lt; 0|| idx &gt;= (int)board.size() || idy &gt;= (int)board[0].size()) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (visited[idx][idy]) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (board[idx][idy] == &apos;.&apos;) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    visited[idx][idy] = 1;</div><div class=\"line\">    _visit(board, visited, idx + 1, idy);</div><div class=\"line\">    _visit(board, visited, idx, idy + 1);</div><div class=\"line\">    _visit(board, visited, idx - 1, idy);</div><div class=\"line\">    _visit(board, visited, idx, idy - 1);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int countBattleships(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</div><div class=\"line\">    int* visited[board.size()];</div><div class=\"line\">    for (int i = 0; i &lt; (int)board.size(); i++) &#123;</div><div class=\"line\">        visited[i] = new int[board[0].size()];</div><div class=\"line\">        memset(visited[i], 0, sizeof(int) * board[0].size());</div><div class=\"line\">    &#125;</div><div class=\"line\">    int res = 0;</div><div class=\"line\">    for (int idx = 0; idx &lt; (int)board.size(); idx++) &#123;</div><div class=\"line\">        for (int idy = 0; idy &lt; (int)board[0].size(); idy++) &#123;</div><div class=\"line\">            if (board[idx][idy] == &apos;X&apos; &amp;&amp; checkShip(board, visited, idx, idy)) &#123;</div><div class=\"line\">                res++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>But, if we can give up the visited array, just make sure the current cell’s left or up have X char to mark it has been visited. It will make sense.</p>\n<p>So, we should add these method to replace the former visited array:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool isVisited(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">    if (idx == 0 &amp;&amp; idy == 0) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125; else if (idx == 0) &#123;</div><div class=\"line\">        return board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">    &#125; else if (idy == 0) &#123;</div><div class=\"line\">        return board[idx - 1][idy] == &apos;X&apos;;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return board[idx - 1][idy] == &apos;X&apos; || board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>So, the last AC code will like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool isVisited(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (idx == 0 &amp;&amp; idy == 0) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125; else if (idx == 0) &#123;</div><div class=\"line\">                return board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">            &#125; else if (idy == 0) &#123;</div><div class=\"line\">                return board[idx - 1][idy] == &apos;X&apos;;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return board[idx - 1][idy] == &apos;X&apos; || board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool checkShip(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (isVisited(board, idx, idy)) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            bool res = true;</div><div class=\"line\">            // check the direction, down</div><div class=\"line\">            int currentIdx = idx, currentIdy = idy;</div><div class=\"line\">            while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">                if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    if (currentIdy + 1 &lt; (int)board[0].size() &amp;&amp; board[currentIdx][currentIdy + 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                        res = false;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    if (currentIdy - 1 &gt;= 0 &amp;&amp; board[currentIdx][currentIdy - 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                        res = false;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    res = true;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                currentIdx++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // check the direction, right</div><div class=\"line\">            currentIdx = idx, currentIdy = idy;</div><div class=\"line\">            if (!res) &#123;</div><div class=\"line\">                res = true;</div><div class=\"line\">                while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">                    if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                        if (currentIdx + 1 &lt; (int)board.size() &amp;&amp; board[currentIdx + 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                            res = false;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (currentIdx - 1 &gt;= 0 &amp;&amp; board[currentIdx - 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                            res = false;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        res = true;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    currentIdy++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            _visit(board, idx, idy);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _visit(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (idx &lt; 0 || idy &lt; 0|| idx &gt;= (int)board.size() || idy &gt;= (int)board[0].size()) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (isVisited(board, idx, idy)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (board[idx][idy] == &apos;.&apos;) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // visited[idx][idy] = 1;</div><div class=\"line\">            _visit(board, idx + 1, idy);</div><div class=\"line\">            _visit(board, idx, idy + 1);</div><div class=\"line\">            _visit(board, idx - 1, idy);</div><div class=\"line\">            _visit(board, idx, idy - 1);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int countBattleships(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)board.size(); idx++) &#123;</div><div class=\"line\">                for (int idy = 0; idy &lt; (int)board[0].size(); idy++) &#123;</div><div class=\"line\">                    if (board[idx][idy] == &apos;X&apos; &amp;&amp; checkShip(board, idx, idy)) &#123;</div><div class=\"line\">                        res++;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>"},{"title":"Heaters","date":"2017-01-04T05:46:25.000Z","_content":"\n> Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.\n>\n> So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.\n>\n> Note:\n>\n> + Numbers of houses and heaters you are given are non-negative and will not exceed 25000.\n> + Positions of houses and heaters you are given are non-negative and will not exceed 10^9.\n> + As long as a house is in the heaters' warm radius range, it can be warmed.\n> + All the heaters follow your radius standard and the warm radius will the same.\n>\n> Example 1:\n>\n> Input: [1,2,3],[2]\n> Output: 1\n> Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.\n>\n> Example 2:\n>\n> Input: [1,2,3,4],[1,4]\n> Output: 1\n> Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.\n\n<!-- more -->\n\nThis is Leetcode 475. As it's descripted, we can quickly find a solution. Picture this:\n\n\n```\n          h1   h2        h3\n           |    |         |\n......................................\n```\n\nIf we find the min value of the radius between every two heaters, and find the max one, which will be the result.\n\nAnd it's time complex is O(n*m), n is the num of the houses and m is the num of heaters.\n\n```\nusing namespace std;\n\nclass Solution {\npublic:\n    int idx;\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\n        sort(houses.begin(), houses.end());\n        sort(heaters.begin(), heaters.end());\n\n        int res = INT_MIN;\n        idx = 0;\n        for (int i = 0; i < (int)heaters.size(); i++) {\n            if (i == 0) {\n                res = max(res, findMinRadius(houses, -1, heaters[i]));\n            } else if (i == (int)heaters.size()) {\n                res = max(res, findMinRadius(houses, heaters[i - 1], -1));\n            } else {\n                res = max(res, findMinRadius(houses, heaters[i - 1], heaters[i]));\n            }\n            std::cout << res << std::endl;\n        }\n        return res;\n    }\n\n    int findMinRadius(vector<int> houses, int heater1, int heater2) {\n        if (heater1 == -1) { // means the first one\n            while (houses[idx] <= heater2) { idx++; }\n            return heater2 - houses[0];\n        } else if (heater2 == -1) { // means the last one\n            while (idx < (int)houses.size()) { idx++; }\n            return houses[idx - 1] - heater1;\n        } else {\n            int minRadius = INT_MAX;\n            for (int i = idx; houses[i] < heater2; i++) {\n                // minRadius = min(max(houses[i] - heater1, heater2 - houses[i]), minRadius);\n                // if there are (2n-1) houses, we need to use the mid one\n                // if there are (2n) houses, we should use the the mid two\n                // here is hard to decide which to use as the standard\n            }\n            return minRadius;\n        }\n    }\n};\n```\n\nHowever, there is a better way to figure this problem out. The idea is to leverage decent binarySearch function.\n\n+ For each house, find its position between those heaters (thus we need the heaters array to be sorted).\n+ Calculate the distances between this house and left heater and right heater, get a MIN value of those two values. Corner cases are there is no left or right heater.\n+ Get MAX value among distances in step 2. It's the answer.\n\nSo, here comes the solution:\n\n```\nclass Solution {\n    public:\n        int findRadius(vector<int>& houses, vector<int>& heaters) {\n            int house_size = houses.size();\n            if (house_size == 0) return 0;\n            sort(heaters.begin(), heaters.end());\n\n            int res = 0;\n            for (auto& c : houses) {\n\n                int idx = Bsearch(heaters, c);\n\n                if (idx == 0) {\n                    res = max(res, heaters[idx] - c);\n                } else if (idx >= (int)heaters.size()) {\n                    res = max(res, c - heaters.back());\n                } else {\n                    res = max(res, min(heaters[idx] - c, c - heaters[idx - 1]));\n                }\n            }\n            return res;\n        }\n\n        int Bsearch(vector<int>& nums, int val) {\n\n            int l = 0, r = nums.size() - 1;\n            while (l <= r) {\n                int mid = l + ((r - l) >> 1);\n                if (nums[mid] == val)\n                    return mid;\n                else if (nums[mid] < val)\n                    l = mid + 1;\n                else\n                    r = mid - 1;\n            }\n            return l;\n        }\n};\n```\n\nAnd it's AC.\n","source":"_posts/Heaters.md","raw":"---\ntitle: Heaters\ndate: 2017-01-04 13:46:25\ntags:\n    - Binary Search\n---\n\n> Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.\n>\n> So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.\n>\n> Note:\n>\n> + Numbers of houses and heaters you are given are non-negative and will not exceed 25000.\n> + Positions of houses and heaters you are given are non-negative and will not exceed 10^9.\n> + As long as a house is in the heaters' warm radius range, it can be warmed.\n> + All the heaters follow your radius standard and the warm radius will the same.\n>\n> Example 1:\n>\n> Input: [1,2,3],[2]\n> Output: 1\n> Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.\n>\n> Example 2:\n>\n> Input: [1,2,3,4],[1,4]\n> Output: 1\n> Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.\n\n<!-- more -->\n\nThis is Leetcode 475. As it's descripted, we can quickly find a solution. Picture this:\n\n\n```\n          h1   h2        h3\n           |    |         |\n......................................\n```\n\nIf we find the min value of the radius between every two heaters, and find the max one, which will be the result.\n\nAnd it's time complex is O(n*m), n is the num of the houses and m is the num of heaters.\n\n```\nusing namespace std;\n\nclass Solution {\npublic:\n    int idx;\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\n        sort(houses.begin(), houses.end());\n        sort(heaters.begin(), heaters.end());\n\n        int res = INT_MIN;\n        idx = 0;\n        for (int i = 0; i < (int)heaters.size(); i++) {\n            if (i == 0) {\n                res = max(res, findMinRadius(houses, -1, heaters[i]));\n            } else if (i == (int)heaters.size()) {\n                res = max(res, findMinRadius(houses, heaters[i - 1], -1));\n            } else {\n                res = max(res, findMinRadius(houses, heaters[i - 1], heaters[i]));\n            }\n            std::cout << res << std::endl;\n        }\n        return res;\n    }\n\n    int findMinRadius(vector<int> houses, int heater1, int heater2) {\n        if (heater1 == -1) { // means the first one\n            while (houses[idx] <= heater2) { idx++; }\n            return heater2 - houses[0];\n        } else if (heater2 == -1) { // means the last one\n            while (idx < (int)houses.size()) { idx++; }\n            return houses[idx - 1] - heater1;\n        } else {\n            int minRadius = INT_MAX;\n            for (int i = idx; houses[i] < heater2; i++) {\n                // minRadius = min(max(houses[i] - heater1, heater2 - houses[i]), minRadius);\n                // if there are (2n-1) houses, we need to use the mid one\n                // if there are (2n) houses, we should use the the mid two\n                // here is hard to decide which to use as the standard\n            }\n            return minRadius;\n        }\n    }\n};\n```\n\nHowever, there is a better way to figure this problem out. The idea is to leverage decent binarySearch function.\n\n+ For each house, find its position between those heaters (thus we need the heaters array to be sorted).\n+ Calculate the distances between this house and left heater and right heater, get a MIN value of those two values. Corner cases are there is no left or right heater.\n+ Get MAX value among distances in step 2. It's the answer.\n\nSo, here comes the solution:\n\n```\nclass Solution {\n    public:\n        int findRadius(vector<int>& houses, vector<int>& heaters) {\n            int house_size = houses.size();\n            if (house_size == 0) return 0;\n            sort(heaters.begin(), heaters.end());\n\n            int res = 0;\n            for (auto& c : houses) {\n\n                int idx = Bsearch(heaters, c);\n\n                if (idx == 0) {\n                    res = max(res, heaters[idx] - c);\n                } else if (idx >= (int)heaters.size()) {\n                    res = max(res, c - heaters.back());\n                } else {\n                    res = max(res, min(heaters[idx] - c, c - heaters[idx - 1]));\n                }\n            }\n            return res;\n        }\n\n        int Bsearch(vector<int>& nums, int val) {\n\n            int l = 0, r = nums.size() - 1;\n            while (l <= r) {\n                int mid = l + ((r - l) >> 1);\n                if (nums[mid] == val)\n                    return mid;\n                else if (nums[mid] < val)\n                    l = mid + 1;\n                else\n                    r = mid - 1;\n            }\n            return l;\n        }\n};\n```\n\nAnd it's AC.\n","slug":"Heaters","published":1,"updated":"2017-01-04T05:27:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixr4kw6j00046uf4m95xzh6c","content":"<blockquote>\n<p>Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.</p>\n<p>So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.</p>\n<p>Note:</p>\n<ul>\n<li>Numbers of houses and heaters you are given are non-negative and will not exceed 25000.</li>\n<li>Positions of houses and heaters you are given are non-negative and will not exceed 10^9.</li>\n<li>As long as a house is in the heaters’ warm radius range, it can be warmed.</li>\n<li>All the heaters follow your radius standard and the warm radius will the same.</li>\n</ul>\n<p>Example 1:</p>\n<p>Input: [1,2,3],[2]<br>Output: 1<br>Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.</p>\n<p>Example 2:</p>\n<p>Input: [1,2,3,4],[1,4]<br>Output: 1<br>Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 475. As it’s descripted, we can quickly find a solution. Picture this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">          h1   h2        h3</div><div class=\"line\">           |    |         |</div><div class=\"line\">......................................</div></pre></td></tr></table></figure>\n<p>If we find the min value of the radius between every two heaters, and find the max one, which will be the result.</p>\n<p>And it’s time complex is O(n*m), n is the num of the houses and m is the num of heaters.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    int idx;</div><div class=\"line\">    int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;</div><div class=\"line\">        sort(houses.begin(), houses.end());</div><div class=\"line\">        sort(heaters.begin(), heaters.end());</div><div class=\"line\"></div><div class=\"line\">        int res = INT_MIN;</div><div class=\"line\">        idx = 0;</div><div class=\"line\">        for (int i = 0; i &lt; (int)heaters.size(); i++) &#123;</div><div class=\"line\">            if (i == 0) &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, -1, heaters[i]));</div><div class=\"line\">            &#125; else if (i == (int)heaters.size()) &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, heaters[i - 1], -1));</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, heaters[i - 1], heaters[i]));</div><div class=\"line\">            &#125;</div><div class=\"line\">            std::cout &lt;&lt; res &lt;&lt; std::endl;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return res;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int findMinRadius(vector&lt;int&gt; houses, int heater1, int heater2) &#123;</div><div class=\"line\">        if (heater1 == -1) &#123; // means the first one</div><div class=\"line\">            while (houses[idx] &lt;= heater2) &#123; idx++; &#125;</div><div class=\"line\">            return heater2 - houses[0];</div><div class=\"line\">        &#125; else if (heater2 == -1) &#123; // means the last one</div><div class=\"line\">            while (idx &lt; (int)houses.size()) &#123; idx++; &#125;</div><div class=\"line\">            return houses[idx - 1] - heater1;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            int minRadius = INT_MAX;</div><div class=\"line\">            for (int i = idx; houses[i] &lt; heater2; i++) &#123;</div><div class=\"line\">                // minRadius = min(max(houses[i] - heater1, heater2 - houses[i]), minRadius);</div><div class=\"line\">                // if there are (2n-1) houses, we need to use the mid one</div><div class=\"line\">                // if there are (2n) houses, we should use the the mid two</div><div class=\"line\">                // here is hard to decide which to use as the standard</div><div class=\"line\">            &#125;</div><div class=\"line\">            return minRadius;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>However, there is a better way to figure this problem out. The idea is to leverage decent binarySearch function.</p>\n<ul>\n<li>For each house, find its position between those heaters (thus we need the heaters array to be sorted).</li>\n<li>Calculate the distances between this house and left heater and right heater, get a MIN value of those two values. Corner cases are there is no left or right heater.</li>\n<li>Get MAX value among distances in step 2. It’s the answer.</li>\n</ul>\n<p>So, here comes the solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;</div><div class=\"line\">            int house_size = houses.size();</div><div class=\"line\">            if (house_size == 0) return 0;</div><div class=\"line\">            sort(heaters.begin(), heaters.end());</div><div class=\"line\"></div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (auto&amp; c : houses) &#123;</div><div class=\"line\"></div><div class=\"line\">                int idx = Bsearch(heaters, c);</div><div class=\"line\"></div><div class=\"line\">                if (idx == 0) &#123;</div><div class=\"line\">                    res = max(res, heaters[idx] - c);</div><div class=\"line\">                &#125; else if (idx &gt;= (int)heaters.size()) &#123;</div><div class=\"line\">                    res = max(res, c - heaters.back());</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    res = max(res, min(heaters[idx] - c, c - heaters[idx - 1]));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int Bsearch(vector&lt;int&gt;&amp; nums, int val) &#123;</div><div class=\"line\"></div><div class=\"line\">            int l = 0, r = nums.size() - 1;</div><div class=\"line\">            while (l &lt;= r) &#123;</div><div class=\"line\">                int mid = l + ((r - l) &gt;&gt; 1);</div><div class=\"line\">                if (nums[mid] == val)</div><div class=\"line\">                    return mid;</div><div class=\"line\">                else if (nums[mid] &lt; val)</div><div class=\"line\">                    l = mid + 1;</div><div class=\"line\">                else</div><div class=\"line\">                    r = mid - 1;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return l;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it’s AC.</p>\n","excerpt":"<blockquote>\n<p>Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.</p>\n<p>So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.</p>\n<p>Note:</p>\n<ul>\n<li>Numbers of houses and heaters you are given are non-negative and will not exceed 25000.</li>\n<li>Positions of houses and heaters you are given are non-negative and will not exceed 10^9.</li>\n<li>As long as a house is in the heaters’ warm radius range, it can be warmed.</li>\n<li>All the heaters follow your radius standard and the warm radius will the same.</li>\n</ul>\n<p>Example 1:</p>\n<p>Input: [1,2,3],[2]<br>Output: 1<br>Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.</p>\n<p>Example 2:</p>\n<p>Input: [1,2,3,4],[1,4]<br>Output: 1<br>Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.</p>\n</blockquote>","more":"<p>This is Leetcode 475. As it’s descripted, we can quickly find a solution. Picture this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">          h1   h2        h3</div><div class=\"line\">           |    |         |</div><div class=\"line\">......................................</div></pre></td></tr></table></figure>\n<p>If we find the min value of the radius between every two heaters, and find the max one, which will be the result.</p>\n<p>And it’s time complex is O(n*m), n is the num of the houses and m is the num of heaters.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    int idx;</div><div class=\"line\">    int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;</div><div class=\"line\">        sort(houses.begin(), houses.end());</div><div class=\"line\">        sort(heaters.begin(), heaters.end());</div><div class=\"line\"></div><div class=\"line\">        int res = INT_MIN;</div><div class=\"line\">        idx = 0;</div><div class=\"line\">        for (int i = 0; i &lt; (int)heaters.size(); i++) &#123;</div><div class=\"line\">            if (i == 0) &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, -1, heaters[i]));</div><div class=\"line\">            &#125; else if (i == (int)heaters.size()) &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, heaters[i - 1], -1));</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, heaters[i - 1], heaters[i]));</div><div class=\"line\">            &#125;</div><div class=\"line\">            std::cout &lt;&lt; res &lt;&lt; std::endl;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return res;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int findMinRadius(vector&lt;int&gt; houses, int heater1, int heater2) &#123;</div><div class=\"line\">        if (heater1 == -1) &#123; // means the first one</div><div class=\"line\">            while (houses[idx] &lt;= heater2) &#123; idx++; &#125;</div><div class=\"line\">            return heater2 - houses[0];</div><div class=\"line\">        &#125; else if (heater2 == -1) &#123; // means the last one</div><div class=\"line\">            while (idx &lt; (int)houses.size()) &#123; idx++; &#125;</div><div class=\"line\">            return houses[idx - 1] - heater1;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            int minRadius = INT_MAX;</div><div class=\"line\">            for (int i = idx; houses[i] &lt; heater2; i++) &#123;</div><div class=\"line\">                // minRadius = min(max(houses[i] - heater1, heater2 - houses[i]), minRadius);</div><div class=\"line\">                // if there are (2n-1) houses, we need to use the mid one</div><div class=\"line\">                // if there are (2n) houses, we should use the the mid two</div><div class=\"line\">                // here is hard to decide which to use as the standard</div><div class=\"line\">            &#125;</div><div class=\"line\">            return minRadius;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>However, there is a better way to figure this problem out. The idea is to leverage decent binarySearch function.</p>\n<ul>\n<li>For each house, find its position between those heaters (thus we need the heaters array to be sorted).</li>\n<li>Calculate the distances between this house and left heater and right heater, get a MIN value of those two values. Corner cases are there is no left or right heater.</li>\n<li>Get MAX value among distances in step 2. It’s the answer.</li>\n</ul>\n<p>So, here comes the solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;</div><div class=\"line\">            int house_size = houses.size();</div><div class=\"line\">            if (house_size == 0) return 0;</div><div class=\"line\">            sort(heaters.begin(), heaters.end());</div><div class=\"line\"></div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (auto&amp; c : houses) &#123;</div><div class=\"line\"></div><div class=\"line\">                int idx = Bsearch(heaters, c);</div><div class=\"line\"></div><div class=\"line\">                if (idx == 0) &#123;</div><div class=\"line\">                    res = max(res, heaters[idx] - c);</div><div class=\"line\">                &#125; else if (idx &gt;= (int)heaters.size()) &#123;</div><div class=\"line\">                    res = max(res, c - heaters.back());</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    res = max(res, min(heaters[idx] - c, c - heaters[idx - 1]));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int Bsearch(vector&lt;int&gt;&amp; nums, int val) &#123;</div><div class=\"line\"></div><div class=\"line\">            int l = 0, r = nums.size() - 1;</div><div class=\"line\">            while (l &lt;= r) &#123;</div><div class=\"line\">                int mid = l + ((r - l) &gt;&gt; 1);</div><div class=\"line\">                if (nums[mid] == val)</div><div class=\"line\">                    return mid;</div><div class=\"line\">                else if (nums[mid] &lt; val)</div><div class=\"line\">                    l = mid + 1;</div><div class=\"line\">                else</div><div class=\"line\">                    r = mid - 1;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return l;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it’s AC.</p>"},{"title":"Intersection of Two Arrays II","date":"2017-01-08T14:36:11.000Z","_content":"\n\n> Given two arrays, write a function to compute their intersection.\n>\n> Example:\n> Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].\n>\n> Note:\n>\n>   + Each element in the result should appear as many times as it shows in both arrays.\n>   + The result can be in any order.\n>\n> Follow up:\n>\n>   + What if the given array is already sorted? How would you optimize your algorithm?\n>   + What if nums1's size is small compared to nums2's size? Which algorithm is better?\n>   + What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?\n\n<!--more-->\n\nThis is Leetcode 350. It's an easy problem, we can quickly write a solution based on hash map:\n\n```\nclass Solution {\n    public:\n        vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n            map<int, int> nums;\n            vector<int> res;\n\n\n            for (int i = 0; i < (int)nums1.size(); i++) {\n                if (nums.find(nums1[i]) == nums.end()) {\n                    nums.insert(pair<int, int>(nums1[i], 1));\n                } else {\n                    nums.find(nums1[i])->second++;\n                }\n            }\n\n            for (int i = 0; i < (int)nums2.size(); i++) {\n                if (nums.find(nums2[i]) != nums.end() && nums.find(nums2[i])->second > 0) {\n                    res.push_back(nums2[i]);\n                    nums.find(nums2[i])->second--;\n                }\n            }\n\n            return res;\n        }\n};\n```\n\nIts time complex is O(n), and its space complex is O(n), which makes it not a good solution. So, as the follow up, we can assume that the both arrays are sorted. Then we can use the two points method like below:\n\n```\nclass Solution {\n    public:\n        vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n            int idx = 0, idy = 0;\n            vector<int> res;\n\n            sort(nums1.begin(), nums1.end());\n            sort(nums2.begin(), nums2.end());\n\n            while (idx < (int)nums1.size() && idy < (int)nums2.size()) {\n                if (nums1[idx] == nums2[idy]) {\n                    res.push_back(nums1[idx]);\n                    idx++; idy++;\n                } else if (nums1[idx] > nums2[idy]) {\n                    idy++;\n                } else if (nums1[idx] < nums2[idy]) {\n                    idx++;\n                }\n            }\n\n            return res;\n        }\n};\n```\n\nIts time complex is O(n) but its space complex is O(1), which makes it better than the hash map solution.\n\nIf the memeory is limited such that we can't load all elements into the memory at once? This is a common problem. And we can use the hash algorithm to divide all elements in to different group and then we deal with them one by one.\n\n","source":"_posts/IntersectionofTwoArraysII.md","raw":"---\ntitle: Intersection of Two Arrays II\ndate: 2017-01-08 22:36:11\ntags:\n    - Binary Search\n    - Hash Table\n    - Two Pointers\n    - Sort\n---\n\n\n> Given two arrays, write a function to compute their intersection.\n>\n> Example:\n> Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].\n>\n> Note:\n>\n>   + Each element in the result should appear as many times as it shows in both arrays.\n>   + The result can be in any order.\n>\n> Follow up:\n>\n>   + What if the given array is already sorted? How would you optimize your algorithm?\n>   + What if nums1's size is small compared to nums2's size? Which algorithm is better?\n>   + What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?\n\n<!--more-->\n\nThis is Leetcode 350. It's an easy problem, we can quickly write a solution based on hash map:\n\n```\nclass Solution {\n    public:\n        vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n            map<int, int> nums;\n            vector<int> res;\n\n\n            for (int i = 0; i < (int)nums1.size(); i++) {\n                if (nums.find(nums1[i]) == nums.end()) {\n                    nums.insert(pair<int, int>(nums1[i], 1));\n                } else {\n                    nums.find(nums1[i])->second++;\n                }\n            }\n\n            for (int i = 0; i < (int)nums2.size(); i++) {\n                if (nums.find(nums2[i]) != nums.end() && nums.find(nums2[i])->second > 0) {\n                    res.push_back(nums2[i]);\n                    nums.find(nums2[i])->second--;\n                }\n            }\n\n            return res;\n        }\n};\n```\n\nIts time complex is O(n), and its space complex is O(n), which makes it not a good solution. So, as the follow up, we can assume that the both arrays are sorted. Then we can use the two points method like below:\n\n```\nclass Solution {\n    public:\n        vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n            int idx = 0, idy = 0;\n            vector<int> res;\n\n            sort(nums1.begin(), nums1.end());\n            sort(nums2.begin(), nums2.end());\n\n            while (idx < (int)nums1.size() && idy < (int)nums2.size()) {\n                if (nums1[idx] == nums2[idy]) {\n                    res.push_back(nums1[idx]);\n                    idx++; idy++;\n                } else if (nums1[idx] > nums2[idy]) {\n                    idy++;\n                } else if (nums1[idx] < nums2[idy]) {\n                    idx++;\n                }\n            }\n\n            return res;\n        }\n};\n```\n\nIts time complex is O(n) but its space complex is O(1), which makes it better than the hash map solution.\n\nIf the memeory is limited such that we can't load all elements into the memory at once? This is a common problem. And we can use the hash algorithm to divide all elements in to different group and then we deal with them one by one.\n\n","slug":"IntersectionofTwoArraysII","published":1,"updated":"2017-01-08T15:01:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixr4kw6n00056uf4k4jbb6bq","content":"<blockquote>\n<p>Given two arrays, write a function to compute their intersection.</p>\n<p>Example:<br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].</p>\n<p>Note:</p>\n<ul>\n<li>Each element in the result should appear as many times as it shows in both arrays.</li>\n<li>The result can be in any order.</li>\n</ul>\n<p>Follow up:</p>\n<ul>\n<li>What if the given array is already sorted? How would you optimize your algorithm?</li>\n<li>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?</li>\n<li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 350. It’s an easy problem, we can quickly write a solution based on hash map:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</div><div class=\"line\">            map&lt;int, int&gt; nums;</div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums1.size(); i++) &#123;</div><div class=\"line\">                if (nums.find(nums1[i]) == nums.end()) &#123;</div><div class=\"line\">                    nums.insert(pair&lt;int, int&gt;(nums1[i], 1));</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    nums.find(nums1[i])-&gt;second++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums2.size(); i++) &#123;</div><div class=\"line\">                if (nums.find(nums2[i]) != nums.end() &amp;&amp; nums.find(nums2[i])-&gt;second &gt; 0) &#123;</div><div class=\"line\">                    res.push_back(nums2[i]);</div><div class=\"line\">                    nums.find(nums2[i])-&gt;second--;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Its time complex is O(n), and its space complex is O(n), which makes it not a good solution. So, as the follow up, we can assume that the both arrays are sorted. Then we can use the two points method like below:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</div><div class=\"line\">            int idx = 0, idy = 0;</div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\"></div><div class=\"line\">            sort(nums1.begin(), nums1.end());</div><div class=\"line\">            sort(nums2.begin(), nums2.end());</div><div class=\"line\"></div><div class=\"line\">            while (idx &lt; (int)nums1.size() &amp;&amp; idy &lt; (int)nums2.size()) &#123;</div><div class=\"line\">                if (nums1[idx] == nums2[idy]) &#123;</div><div class=\"line\">                    res.push_back(nums1[idx]);</div><div class=\"line\">                    idx++; idy++;</div><div class=\"line\">                &#125; else if (nums1[idx] &gt; nums2[idy]) &#123;</div><div class=\"line\">                    idy++;</div><div class=\"line\">                &#125; else if (nums1[idx] &lt; nums2[idy]) &#123;</div><div class=\"line\">                    idx++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Its time complex is O(n) but its space complex is O(1), which makes it better than the hash map solution.</p>\n<p>If the memeory is limited such that we can’t load all elements into the memory at once? This is a common problem. And we can use the hash algorithm to divide all elements in to different group and then we deal with them one by one.</p>\n","excerpt":"<blockquote>\n<p>Given two arrays, write a function to compute their intersection.</p>\n<p>Example:<br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].</p>\n<p>Note:</p>\n<ul>\n<li>Each element in the result should appear as many times as it shows in both arrays.</li>\n<li>The result can be in any order.</li>\n</ul>\n<p>Follow up:</p>\n<ul>\n<li>What if the given array is already sorted? How would you optimize your algorithm?</li>\n<li>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?</li>\n<li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 350. It’s an easy problem, we can quickly write a solution based on hash map:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</div><div class=\"line\">            map&lt;int, int&gt; nums;</div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums1.size(); i++) &#123;</div><div class=\"line\">                if (nums.find(nums1[i]) == nums.end()) &#123;</div><div class=\"line\">                    nums.insert(pair&lt;int, int&gt;(nums1[i], 1));</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    nums.find(nums1[i])-&gt;second++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums2.size(); i++) &#123;</div><div class=\"line\">                if (nums.find(nums2[i]) != nums.end() &amp;&amp; nums.find(nums2[i])-&gt;second &gt; 0) &#123;</div><div class=\"line\">                    res.push_back(nums2[i]);</div><div class=\"line\">                    nums.find(nums2[i])-&gt;second--;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Its time complex is O(n), and its space complex is O(n), which makes it not a good solution. So, as the follow up, we can assume that the both arrays are sorted. Then we can use the two points method like below:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</div><div class=\"line\">            int idx = 0, idy = 0;</div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\"></div><div class=\"line\">            sort(nums1.begin(), nums1.end());</div><div class=\"line\">            sort(nums2.begin(), nums2.end());</div><div class=\"line\"></div><div class=\"line\">            while (idx &lt; (int)nums1.size() &amp;&amp; idy &lt; (int)nums2.size()) &#123;</div><div class=\"line\">                if (nums1[idx] == nums2[idy]) &#123;</div><div class=\"line\">                    res.push_back(nums1[idx]);</div><div class=\"line\">                    idx++; idy++;</div><div class=\"line\">                &#125; else if (nums1[idx] &gt; nums2[idy]) &#123;</div><div class=\"line\">                    idy++;</div><div class=\"line\">                &#125; else if (nums1[idx] &lt; nums2[idy]) &#123;</div><div class=\"line\">                    idx++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Its time complex is O(n) but its space complex is O(1), which makes it better than the hash map solution.</p>\n<p>If the memeory is limited such that we can’t load all elements into the memory at once? This is a common problem. And we can use the hash algorithm to divide all elements in to different group and then we deal with them one by one.</p>"},{"title":"Longest Increasing Path in a Matrix","date":"2017-01-09T08:15:57.000Z","_content":"\n> Given an integer matrix, find the length of the longest increasing path.\n>\n> From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).\n>\n> Example 1:\n>\n> nums = [ [9,9,4], [6,6,8], [2,1,1] ]\n>\n> Return 4\n> The longest increasing path is [1, 2, 6, 9].\n>\n> Example 2:\n>\n> nums = [ [3,4,5], [3,2,6], [2,2,1] ]\n>\n> Return 4\n> The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.\n\n<!-- more -->\n\nThis is Leetcode 329, it's a classic DFS problem. And you can use more space to improve its performance.\n\nFor example, you can use two maxDepth array to store the max depth in current position and its direction.\n\nSo, its solution will be as following, (we use the build-in dfs function):\n\n```\nclass Solution {\n    public:\n        int longestIncreasingPath(vector<vector<int>>& matrix) {\n            int rows = matrix.size();\n            if (!rows) return 0;\n            int cols = matrix[0].size();\n\n            vector<vector<int>> dp(rows, vector<int>(cols, 0));\n            std::function<int(int, int)> dfs = [&] (int x, int y) {\n                if (dp[x][y]) return dp[x][y];\n                vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\n                for (auto &dir : dirs) {\n                    int xx = x + dir[0], yy = y + dir[1];\n                    if (xx < 0 || xx >= rows || yy < 0 || yy >= cols) continue;\n                    if (matrix[xx][yy] <= matrix[x][y]) continue;\n                    dp[x][y] = std::max(dp[x][y], dfs(xx, yy));\n                }\n                return ++dp[x][y];\n            };\n\n            int ret = 0;\n            for (int i = 0; i < rows; ++i) {\n                for (int j = 0; j < cols; ++j) {\n                    ret = std::max(ret, dfs(i, j));\n                }\n            }\n\n            return ret;\n        }\n};\n```\n","source":"_posts/LongestIncreasingPathinaMatrix.md","raw":"---\ntitle: Longest Increasing Path in a Matrix\ndate: 2017-01-09 16:15:57\ntags:\n    - Depth-first Search\n    - Memoization\n    - Topological sort\n---\n\n> Given an integer matrix, find the length of the longest increasing path.\n>\n> From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).\n>\n> Example 1:\n>\n> nums = [ [9,9,4], [6,6,8], [2,1,1] ]\n>\n> Return 4\n> The longest increasing path is [1, 2, 6, 9].\n>\n> Example 2:\n>\n> nums = [ [3,4,5], [3,2,6], [2,2,1] ]\n>\n> Return 4\n> The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.\n\n<!-- more -->\n\nThis is Leetcode 329, it's a classic DFS problem. And you can use more space to improve its performance.\n\nFor example, you can use two maxDepth array to store the max depth in current position and its direction.\n\nSo, its solution will be as following, (we use the build-in dfs function):\n\n```\nclass Solution {\n    public:\n        int longestIncreasingPath(vector<vector<int>>& matrix) {\n            int rows = matrix.size();\n            if (!rows) return 0;\n            int cols = matrix[0].size();\n\n            vector<vector<int>> dp(rows, vector<int>(cols, 0));\n            std::function<int(int, int)> dfs = [&] (int x, int y) {\n                if (dp[x][y]) return dp[x][y];\n                vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\n                for (auto &dir : dirs) {\n                    int xx = x + dir[0], yy = y + dir[1];\n                    if (xx < 0 || xx >= rows || yy < 0 || yy >= cols) continue;\n                    if (matrix[xx][yy] <= matrix[x][y]) continue;\n                    dp[x][y] = std::max(dp[x][y], dfs(xx, yy));\n                }\n                return ++dp[x][y];\n            };\n\n            int ret = 0;\n            for (int i = 0; i < rows; ++i) {\n                for (int j = 0; j < cols; ++j) {\n                    ret = std::max(ret, dfs(i, j));\n                }\n            }\n\n            return ret;\n        }\n};\n```\n","slug":"LongestIncreasingPathinaMatrix","published":1,"updated":"2017-01-09T08:24:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixr4kw6q00076uf41y948ltz","content":"<blockquote>\n<p>Given an integer matrix, find the length of the longest increasing path.</p>\n<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>\n<p>Example 1:</p>\n<p>nums = [ [9,9,4], [6,6,8], [2,1,1] ]</p>\n<p>Return 4<br>The longest increasing path is [1, 2, 6, 9].</p>\n<p>Example 2:</p>\n<p>nums = [ [3,4,5], [3,2,6], [2,2,1] ]</p>\n<p>Return 4<br>The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 329, it’s a classic DFS problem. And you can use more space to improve its performance.</p>\n<p>For example, you can use two maxDepth array to store the max depth in current position and its direction.</p>\n<p>So, its solution will be as following, (we use the build-in dfs function):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</div><div class=\"line\">            int rows = matrix.size();</div><div class=\"line\">            if (!rows) return 0;</div><div class=\"line\">            int cols = matrix[0].size();</div><div class=\"line\"></div><div class=\"line\">            vector&lt;vector&lt;int&gt;&gt; dp(rows, vector&lt;int&gt;(cols, 0));</div><div class=\"line\">            std::function&lt;int(int, int)&gt; dfs = [&amp;] (int x, int y) &#123;</div><div class=\"line\">                if (dp[x][y]) return dp[x][y];</div><div class=\"line\">                vector&lt;vector&lt;int&gt;&gt; dirs = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;</div><div class=\"line\">                for (auto &amp;dir : dirs) &#123;</div><div class=\"line\">                    int xx = x + dir[0], yy = y + dir[1];</div><div class=\"line\">                    if (xx &lt; 0 || xx &gt;= rows || yy &lt; 0 || yy &gt;= cols) continue;</div><div class=\"line\">                    if (matrix[xx][yy] &lt;= matrix[x][y]) continue;</div><div class=\"line\">                    dp[x][y] = std::max(dp[x][y], dfs(xx, yy));</div><div class=\"line\">                &#125;</div><div class=\"line\">                return ++dp[x][y];</div><div class=\"line\">            &#125;;</div><div class=\"line\"></div><div class=\"line\">            int ret = 0;</div><div class=\"line\">            for (int i = 0; i &lt; rows; ++i) &#123;</div><div class=\"line\">                for (int j = 0; j &lt; cols; ++j) &#123;</div><div class=\"line\">                    ret = std::max(ret, dfs(i, j));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return ret;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n","excerpt":"<blockquote>\n<p>Given an integer matrix, find the length of the longest increasing path.</p>\n<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>\n<p>Example 1:</p>\n<p>nums = [ [9,9,4], [6,6,8], [2,1,1] ]</p>\n<p>Return 4<br>The longest increasing path is [1, 2, 6, 9].</p>\n<p>Example 2:</p>\n<p>nums = [ [3,4,5], [3,2,6], [2,2,1] ]</p>\n<p>Return 4<br>The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</p>\n</blockquote>","more":"<p>This is Leetcode 329, it’s a classic DFS problem. And you can use more space to improve its performance.</p>\n<p>For example, you can use two maxDepth array to store the max depth in current position and its direction.</p>\n<p>So, its solution will be as following, (we use the build-in dfs function):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</div><div class=\"line\">            int rows = matrix.size();</div><div class=\"line\">            if (!rows) return 0;</div><div class=\"line\">            int cols = matrix[0].size();</div><div class=\"line\"></div><div class=\"line\">            vector&lt;vector&lt;int&gt;&gt; dp(rows, vector&lt;int&gt;(cols, 0));</div><div class=\"line\">            std::function&lt;int(int, int)&gt; dfs = [&amp;] (int x, int y) &#123;</div><div class=\"line\">                if (dp[x][y]) return dp[x][y];</div><div class=\"line\">                vector&lt;vector&lt;int&gt;&gt; dirs = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;</div><div class=\"line\">                for (auto &amp;dir : dirs) &#123;</div><div class=\"line\">                    int xx = x + dir[0], yy = y + dir[1];</div><div class=\"line\">                    if (xx &lt; 0 || xx &gt;= rows || yy &lt; 0 || yy &gt;= cols) continue;</div><div class=\"line\">                    if (matrix[xx][yy] &lt;= matrix[x][y]) continue;</div><div class=\"line\">                    dp[x][y] = std::max(dp[x][y], dfs(xx, yy));</div><div class=\"line\">                &#125;</div><div class=\"line\">                return ++dp[x][y];</div><div class=\"line\">            &#125;;</div><div class=\"line\"></div><div class=\"line\">            int ret = 0;</div><div class=\"line\">            for (int i = 0; i &lt; rows; ++i) &#123;</div><div class=\"line\">                for (int j = 0; j &lt; cols; ++j) &#123;</div><div class=\"line\">                    ret = std::max(ret, dfs(i, j));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return ret;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>"},{"title":"New Start","date":"2017-01-01T05:46:25.000Z","_content":"\nAs I promised before. I will write blogs in two languages. And here, I will use English to write about my oj games in order to improve my interview skills.\n\n<!--more-->\n","source":"_posts/NewStart.md","raw":"---\ntitle: New Start\ndate: 2017-01-01 13:46:25\ntags: \n    - Description\n---\n\nAs I promised before. I will write blogs in two languages. And here, I will use English to write about my oj games in order to improve my interview skills.\n\n<!--more-->\n","slug":"NewStart","published":1,"updated":"2017-01-03T06:47:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixr4kw6s00086uf45zq44k1z","content":"<p>As I promised before. I will write blogs in two languages. And here, I will use English to write about my oj games in order to improve my interview skills.</p>\n<a id=\"more\"></a>\n","excerpt":"<p>As I promised before. I will write blogs in two languages. And here, I will use English to write about my oj games in order to improve my interview skills.</p>","more":""},{"title":"Partition Equal Subset Sum","date":"2017-01-06T05:46:25.000Z","_content":"\n> Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n>\n> Note:\n>\n> + Each of the array element will not exceed 100.\n> + The array size will not exceed 200.\n>\n> Example 1:\n>\n> Input: [1, 5, 11, 5]\n>\n> Output: true\n>\n> Explanation: The array can be partitioned as [1, 5, 5] and [11].\n>\n> Example 2:\n>\n> Input: [1, 2, 3, 5]\n>\n> Output: false\n>\n> Explanation: The array cannot be partitioned into equal sum subsets.\n>\n> Subscribe to see which companies asked this question\n\n<!-- more -->\n\nThis is Leetcode 416, and it is a leetweek problem. My last pass code like these:\n```\nclass Solution {\n    public:\n        bool canPartition(vector<int>& nums) {\n            if (nums.size() < 2) {\n                return false;\n            }\n            int sum = 0;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                sum = sum + nums[i];\n            }\n            if (sum % 2 != 0) {\n                return false;\n            }\n            return check(0, 0, nums, sum);\n        }\n\n        bool check(int start, int current, vector<int> nums, int sum) {\n            bool res = false;\n            if (current > sum / 2) {\n                return false;\n            }\n            if (current == sum / 2) {\n                return true;\n            }\n            for (int i = start + 1; i < (int)nums.size(); i++) {\n                res = res || check(i, current + nums[i], nums, sum);\n            }\n            return res;\n        }\n};\n```\nBecause the time complex of this recursive functoin is O(n!), the worst condition. So, we can change our mind to turn this problem into another one.\n\nFind a set of the subarray which its sum is sum / 2. And we can use the DP solution.\n\nBecause we know the sum of the array, so we make a array **dp** in size sum/2. And after a for loop. we will know the dp[num] and dp[sum/2 - num] can achieve. So, when we for twice, like:\n```\nfor (auto num : nums) {\n    for(int i = target; i >= num; i--) { // to be quick we don't visit the whole dp array\n        dp[i] = dp[i] || dp[i - num];\n    }\n}\n```\n\nSo, here comes a better solution based on DP:\n\n```\nusing namespace std;\nclass Solution {\n    public:\n        bool canPartition(vector<int>& nums) {\n            int sum = accumulate(nums.begin(), nums.end(), 0);\n            if (sum & 1) return false;\n            int half = sum >> 1;\n\n            vector<bool> accessibility(half + 1, false);\n            accessibility[0] = true;    // '0' is always reachable\n            //For all num in nums, check the accessibility from half - num to 0.\n            //If 'i' is accessible by former numbers, then 'i + num' is also accessible. (DP Algorithm)\n            for(int num: nums)\n                //Below here we must start from 'half' downto 'num', otherwise current 'num' might be multiply used.\n                //e.g.: If num == 2, then we will have 2, 4, 6... will all be accessible and lead to wrong answer.\n                for(int i = half; i >= num; i--){\n                    if (accessibility[i - num] == true){\n                        accessibility[i] = true;\n                    }\n                }\n            return accessibility[half];\n        }\n};\n```\n\nHowever it's space complex is O(n), so if you need a O(1) solution, I find a cool solution based on bitset.\n\n```\nbool canPartition(vector<int>& nums) {\n    bitset<5001> bits(1);\n    int sum = accumulate(nums.begin(), nums.end(), 0);\n    for (auto n : nums) bits |= bits << n;\n    return !(sum & 1) && bits[sum >> 1];\n}\n```\nWhy and how it works, remaining unknown.\n","source":"_posts/PartitionEqualSubsetSum.md","raw":"---\ntitle: Partition Equal Subset Sum\ndate: 2017-01-06 13:46:25\ntags:\n    - Dynamic Programming\n---\n\n> Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n>\n> Note:\n>\n> + Each of the array element will not exceed 100.\n> + The array size will not exceed 200.\n>\n> Example 1:\n>\n> Input: [1, 5, 11, 5]\n>\n> Output: true\n>\n> Explanation: The array can be partitioned as [1, 5, 5] and [11].\n>\n> Example 2:\n>\n> Input: [1, 2, 3, 5]\n>\n> Output: false\n>\n> Explanation: The array cannot be partitioned into equal sum subsets.\n>\n> Subscribe to see which companies asked this question\n\n<!-- more -->\n\nThis is Leetcode 416, and it is a leetweek problem. My last pass code like these:\n```\nclass Solution {\n    public:\n        bool canPartition(vector<int>& nums) {\n            if (nums.size() < 2) {\n                return false;\n            }\n            int sum = 0;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                sum = sum + nums[i];\n            }\n            if (sum % 2 != 0) {\n                return false;\n            }\n            return check(0, 0, nums, sum);\n        }\n\n        bool check(int start, int current, vector<int> nums, int sum) {\n            bool res = false;\n            if (current > sum / 2) {\n                return false;\n            }\n            if (current == sum / 2) {\n                return true;\n            }\n            for (int i = start + 1; i < (int)nums.size(); i++) {\n                res = res || check(i, current + nums[i], nums, sum);\n            }\n            return res;\n        }\n};\n```\nBecause the time complex of this recursive functoin is O(n!), the worst condition. So, we can change our mind to turn this problem into another one.\n\nFind a set of the subarray which its sum is sum / 2. And we can use the DP solution.\n\nBecause we know the sum of the array, so we make a array **dp** in size sum/2. And after a for loop. we will know the dp[num] and dp[sum/2 - num] can achieve. So, when we for twice, like:\n```\nfor (auto num : nums) {\n    for(int i = target; i >= num; i--) { // to be quick we don't visit the whole dp array\n        dp[i] = dp[i] || dp[i - num];\n    }\n}\n```\n\nSo, here comes a better solution based on DP:\n\n```\nusing namespace std;\nclass Solution {\n    public:\n        bool canPartition(vector<int>& nums) {\n            int sum = accumulate(nums.begin(), nums.end(), 0);\n            if (sum & 1) return false;\n            int half = sum >> 1;\n\n            vector<bool> accessibility(half + 1, false);\n            accessibility[0] = true;    // '0' is always reachable\n            //For all num in nums, check the accessibility from half - num to 0.\n            //If 'i' is accessible by former numbers, then 'i + num' is also accessible. (DP Algorithm)\n            for(int num: nums)\n                //Below here we must start from 'half' downto 'num', otherwise current 'num' might be multiply used.\n                //e.g.: If num == 2, then we will have 2, 4, 6... will all be accessible and lead to wrong answer.\n                for(int i = half; i >= num; i--){\n                    if (accessibility[i - num] == true){\n                        accessibility[i] = true;\n                    }\n                }\n            return accessibility[half];\n        }\n};\n```\n\nHowever it's space complex is O(n), so if you need a O(1) solution, I find a cool solution based on bitset.\n\n```\nbool canPartition(vector<int>& nums) {\n    bitset<5001> bits(1);\n    int sum = accumulate(nums.begin(), nums.end(), 0);\n    for (auto n : nums) bits |= bits << n;\n    return !(sum & 1) && bits[sum >> 1];\n}\n```\nWhy and how it works, remaining unknown.\n","slug":"PartitionEqualSubsetSum","published":1,"updated":"2017-01-06T08:37:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixr4kw6w000a6uf4ptab6nja","content":"<blockquote>\n<p>Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>\n<p>Note:</p>\n<ul>\n<li>Each of the array element will not exceed 100.</li>\n<li>The array size will not exceed 200.</li>\n</ul>\n<p>Example 1:</p>\n<p>Input: [1, 5, 11, 5]</p>\n<p>Output: true</p>\n<p>Explanation: The array can be partitioned as [1, 5, 5] and [11].</p>\n<p>Example 2:</p>\n<p>Input: [1, 2, 3, 5]</p>\n<p>Output: false</p>\n<p>Explanation: The array cannot be partitioned into equal sum subsets.</p>\n<p>Subscribe to see which companies asked this question</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 416, and it is a leetweek problem. My last pass code like these:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() &lt; 2) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int sum = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                sum = sum + nums[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (sum % 2 != 0) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return check(0, 0, nums, sum);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool check(int start, int current, vector&lt;int&gt; nums, int sum) &#123;</div><div class=\"line\">            bool res = false;</div><div class=\"line\">            if (current &gt; sum / 2) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (current == sum / 2) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = start + 1; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                res = res || check(i, current + nums[i], nums, sum);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>Because the time complex of this recursive functoin is O(n!), the worst condition. So, we can change our mind to turn this problem into another one.</p>\n<p>Find a set of the subarray which its sum is sum / 2. And we can use the DP solution.</p>\n<p>Because we know the sum of the array, so we make a array <strong>dp</strong> in size sum/2. And after a for loop. we will know the dp[num] and dp[sum/2 - num] can achieve. So, when we for twice, like:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (auto num : nums) &#123;</div><div class=\"line\">    for(int i = target; i &gt;= num; i--) &#123; // to be quick we don&apos;t visit the whole dp array</div><div class=\"line\">        dp[i] = dp[i] || dp[i - num];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>So, here comes a better solution based on DP:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            int sum = accumulate(nums.begin(), nums.end(), 0);</div><div class=\"line\">            if (sum &amp; 1) return false;</div><div class=\"line\">            int half = sum &gt;&gt; 1;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;bool&gt; accessibility(half + 1, false);</div><div class=\"line\">            accessibility[0] = true;    // &apos;0&apos; is always reachable</div><div class=\"line\">            //For all num in nums, check the accessibility from half - num to 0.</div><div class=\"line\">            //If &apos;i&apos; is accessible by former numbers, then &apos;i + num&apos; is also accessible. (DP Algorithm)</div><div class=\"line\">            for(int num: nums)</div><div class=\"line\">                //Below here we must start from &apos;half&apos; downto &apos;num&apos;, otherwise current &apos;num&apos; might be multiply used.</div><div class=\"line\">                //e.g.: If num == 2, then we will have 2, 4, 6... will all be accessible and lead to wrong answer.</div><div class=\"line\">                for(int i = half; i &gt;= num; i--)&#123;</div><div class=\"line\">                    if (accessibility[i - num] == true)&#123;</div><div class=\"line\">                        accessibility[i] = true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            return accessibility[half];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>However it’s space complex is O(n), so if you need a O(1) solution, I find a cool solution based on bitset.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    bitset&lt;5001&gt; bits(1);</div><div class=\"line\">    int sum = accumulate(nums.begin(), nums.end(), 0);</div><div class=\"line\">    for (auto n : nums) bits |= bits &lt;&lt; n;</div><div class=\"line\">    return !(sum &amp; 1) &amp;&amp; bits[sum &gt;&gt; 1];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Why and how it works, remaining unknown.</p>\n","excerpt":"<blockquote>\n<p>Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>\n<p>Note:</p>\n<ul>\n<li>Each of the array element will not exceed 100.</li>\n<li>The array size will not exceed 200.</li>\n</ul>\n<p>Example 1:</p>\n<p>Input: [1, 5, 11, 5]</p>\n<p>Output: true</p>\n<p>Explanation: The array can be partitioned as [1, 5, 5] and [11].</p>\n<p>Example 2:</p>\n<p>Input: [1, 2, 3, 5]</p>\n<p>Output: false</p>\n<p>Explanation: The array cannot be partitioned into equal sum subsets.</p>\n<p>Subscribe to see which companies asked this question</p>\n</blockquote>","more":"<p>This is Leetcode 416, and it is a leetweek problem. My last pass code like these:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() &lt; 2) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int sum = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                sum = sum + nums[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (sum % 2 != 0) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return check(0, 0, nums, sum);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool check(int start, int current, vector&lt;int&gt; nums, int sum) &#123;</div><div class=\"line\">            bool res = false;</div><div class=\"line\">            if (current &gt; sum / 2) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (current == sum / 2) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = start + 1; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                res = res || check(i, current + nums[i], nums, sum);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>Because the time complex of this recursive functoin is O(n!), the worst condition. So, we can change our mind to turn this problem into another one.</p>\n<p>Find a set of the subarray which its sum is sum / 2. And we can use the DP solution.</p>\n<p>Because we know the sum of the array, so we make a array <strong>dp</strong> in size sum/2. And after a for loop. we will know the dp[num] and dp[sum/2 - num] can achieve. So, when we for twice, like:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (auto num : nums) &#123;</div><div class=\"line\">    for(int i = target; i &gt;= num; i--) &#123; // to be quick we don&apos;t visit the whole dp array</div><div class=\"line\">        dp[i] = dp[i] || dp[i - num];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>So, here comes a better solution based on DP:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            int sum = accumulate(nums.begin(), nums.end(), 0);</div><div class=\"line\">            if (sum &amp; 1) return false;</div><div class=\"line\">            int half = sum &gt;&gt; 1;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;bool&gt; accessibility(half + 1, false);</div><div class=\"line\">            accessibility[0] = true;    // &apos;0&apos; is always reachable</div><div class=\"line\">            //For all num in nums, check the accessibility from half - num to 0.</div><div class=\"line\">            //If &apos;i&apos; is accessible by former numbers, then &apos;i + num&apos; is also accessible. (DP Algorithm)</div><div class=\"line\">            for(int num: nums)</div><div class=\"line\">                //Below here we must start from &apos;half&apos; downto &apos;num&apos;, otherwise current &apos;num&apos; might be multiply used.</div><div class=\"line\">                //e.g.: If num == 2, then we will have 2, 4, 6... will all be accessible and lead to wrong answer.</div><div class=\"line\">                for(int i = half; i &gt;= num; i--)&#123;</div><div class=\"line\">                    if (accessibility[i - num] == true)&#123;</div><div class=\"line\">                        accessibility[i] = true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            return accessibility[half];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>However it’s space complex is O(n), so if you need a O(1) solution, I find a cool solution based on bitset.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    bitset&lt;5001&gt; bits(1);</div><div class=\"line\">    int sum = accumulate(nums.begin(), nums.end(), 0);</div><div class=\"line\">    for (auto n : nums) bits |= bits &lt;&lt; n;</div><div class=\"line\">    return !(sum &amp; 1) &amp;&amp; bits[sum &gt;&gt; 1];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Why and how it works, remaining unknown.</p>"},{"title":"Path Sum III","date":"2017-01-07T11:46:25.000Z","_content":"\n> You are given a binary tree in which each node contains an integer value.\n>\n> Find the number of paths that sum to a given value.\n>\n> The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).\n>\n> The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.\n>\n> Example:\n>\n> root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8\n>\n>           10\n>          /  \\\n>         5   -3\n>        / \\    \\\n>       3   2   11\n>      / \\   \\\n>     3  -2   1\n>\n> Return 3. The paths that sum to 8 are:\n>\n> 1.  5 -> 3\n> 2.  5 -> 2 -> 1\n> 3. -3 -> 11\n\n<!-- more -->\n\n\nThis is Leetcode 437, easy problem, and it's solution as following:\n\n```\nclass Solution {\n    public:\n        int pathSum(TreeNode* root, int sum) {\n            if(root == NULL)\n                return 0;\n            return visit(root, sum) + pathSum(root->left, sum) + pathSum(root->right, sum);\n        }\n\n        int visit(TreeNode* node, int sum) {\n            int res = 0;\n            if(node == NULL)\n                return res;\n            if(sum == node->val)\n                res++;\n            res += visit(node->left, sum - node->val);\n            res += visit(node->right, sum - node->val);\n            return res;\n        }\n};\n```\n\nIt's time complex is O(nlogn) if it's a balanced tree while O(n^2) in the worst case.\n\nThe better solution is the DP solution using a map to store all the value of the tree node.\n\n```\nclass Solution {\n    public:\n        int help(TreeNode* root, int sum, unordered_map<int, int>& store, int pre) {\n            if (!root) return 0;\n            root->val += pre;\n            int res = (root->val == sum) + (store.count(root->val - sum) ? store[root->val - sum] : 0);\n            store[root->val]++;\n            res += help(root->left, sum, store, root->val) + help(root->right, sum, store, root->val);\n            store[root->val]--;\n            return res;\n        }\n\n        int pathSum(TreeNode* root, int sum) {\n            unordered_map<int, int> store;\n            return help(root, sum, store, 0);\n        }\n};\n```\n\nThat's it.\n","source":"_posts/PathSumIII.md","raw":"---\ntitle: Path Sum III\ndate: 2017-01-07 19:46:25\ntags:\n    - Tree\n---\n\n> You are given a binary tree in which each node contains an integer value.\n>\n> Find the number of paths that sum to a given value.\n>\n> The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).\n>\n> The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.\n>\n> Example:\n>\n> root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8\n>\n>           10\n>          /  \\\n>         5   -3\n>        / \\    \\\n>       3   2   11\n>      / \\   \\\n>     3  -2   1\n>\n> Return 3. The paths that sum to 8 are:\n>\n> 1.  5 -> 3\n> 2.  5 -> 2 -> 1\n> 3. -3 -> 11\n\n<!-- more -->\n\n\nThis is Leetcode 437, easy problem, and it's solution as following:\n\n```\nclass Solution {\n    public:\n        int pathSum(TreeNode* root, int sum) {\n            if(root == NULL)\n                return 0;\n            return visit(root, sum) + pathSum(root->left, sum) + pathSum(root->right, sum);\n        }\n\n        int visit(TreeNode* node, int sum) {\n            int res = 0;\n            if(node == NULL)\n                return res;\n            if(sum == node->val)\n                res++;\n            res += visit(node->left, sum - node->val);\n            res += visit(node->right, sum - node->val);\n            return res;\n        }\n};\n```\n\nIt's time complex is O(nlogn) if it's a balanced tree while O(n^2) in the worst case.\n\nThe better solution is the DP solution using a map to store all the value of the tree node.\n\n```\nclass Solution {\n    public:\n        int help(TreeNode* root, int sum, unordered_map<int, int>& store, int pre) {\n            if (!root) return 0;\n            root->val += pre;\n            int res = (root->val == sum) + (store.count(root->val - sum) ? store[root->val - sum] : 0);\n            store[root->val]++;\n            res += help(root->left, sum, store, root->val) + help(root->right, sum, store, root->val);\n            store[root->val]--;\n            return res;\n        }\n\n        int pathSum(TreeNode* root, int sum) {\n            unordered_map<int, int> store;\n            return help(root, sum, store, 0);\n        }\n};\n```\n\nThat's it.\n","slug":"PathSumIII","published":1,"updated":"2017-01-07T16:00:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixr4kw6y000c6uf4i1x15jqx","content":"<blockquote>\n<p>You are given a binary tree in which each node contains an integer value.</p>\n<p>Find the number of paths that sum to a given value.</p>\n<p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p>\n<p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p>\n<p>Example:</p>\n<p>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</p>\n<pre><code>      10\n     /  \\\n    5   -3\n   / \\    \\\n  3   2   11\n / \\   \\\n3  -2   1\n</code></pre><p>Return 3. The paths that sum to 8 are:</p>\n<ol>\n<li>5 -&gt; 3</li>\n<li>5 -&gt; 2 -&gt; 1</li>\n<li>-3 -&gt; 11</li>\n</ol>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 437, easy problem, and it’s solution as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int pathSum(TreeNode* root, int sum) &#123;</div><div class=\"line\">            if(root == NULL)</div><div class=\"line\">                return 0;</div><div class=\"line\">            return visit(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int visit(TreeNode* node, int sum) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            if(node == NULL)</div><div class=\"line\">                return res;</div><div class=\"line\">            if(sum == node-&gt;val)</div><div class=\"line\">                res++;</div><div class=\"line\">            res += visit(node-&gt;left, sum - node-&gt;val);</div><div class=\"line\">            res += visit(node-&gt;right, sum - node-&gt;val);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It’s time complex is O(nlogn) if it’s a balanced tree while O(n^2) in the worst case.</p>\n<p>The better solution is the DP solution using a map to store all the value of the tree node.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int help(TreeNode* root, int sum, unordered_map&lt;int, int&gt;&amp; store, int pre) &#123;</div><div class=\"line\">            if (!root) return 0;</div><div class=\"line\">            root-&gt;val += pre;</div><div class=\"line\">            int res = (root-&gt;val == sum) + (store.count(root-&gt;val - sum) ? store[root-&gt;val - sum] : 0);</div><div class=\"line\">            store[root-&gt;val]++;</div><div class=\"line\">            res += help(root-&gt;left, sum, store, root-&gt;val) + help(root-&gt;right, sum, store, root-&gt;val);</div><div class=\"line\">            store[root-&gt;val]--;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int pathSum(TreeNode* root, int sum) &#123;</div><div class=\"line\">            unordered_map&lt;int, int&gt; store;</div><div class=\"line\">            return help(root, sum, store, 0);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>That’s it.</p>\n","excerpt":"<blockquote>\n<p>You are given a binary tree in which each node contains an integer value.</p>\n<p>Find the number of paths that sum to a given value.</p>\n<p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p>\n<p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p>\n<p>Example:</p>\n<p>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</p>\n<pre><code>      10\n     /  \\\n    5   -3\n   / \\    \\\n  3   2   11\n / \\   \\\n3  -2   1\n</code></pre><p>Return 3. The paths that sum to 8 are:</p>\n<ol>\n<li>5 -&gt; 3</li>\n<li>5 -&gt; 2 -&gt; 1</li>\n<li>-3 -&gt; 11</li>\n</ol>\n</blockquote>","more":"<p>This is Leetcode 437, easy problem, and it’s solution as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int pathSum(TreeNode* root, int sum) &#123;</div><div class=\"line\">            if(root == NULL)</div><div class=\"line\">                return 0;</div><div class=\"line\">            return visit(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int visit(TreeNode* node, int sum) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            if(node == NULL)</div><div class=\"line\">                return res;</div><div class=\"line\">            if(sum == node-&gt;val)</div><div class=\"line\">                res++;</div><div class=\"line\">            res += visit(node-&gt;left, sum - node-&gt;val);</div><div class=\"line\">            res += visit(node-&gt;right, sum - node-&gt;val);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It’s time complex is O(nlogn) if it’s a balanced tree while O(n^2) in the worst case.</p>\n<p>The better solution is the DP solution using a map to store all the value of the tree node.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int help(TreeNode* root, int sum, unordered_map&lt;int, int&gt;&amp; store, int pre) &#123;</div><div class=\"line\">            if (!root) return 0;</div><div class=\"line\">            root-&gt;val += pre;</div><div class=\"line\">            int res = (root-&gt;val == sum) + (store.count(root-&gt;val - sum) ? store[root-&gt;val - sum] : 0);</div><div class=\"line\">            store[root-&gt;val]++;</div><div class=\"line\">            res += help(root-&gt;left, sum, store, root-&gt;val) + help(root-&gt;right, sum, store, root-&gt;val);</div><div class=\"line\">            store[root-&gt;val]--;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int pathSum(TreeNode* root, int sum) &#123;</div><div class=\"line\">            unordered_map&lt;int, int&gt; store;</div><div class=\"line\">            return help(root, sum, store, 0);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>That’s it.</p>"},{"title":"Total Hamming Distance","date":"2017-01-02T05:46:25.000Z","_content":"\n> The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\n>\n> Now your job is to find the total Hamming distance between all pairs of the given numbers.\n>\n> Example:\n>\n> Input: 4, 14, 2\n>\n> Output: 6\n>\n> Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just\n> showing the four bits relevant in this case). So the answer will be:\n> HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\n>\n> Note:\n>\n> + Elements of the given array are in the range of 0 to 10^9\n> + Length of the array will not exceed 10^4.\n>\n> Subscribe to see which companies asked this question\n\n<!--more-->\n\nThis is the leetcode No.477, we can quickly find a solution like this:\n\n```\nusing namespace std;\n\nclass Solution {\npublic:\n    int totalHammingDistance(vector<int>& nums) {\n        int sum = 0;\n        for (int i = 0; i < (int)nums.size() - 1; i++) {\n            for (int j = i + 1; j < (int)nums.size(); j++) {\n                sum += hamming_distance(nums[i], nums[j]);\n            }\n        }\n        return sum;\n    }\n\n    int hamming_distance(unsigned long long x, unsigned long long y) {\n        return __builtin_popcountll(x ^ y);\n    }\n};\n```\n\nIt is correct, however it time complex is O(n^2), and the result is TLE.\n\nSo, I found a better solution here. As we can see from the question, we can find the number is int type, and no larger than 2^32 in that we use a 32 bit size bitmap. For better explaination, I use 8 bit size as example.\n\n```\n0000 0000\n1110 0010\n1101 0101\n```\n\nWe get such an array, and we just need to figure out how many 1s in each index. Take 1st index as an example, we get one 1 bit, and the total distance for the 1st index is (3-1)*(1) which stands for (n - bitCount) * bitCount.\n\nSo, what we should do is to add the total 32 bits.\n\nLast, here comes to a solution:\n\n```\nint totalHammingDistance(vector<int>& nums) {\n    int total = 0, bitCount = 0;\n    for (int idx = 0; idx < 32; idx++) {\n        for (int i = 0; i < (int)nums.size(); i++) {\n            bitCount += (nums[i] >> idx) & 1;\n        }\n        total += bitCount * (nums.size() - bitCount);\n    }\n    return total;\n}\n```\n\nAnd it's time complex is O(n*32) which means O(n) and it's accepted.\n","source":"_posts/TotalHammingDistance.md","raw":"---\ntitle: Total Hamming Distance\ndate: 2017-01-02 13:46:25\ntags: \n    - Bitmap\n---\n\n> The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\n>\n> Now your job is to find the total Hamming distance between all pairs of the given numbers.\n>\n> Example:\n>\n> Input: 4, 14, 2\n>\n> Output: 6\n>\n> Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just\n> showing the four bits relevant in this case). So the answer will be:\n> HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\n>\n> Note:\n>\n> + Elements of the given array are in the range of 0 to 10^9\n> + Length of the array will not exceed 10^4.\n>\n> Subscribe to see which companies asked this question\n\n<!--more-->\n\nThis is the leetcode No.477, we can quickly find a solution like this:\n\n```\nusing namespace std;\n\nclass Solution {\npublic:\n    int totalHammingDistance(vector<int>& nums) {\n        int sum = 0;\n        for (int i = 0; i < (int)nums.size() - 1; i++) {\n            for (int j = i + 1; j < (int)nums.size(); j++) {\n                sum += hamming_distance(nums[i], nums[j]);\n            }\n        }\n        return sum;\n    }\n\n    int hamming_distance(unsigned long long x, unsigned long long y) {\n        return __builtin_popcountll(x ^ y);\n    }\n};\n```\n\nIt is correct, however it time complex is O(n^2), and the result is TLE.\n\nSo, I found a better solution here. As we can see from the question, we can find the number is int type, and no larger than 2^32 in that we use a 32 bit size bitmap. For better explaination, I use 8 bit size as example.\n\n```\n0000 0000\n1110 0010\n1101 0101\n```\n\nWe get such an array, and we just need to figure out how many 1s in each index. Take 1st index as an example, we get one 1 bit, and the total distance for the 1st index is (3-1)*(1) which stands for (n - bitCount) * bitCount.\n\nSo, what we should do is to add the total 32 bits.\n\nLast, here comes to a solution:\n\n```\nint totalHammingDistance(vector<int>& nums) {\n    int total = 0, bitCount = 0;\n    for (int idx = 0; idx < 32; idx++) {\n        for (int i = 0; i < (int)nums.size(); i++) {\n            bitCount += (nums[i] >> idx) & 1;\n        }\n        total += bitCount * (nums.size() - bitCount);\n    }\n    return total;\n}\n```\n\nAnd it's time complex is O(n*32) which means O(n) and it's accepted.\n","slug":"TotalHammingDistance","published":1,"updated":"2017-01-03T06:47:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixr4kw6z000f6uf4hwa2uz2o","content":"<blockquote>\n<p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p>\n<p>Now your job is to find the total Hamming distance between all pairs of the given numbers.</p>\n<p>Example:</p>\n<p>Input: 4, 14, 2</p>\n<p>Output: 6</p>\n<p>Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just<br>showing the four bits relevant in this case). So the answer will be:<br>HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</p>\n<p>Note:</p>\n<ul>\n<li>Elements of the given array are in the range of 0 to 10^9</li>\n<li>Length of the array will not exceed 10^4.</li>\n</ul>\n<p>Subscribe to see which companies asked this question</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is the leetcode No.477, we can quickly find a solution like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">        int sum = 0;</div><div class=\"line\">        for (int i = 0; i &lt; (int)nums.size() - 1; i++) &#123;</div><div class=\"line\">            for (int j = i + 1; j &lt; (int)nums.size(); j++) &#123;</div><div class=\"line\">                sum += hamming_distance(nums[i], nums[j]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return sum;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int hamming_distance(unsigned long long x, unsigned long long y) &#123;</div><div class=\"line\">        return __builtin_popcountll(x ^ y);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It is correct, however it time complex is O(n^2), and the result is TLE.</p>\n<p>So, I found a better solution here. As we can see from the question, we can find the number is int type, and no larger than 2^32 in that we use a 32 bit size bitmap. For better explaination, I use 8 bit size as example.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">0000 0000</div><div class=\"line\">1110 0010</div><div class=\"line\">1101 0101</div></pre></td></tr></table></figure>\n<p>We get such an array, and we just need to figure out how many 1s in each index. Take 1st index as an example, we get one 1 bit, and the total distance for the 1st index is (3-1)<em>(1) which stands for (n - bitCount) </em> bitCount.</p>\n<p>So, what we should do is to add the total 32 bits.</p>\n<p>Last, here comes to a solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    int total = 0, bitCount = 0;</div><div class=\"line\">    for (int idx = 0; idx &lt; 32; idx++) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">            bitCount += (nums[i] &gt;&gt; idx) &amp; 1;</div><div class=\"line\">        &#125;</div><div class=\"line\">        total += bitCount * (nums.size() - bitCount);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return total;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>And it’s time complex is O(n*32) which means O(n) and it’s accepted.</p>\n","excerpt":"<blockquote>\n<p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p>\n<p>Now your job is to find the total Hamming distance between all pairs of the given numbers.</p>\n<p>Example:</p>\n<p>Input: 4, 14, 2</p>\n<p>Output: 6</p>\n<p>Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just<br>showing the four bits relevant in this case). So the answer will be:<br>HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</p>\n<p>Note:</p>\n<ul>\n<li>Elements of the given array are in the range of 0 to 10^9</li>\n<li>Length of the array will not exceed 10^4.</li>\n</ul>\n<p>Subscribe to see which companies asked this question</p>\n</blockquote>","more":"<p>This is the leetcode No.477, we can quickly find a solution like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">        int sum = 0;</div><div class=\"line\">        for (int i = 0; i &lt; (int)nums.size() - 1; i++) &#123;</div><div class=\"line\">            for (int j = i + 1; j &lt; (int)nums.size(); j++) &#123;</div><div class=\"line\">                sum += hamming_distance(nums[i], nums[j]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return sum;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int hamming_distance(unsigned long long x, unsigned long long y) &#123;</div><div class=\"line\">        return __builtin_popcountll(x ^ y);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It is correct, however it time complex is O(n^2), and the result is TLE.</p>\n<p>So, I found a better solution here. As we can see from the question, we can find the number is int type, and no larger than 2^32 in that we use a 32 bit size bitmap. For better explaination, I use 8 bit size as example.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">0000 0000</div><div class=\"line\">1110 0010</div><div class=\"line\">1101 0101</div></pre></td></tr></table></figure>\n<p>We get such an array, and we just need to figure out how many 1s in each index. Take 1st index as an example, we get one 1 bit, and the total distance for the 1st index is (3-1)<em>(1) which stands for (n - bitCount) </em> bitCount.</p>\n<p>So, what we should do is to add the total 32 bits.</p>\n<p>Last, here comes to a solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    int total = 0, bitCount = 0;</div><div class=\"line\">    for (int idx = 0; idx &lt; 32; idx++) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">            bitCount += (nums[i] &gt;&gt; idx) &amp; 1;</div><div class=\"line\">        &#125;</div><div class=\"line\">        total += bitCount * (nums.size() - bitCount);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return total;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>And it’s time complex is O(n*32) which means O(n) and it’s accepted.</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cixr4kw6800006uf44aq1kxi3","tag_id":"cixr4kw6e00026uf4qwo4vx8z","_id":"cixr4kw6w000b6uf4z7lpo4ri"},{"post_id":"cixr4kw6800006uf44aq1kxi3","tag_id":"cixr4kw6o00066uf4ua45gg4w","_id":"cixr4kw6y000d6uf44adskvqo"},{"post_id":"cixr4kw6c00016uf4mzcpgdyg","tag_id":"cixr4kw6u00096uf4odoq5fq2","_id":"cixr4kw71000g6uf400vhu90v"},{"post_id":"cixr4kw6h00036uf435w229ku","tag_id":"cixr4kw6z000e6uf414vmm1mn","_id":"cixr4kw71000i6uf4hzxnv8pd"},{"post_id":"cixr4kw6j00046uf4m95xzh6c","tag_id":"cixr4kw71000h6uf4jtd2q8y9","_id":"cixr4kw73000k6uf47s8zb35d"},{"post_id":"cixr4kw6n00056uf4k4jbb6bq","tag_id":"cixr4kw71000h6uf4jtd2q8y9","_id":"cixr4kw74000o6uf4dkaod93h"},{"post_id":"cixr4kw6n00056uf4k4jbb6bq","tag_id":"cixr4kw6e00026uf4qwo4vx8z","_id":"cixr4kw74000p6uf4z8sfuf8l"},{"post_id":"cixr4kw6n00056uf4k4jbb6bq","tag_id":"cixr4kw73000l6uf4p0ghijce","_id":"cixr4kw75000r6uf4p6em2laf"},{"post_id":"cixr4kw6n00056uf4k4jbb6bq","tag_id":"cixr4kw73000m6uf4rb3wnyyj","_id":"cixr4kw75000s6uf4s74o3f8o"},{"post_id":"cixr4kw6q00076uf41y948ltz","tag_id":"cixr4kw74000n6uf47vq663eh","_id":"cixr4kw76000v6uf4yiqghw21"},{"post_id":"cixr4kw6q00076uf41y948ltz","tag_id":"cixr4kw74000q6uf47mq0rjmn","_id":"cixr4kw76000w6uf47dvynika"},{"post_id":"cixr4kw6q00076uf41y948ltz","tag_id":"cixr4kw75000t6uf4ho26wfy7","_id":"cixr4kw77000y6uf4trk0e4xr"},{"post_id":"cixr4kw6s00086uf45zq44k1z","tag_id":"cixr4kw76000u6uf4rwyadsbr","_id":"cixr4kw77000z6uf49g9hyrqt"},{"post_id":"cixr4kw6w000a6uf4ptab6nja","tag_id":"cixr4kw76000x6uf4rne5j7yo","_id":"cixr4kw7700116uf4ty1mmu7l"},{"post_id":"cixr4kw6y000c6uf4i1x15jqx","tag_id":"cixr4kw7700106uf481uxqmnj","_id":"cixr4kw7800136uf4qfkd46ii"},{"post_id":"cixr4kw6z000f6uf4hwa2uz2o","tag_id":"cixr4kw7700126uf43q35ou5s","_id":"cixr4kw7800146uf4h22drs14"}],"Tag":[{"name":"Hash Table","_id":"cixr4kw6e00026uf4qwo4vx8z"},{"name":"String","_id":"cixr4kw6o00066uf4ua45gg4w"},{"name":"Stack","_id":"cixr4kw6u00096uf4odoq5fq2"},{"name":"Simulation","_id":"cixr4kw6z000e6uf414vmm1mn"},{"name":"Binary Search","_id":"cixr4kw71000h6uf4jtd2q8y9"},{"name":"Two Pointers","_id":"cixr4kw73000l6uf4p0ghijce"},{"name":"Sort","_id":"cixr4kw73000m6uf4rb3wnyyj"},{"name":"Depth-first Search","_id":"cixr4kw74000n6uf47vq663eh"},{"name":"Memoization","_id":"cixr4kw74000q6uf47mq0rjmn"},{"name":"Topological sort","_id":"cixr4kw75000t6uf4ho26wfy7"},{"name":"Description","_id":"cixr4kw76000u6uf4rwyadsbr"},{"name":"Dynamic Programming","_id":"cixr4kw76000x6uf4rne5j7yo"},{"name":"Tree","_id":"cixr4kw7700106uf481uxqmnj"},{"name":"Bitmap","_id":"cixr4kw7700126uf43q35ou5s"}]}}